
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>10.1. Language options &mdash; Glasgow Haskell Compiler 8.2.2 User&#39;s Guide</title>
    
    <link rel="stylesheet" href="_static/ghc-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 8.2.2 User&#39;s Guide"
          href="_static/opensearch.xml"/>
    <link rel="top" title="Glasgow Haskell Compiler 8.2.2 User&#39;s Guide" href="index.html" />
    <link rel="up" title="10. GHC Language Features" href="lang.html" />
    <link rel="next" title="10.38. Concurrent and Parallel Haskell" href="parallel.html" />
    <link rel="prev" title="10. GHC Language Features" href="lang.html" /> 
  </head>
  <body role="document">
<div class="logo">
    <h1><a href="index.html">Glasgow Haskell Compiler User's Guide</a></h1>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="parallel.html" title="10.38. Concurrent and Parallel Haskell"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="lang.html" title="10. GHC Language Features"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.2.2 User&#39;s Guide</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="lang.html" accesskey="U">10. GHC Language Features</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">10.1. Language options</a></li>
<li><a class="reference internal" href="#unboxed-types-and-primitive-operations">10.2. Unboxed types and primitive operations</a><ul>
<li><a class="reference internal" href="#unboxed-types">10.2.1. Unboxed types</a></li>
<li><a class="reference internal" href="#unboxed-type-kinds">10.2.2. Unboxed type kinds</a></li>
<li><a class="reference internal" href="#unboxed-tuples">10.2.3. Unboxed tuples</a></li>
<li><a class="reference internal" href="#unboxed-sums">10.2.4. Unboxed sums</a></li>
</ul>
</li>
<li><a class="reference internal" href="#syntactic-extensions">10.3. Syntactic extensions</a><ul>
<li><a class="reference internal" href="#unicode-syntax">10.3.1. Unicode syntax</a></li>
<li><a class="reference internal" href="#the-magic-hash">10.3.2. The magic hash</a></li>
<li><a class="reference internal" href="#negative-literals">10.3.3. Negative literals</a></li>
<li><a class="reference internal" href="#fractional-looking-integer-literals">10.3.4. Fractional looking integer literals</a></li>
<li><a class="reference internal" href="#binary-integer-literals">10.3.5. Binary integer literals</a></li>
<li><a class="reference internal" href="#pattern-guards">10.3.6. Pattern guards</a></li>
<li><a class="reference internal" href="#view-patterns">10.3.7. View patterns</a></li>
<li><a class="reference internal" href="#n-k-patterns">10.3.8. n+k patterns</a></li>
<li><a class="reference internal" href="#the-recursive-do-notation">10.3.9. The recursive do-notation</a><ul>
<li><a class="reference internal" href="#recursive-binding-groups">10.3.9.1. Recursive binding groups</a></li>
<li><a class="reference internal" href="#the-mdo-notation">10.3.9.2. The <code class="docutils literal"><span class="pre">mdo</span></code> notation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#applicative-do-notation">10.3.10. Applicative do-notation</a><ul>
<li><a class="reference internal" href="#existential-patterns-and-gadts">10.3.10.1. Existential patterns and GADTs</a></li>
<li><a class="reference internal" href="#things-to-watch-out-for">10.3.10.2. Things to watch out for</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parallel-list-comprehensions">10.3.11. Parallel List Comprehensions</a></li>
<li><a class="reference internal" href="#generalised-sql-like-list-comprehensions">10.3.12. Generalised (SQL-like) List Comprehensions</a></li>
<li><a class="reference internal" href="#monad-comprehensions">10.3.13. Monad comprehensions</a></li>
<li><a class="reference internal" href="#new-monadic-failure-desugaring-mechanism">10.3.14. New monadic failure desugaring mechanism</a></li>
<li><a class="reference internal" href="#rebindable-syntax-and-the-implicit-prelude-import">10.3.15. Rebindable syntax and the implicit Prelude import</a><ul>
<li><a class="reference internal" href="#things-unaffected-by-xrebindablesyntax">10.3.15.1. Things unaffected by <code class="docutils literal"><span class="pre">-XRebindableSyntax</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#postfix-operators">10.3.16. Postfix operators</a></li>
<li><a class="reference internal" href="#tuple-sections">10.3.17. Tuple sections</a></li>
<li><a class="reference internal" href="#lambda-case">10.3.18. Lambda-case</a></li>
<li><a class="reference internal" href="#empty-case-alternatives">10.3.19. Empty case alternatives</a></li>
<li><a class="reference internal" href="#multi-way-if-expressions">10.3.20. Multi-way if-expressions</a></li>
<li><a class="reference internal" href="#local-fixity-declarations">10.3.21. Local Fixity Declarations</a></li>
<li><a class="reference internal" href="#import-and-export-extensions">10.3.22. Import and export extensions</a><ul>
<li><a class="reference internal" href="#hiding-things-the-imported-module-doesn-t-export">10.3.22.1. Hiding things the imported module doesn&#8217;t export</a></li>
<li><a class="reference internal" href="#package-qualified-imports">10.3.22.2. Package-qualified imports</a></li>
<li><a class="reference internal" href="#safe-imports">10.3.22.3. Safe imports</a></li>
<li><a class="reference internal" href="#explicit-namespaces-in-import-export">10.3.22.4. Explicit namespaces in import/export</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-stolen-syntax">10.3.23. Summary of stolen syntax</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extensions-to-data-types-and-type-synonyms">10.4. Extensions to data types and type synonyms</a><ul>
<li><a class="reference internal" href="#data-types-with-no-constructors">10.4.1. Data types with no constructors</a></li>
<li><a class="reference internal" href="#data-type-contexts">10.4.2. Data type contexts</a></li>
<li><a class="reference internal" href="#infix-type-constructors-classes-and-type-variables">10.4.3. Infix type constructors, classes, and type variables</a></li>
<li><a class="reference internal" href="#type-operators">10.4.4. Type operators</a></li>
<li><a class="reference internal" href="#liberalised-type-synonyms">10.4.5. Liberalised type synonyms</a></li>
<li><a class="reference internal" href="#existentially-quantified-data-constructors">10.4.6. Existentially quantified data constructors</a><ul>
<li><a class="reference internal" href="#why-existential">10.4.6.1. Why existential?</a></li>
<li><a class="reference internal" href="#existentials-and-type-classes">10.4.6.2. Existentials and type classes</a></li>
<li><a class="reference internal" href="#record-constructors">10.4.6.3. Record Constructors</a></li>
<li><a class="reference internal" href="#restrictions">10.4.6.4. Restrictions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#declaring-data-types-with-explicit-constructor-signatures">10.4.7. Declaring data types with explicit constructor signatures</a></li>
<li><a class="reference internal" href="#generalised-algebraic-data-types-gadts">10.4.8. Generalised Algebraic Data Types (GADTs)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extensions-to-the-record-system">10.5. Extensions to the record system</a><ul>
<li><a class="reference internal" href="#traditional-record-syntax">10.5.1. Traditional record syntax</a></li>
<li><a class="reference internal" href="#record-field-disambiguation">10.5.2. Record field disambiguation</a></li>
<li><a class="reference internal" href="#duplicate-record-fields">10.5.3. Duplicate record fields</a><ul>
<li><a class="reference internal" href="#selector-functions">10.5.3.1. Selector functions</a></li>
<li><a class="reference internal" href="#record-updates">10.5.3.2. Record updates</a></li>
<li><a class="reference internal" href="#import-and-export-of-record-fields">10.5.3.3. Import and export of record fields</a></li>
</ul>
</li>
<li><a class="reference internal" href="#record-puns">10.5.4. Record puns</a></li>
<li><a class="reference internal" href="#record-wildcards">10.5.5. Record wildcards</a></li>
<li><a class="reference internal" href="#record-field-selector-polymorphism">10.5.6. Record field selector polymorphism</a><ul>
<li><a class="reference internal" href="#solving-hasfield-constraints">10.5.6.1. Solving HasField constraints</a></li>
<li><a class="reference internal" href="#virtual-record-fields">10.5.6.2. Virtual record fields</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#extensions-to-the-deriving-mechanism">10.6. Extensions to the &#8220;deriving&#8221; mechanism</a><ul>
<li><a class="reference internal" href="#inferred-context-for-deriving-clauses">10.6.1. Inferred context for deriving clauses</a></li>
<li><a class="reference internal" href="#stand-alone-deriving-declarations">10.6.2. Stand-alone deriving declarations</a></li>
<li><a class="reference internal" href="#deriving-instances-of-extra-classes-data-etc">10.6.3. Deriving instances of extra classes (<code class="docutils literal"><span class="pre">Data</span></code>, etc.)</a></li>
<li><a class="reference internal" href="#deriving-functor-instances">10.6.4. Deriving <code class="docutils literal"><span class="pre">Functor</span></code> instances</a></li>
<li><a class="reference internal" href="#deriving-foldable-instances">10.6.5. Deriving <code class="docutils literal"><span class="pre">Foldable</span></code> instances</a></li>
<li><a class="reference internal" href="#deriving-traversable-instances">10.6.6. Deriving <code class="docutils literal"><span class="pre">Traversable</span></code> instances</a></li>
<li><a class="reference internal" href="#deriving-data-instances">10.6.7. Deriving <code class="docutils literal"><span class="pre">Data</span></code> instances</a></li>
<li><a class="reference internal" href="#deriving-typeable-instances">10.6.8. Deriving <code class="docutils literal"><span class="pre">Typeable</span></code> instances</a></li>
<li><a class="reference internal" href="#deriving-lift-instances">10.6.9. Deriving <code class="docutils literal"><span class="pre">Lift</span></code> instances</a></li>
<li><a class="reference internal" href="#generalised-derived-instances-for-newtypes">10.6.10. Generalised derived instances for newtypes</a><ul>
<li><a class="reference internal" href="#generalising-the-deriving-clause">10.6.10.1. Generalising the deriving clause</a></li>
<li><a class="reference internal" href="#a-more-precise-specification">10.6.10.2. A more precise specification</a></li>
<li><a class="reference internal" href="#associated-type-families">10.6.10.3. Associated type families</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deriving-any-other-class">10.6.11. Deriving any other class</a></li>
<li><a class="reference internal" href="#deriving-strategies">10.6.12. Deriving strategies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pattern-synonyms">10.7. Pattern synonyms</a><ul>
<li><a class="reference internal" href="#record-pattern-synonyms">10.7.1. Record Pattern Synonyms</a></li>
<li><a class="reference internal" href="#syntax-and-scoping-of-pattern-synonyms">10.7.2. Syntax and scoping of pattern synonyms</a></li>
<li><a class="reference internal" href="#import-and-export-of-pattern-synonyms">10.7.3. Import and export of pattern synonyms</a></li>
<li><a class="reference internal" href="#typing-of-pattern-synonyms">10.7.4. Typing of pattern synonyms</a></li>
<li><a class="reference internal" href="#matching-of-pattern-synonyms">10.7.5. Matching of pattern synonyms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-instances-declarations">10.8. Class and instances declarations</a><ul>
<li><a class="reference internal" href="#class-declarations">10.8.1. Class declarations</a><ul>
<li><a class="reference internal" href="#multi-parameter-type-classes">10.8.1.1. Multi-parameter type classes</a></li>
<li><a class="reference internal" href="#the-superclasses-of-a-class-declaration">10.8.1.2. The superclasses of a class declaration</a></li>
<li><a class="reference internal" href="#constrained-class-method-types">10.8.1.3. Constrained class method types</a></li>
<li><a class="reference internal" href="#default-method-signatures">10.8.1.4. Default method signatures</a></li>
<li><a class="reference internal" href="#nullary-type-classes">10.8.1.5. Nullary type classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functional-dependencies">10.8.2. Functional dependencies</a><ul>
<li><a class="reference internal" href="#rules-for-functional-dependencies">10.8.2.1. Rules for functional dependencies</a></li>
<li><a class="reference internal" href="#background-on-functional-dependencies">10.8.2.2. Background on functional dependencies</a><ul>
<li><a class="reference internal" href="#an-attempt-to-use-constructor-classes">10.8.2.2.1. An attempt to use constructor classes</a></li>
<li><a class="reference internal" href="#adding-functional-dependencies">10.8.2.2.2. Adding functional dependencies</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#instance-declarations">10.8.3. Instance declarations</a><ul>
<li><a class="reference internal" href="#instance-resolution">10.8.3.1. Instance resolution</a></li>
<li><a class="reference internal" href="#relaxed-rules-for-the-instance-head">10.8.3.2. Relaxed rules for the instance head</a></li>
<li><a class="reference internal" href="#relaxed-rules-for-instance-contexts">10.8.3.3. Relaxed rules for instance contexts</a></li>
<li><a class="reference internal" href="#instance-termination-rules">10.8.3.4. Instance termination rules</a></li>
<li><a class="reference internal" href="#undecidable-instances">10.8.3.5. Undecidable instances</a></li>
<li><a class="reference internal" href="#overlapping-instances">10.8.3.6. Overlapping instances</a></li>
<li><a class="reference internal" href="#instance-signatures-type-signatures-in-instance-declarations">10.8.3.7. Instance signatures: type signatures in instance declarations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overloaded-string-literals">10.8.4. Overloaded string literals</a></li>
<li><a class="reference internal" href="#overloaded-labels">10.8.5. Overloaded labels</a></li>
<li><a class="reference internal" href="#overloaded-lists">10.8.6. Overloaded lists</a><ul>
<li><a class="reference internal" href="#the-islist-class">10.8.6.1. The <code class="docutils literal"><span class="pre">IsList</span></code> class</a></li>
<li><a class="reference internal" href="#id32">10.8.6.2. Rebindable syntax</a></li>
<li><a class="reference internal" href="#defaulting">10.8.6.3. Defaulting</a></li>
<li><a class="reference internal" href="#speculation-about-the-future">10.8.6.4. Speculation about the future</a></li>
</ul>
</li>
<li><a class="reference internal" href="#undecidable-or-recursive-superclasses">10.8.7. Undecidable (or recursive) superclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-families">10.9. Type families</a><ul>
<li><a class="reference internal" href="#data-families">10.9.1. Data families</a><ul>
<li><a class="reference internal" href="#data-family-declarations">10.9.1.1. Data family declarations</a></li>
<li><a class="reference internal" href="#data-instance-declarations">10.9.1.2. Data instance declarations</a></li>
<li><a class="reference internal" href="#overlap-of-data-instances">10.9.1.3. Overlap of data instances</a></li>
</ul>
</li>
<li><a class="reference internal" href="#synonym-families">10.9.2. Synonym families</a><ul>
<li><a class="reference internal" href="#type-family-declarations">10.9.2.1. Type family declarations</a></li>
<li><a class="reference internal" href="#type-instance-declarations">10.9.2.2. Type instance declarations</a></li>
<li><a class="reference internal" href="#closed-type-families">10.9.2.3. Closed type families</a></li>
<li><a class="reference internal" href="#type-family-examples">10.9.2.4. Type family examples</a></li>
<li><a class="reference internal" href="#compatibility-and-apartness-of-type-family-equations">10.9.2.5. Compatibility and apartness of type family equations</a></li>
<li><a class="reference internal" href="#decidability-of-type-synonym-instances">10.9.2.6. Decidability of type synonym instances</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wildcards-on-the-lhs-of-data-and-type-family-instances">10.9.3. Wildcards on the LHS of data and type family instances</a></li>
<li><a class="reference internal" href="#associated-data-and-type-families">10.9.4. Associated data and type families</a><ul>
<li><a class="reference internal" href="#associated-instances">10.9.4.1. Associated instances</a></li>
<li><a class="reference internal" href="#associated-type-synonym-defaults">10.9.4.2. Associated type synonym defaults</a></li>
<li><a class="reference internal" href="#scoping-of-class-parameters">10.9.4.3. Scoping of class parameters</a></li>
<li><a class="reference internal" href="#instance-contexts-and-associated-type-and-data-instances">10.9.4.4. Instance contexts and associated type and data instances</a></li>
</ul>
</li>
<li><a class="reference internal" href="#import-and-export">10.9.5. Import and export</a><ul>
<li><a class="reference internal" href="#examples">10.9.5.1. Examples</a></li>
<li><a class="reference internal" href="#instances">10.9.5.2. Instances</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-families-and-instance-declarations">10.9.6. Type families and instance declarations</a></li>
<li><a class="reference internal" href="#injective-type-families">10.9.7. Injective type families</a><ul>
<li><a class="reference internal" href="#syntax-of-injectivity-annotation">10.9.7.1. Syntax of injectivity annotation</a></li>
<li><a class="reference internal" href="#verifying-injectivity-annotation-against-type-family-equations">10.9.7.2. Verifying injectivity annotation against type family equations</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#datatype-promotion">10.10. Datatype promotion</a><ul>
<li><a class="reference internal" href="#motivation">10.10.1. Motivation</a></li>
<li><a class="reference internal" href="#overview">10.10.2. Overview</a></li>
<li><a class="reference internal" href="#distinguishing-between-types-and-constructors">10.10.3. Distinguishing between types and constructors</a></li>
<li><a class="reference internal" href="#promoted-list-and-tuple-types">10.10.4. Promoted list and tuple types</a></li>
<li><a class="reference internal" href="#promoting-existential-data-constructors">10.10.5. Promoting existential data constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kind-polymorphism-and-type-in-type">10.11. Kind polymorphism and Type-in-Type</a><ul>
<li><a class="reference internal" href="#the-difference-between-xtypeintype-and-xpolykinds">10.11.1. The difference between <code class="docutils literal"><span class="pre">-XTypeInType</span></code> and <code class="docutils literal"><span class="pre">-XPolyKinds</span></code></a></li>
<li><a class="reference internal" href="#overview-of-kind-polymorphism">10.11.2. Overview of kind polymorphism</a></li>
<li><a class="reference internal" href="#overview-of-type-in-type">10.11.3. Overview of Type-in-Type</a></li>
<li><a class="reference internal" href="#principles-of-kind-inference">10.11.4. Principles of kind inference</a></li>
<li><a class="reference internal" href="#complete-user-supplied-kind-signatures-and-polymorphic-recursion">10.11.5. Complete user-supplied kind signatures and polymorphic recursion</a></li>
<li><a class="reference internal" href="#kind-inference-in-closed-type-families">10.11.6. Kind inference in closed type families</a></li>
<li><a class="reference internal" href="#kind-inference-in-class-instance-declarations">10.11.7. Kind inference in class instance declarations</a></li>
<li><a class="reference internal" href="#kind-inference-in-type-signatures">10.11.8. Kind inference in type signatures</a></li>
<li><a class="reference internal" href="#explicit-kind-quantification">10.11.9. Explicit kind quantification</a></li>
<li><a class="reference internal" href="#kind-indexed-gadts">10.11.10. Kind-indexed GADTs</a></li>
<li><a class="reference internal" href="#constraints-in-kinds">10.11.11. Constraints in kinds</a></li>
<li><a class="reference internal" href="#the-kind">10.11.12. The kind <code class="docutils literal"><span class="pre">*</span></code></a></li>
<li><a class="reference internal" href="#inferring-dependency-in-datatype-declarations">10.11.13. Inferring dependency in datatype declarations</a></li>
<li><a class="reference internal" href="#kind-defaulting-without-xpolykinds">10.11.14. Kind defaulting without <code class="docutils literal"><span class="pre">-XPolyKinds</span></code></a></li>
<li><a class="reference internal" href="#pretty-printing-in-the-presence-of-kind-polymorphism">10.11.15. Pretty-printing in the presence of kind polymorphism</a></li>
</ul>
</li>
<li><a class="reference internal" href="#levity-polymorphism">10.12. Levity polymorphism</a><ul>
<li><a class="reference internal" href="#no-levity-polymorphic-variables-or-arguments">10.12.1. No levity-polymorphic variables or arguments</a></li>
<li><a class="reference internal" href="#levity-polymorphic-bottoms">10.12.2. Levity-polymorphic bottoms</a></li>
<li><a class="reference internal" href="#printing-levity-polymorphic-types">10.12.3. Printing levity-polymorphic types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-level-literals">10.13. Type-Level Literals</a><ul>
<li><a class="reference internal" href="#runtime-values-for-type-level-literals">10.13.1. Runtime Values for Type-Level Literals</a></li>
<li><a class="reference internal" href="#computing-with-type-level-naturals">10.13.2. Computing With Type-Level Naturals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#constraints-in-types">10.14. Constraints in types</a><ul>
<li><a class="reference internal" href="#equality-constraints">10.14.1. Equality constraints</a></li>
<li><a class="reference internal" href="#heterogeneous-equality">10.14.2. Heterogeneous equality</a></li>
<li><a class="reference internal" href="#unlifted-heterogeneous-equality">10.14.3. Unlifted heterogeneous equality</a></li>
<li><a class="reference internal" href="#the-coercible-constraint">10.14.4. The <code class="docutils literal"><span class="pre">Coercible</span></code> constraint</a></li>
<li><a class="reference internal" href="#the-constraint-kind">10.14.5. The <code class="docutils literal"><span class="pre">Constraint</span></code> kind</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extensions-to-type-signatures">10.15. Extensions to type signatures</a><ul>
<li><a class="reference internal" href="#explicit-universal-quantification-forall">10.15.1. Explicit universal quantification (forall)</a></li>
<li><a class="reference internal" href="#the-context-of-a-type-signature">10.15.2. The context of a type signature</a></li>
<li><a class="reference internal" href="#ambiguous-types-and-the-ambiguity-check">10.15.3. Ambiguous types and the ambiguity check</a></li>
<li><a class="reference internal" href="#explicitly-kinded-quantification">10.15.4. Explicitly-kinded quantification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lexically-scoped-type-variables">10.16. Lexically scoped type variables</a><ul>
<li><a class="reference internal" href="#id48">10.16.1. Overview</a></li>
<li><a class="reference internal" href="#declaration-type-signatures">10.16.2. Declaration type signatures</a></li>
<li><a class="reference internal" href="#expression-type-signatures">10.16.3. Expression type signatures</a></li>
<li><a class="reference internal" href="#pattern-type-signatures">10.16.4. Pattern type signatures</a></li>
<li><a class="reference internal" href="#class-and-instance-declarations">10.16.5. Class and instance declarations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bindings-and-generalisation">10.17. Bindings and generalisation</a><ul>
<li><a class="reference internal" href="#switching-off-the-dreaded-monomorphism-restriction">10.17.1. Switching off the dreaded Monomorphism Restriction</a></li>
<li><a class="reference internal" href="#let-generalisation">10.17.2. Let-generalisation</a></li>
<li><a class="reference internal" href="#kind-generalisation">10.17.3. Kind generalisation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visible-type-application">10.18. Visible type application</a></li>
<li><a class="reference internal" href="#implicit-parameters">10.19. Implicit parameters</a><ul>
<li><a class="reference internal" href="#implicit-parameter-type-constraints">10.19.1. Implicit-parameter type constraints</a></li>
<li><a class="reference internal" href="#implicit-parameter-bindings">10.19.2. Implicit-parameter bindings</a></li>
<li><a class="reference internal" href="#implicit-parameters-and-polymorphic-recursion">10.19.3. Implicit parameters and polymorphic recursion</a></li>
<li><a class="reference internal" href="#implicit-parameters-and-monomorphism">10.19.4. Implicit parameters and monomorphism</a></li>
</ul>
</li>
<li><a class="reference internal" href="#arbitrary-rank-polymorphism">10.20. Arbitrary-rank polymorphism</a><ul>
<li><a class="reference internal" href="#univ">10.20.1. Examples</a></li>
<li><a class="reference internal" href="#type-inference">10.20.2. Type inference</a></li>
<li><a class="reference internal" href="#implicit-quantification">10.20.3. Implicit quantification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#impredicative-polymorphism">10.21. Impredicative polymorphism</a></li>
<li><a class="reference internal" href="#typed-holes">10.22. Typed Holes</a></li>
<li><a class="reference internal" href="#partial-type-signatures">10.23. Partial Type Signatures</a><ul>
<li><a class="reference internal" href="#syntax">10.23.1. Syntax</a><ul>
<li><a class="reference internal" href="#type-wildcards">10.23.1.1. Type Wildcards</a></li>
<li><a class="reference internal" href="#named-wildcards">10.23.1.2. Named Wildcards</a></li>
<li><a class="reference internal" href="#extra-constraints-wildcard">10.23.1.3. Extra-Constraints Wildcard</a></li>
</ul>
</li>
<li><a class="reference internal" href="#where-can-they-occur">10.23.2. Where can they occur?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-compile-time-errors">10.24. Custom compile-time errors</a></li>
<li><a class="reference internal" href="#deferring-type-errors-to-runtime">10.25. Deferring type errors to runtime</a><ul>
<li><a class="reference internal" href="#enabling-deferring-of-type-errors">10.25.1. Enabling deferring of type errors</a></li>
<li><a class="reference internal" href="#deferred-type-errors-in-ghci">10.25.2. Deferred type errors in GHCi</a></li>
</ul>
</li>
<li><a class="reference internal" href="#template-haskell">10.26. Template Haskell</a><ul>
<li><a class="reference internal" href="#th-syntax">10.26.1. Syntax</a></li>
<li><a class="reference internal" href="#using-template-haskell">10.26.2. Using Template Haskell</a></li>
<li><a class="reference internal" href="#viewing-template-haskell-generated-code">10.26.3. Viewing Template Haskell generated code</a></li>
<li><a class="reference internal" href="#a-template-haskell-worked-example">10.26.4. A Template Haskell Worked Example</a></li>
<li><a class="reference internal" href="#using-template-haskell-with-profiling">10.26.5. Using Template Haskell with Profiling</a></li>
<li><a class="reference internal" href="#template-haskell-quasi-quotation">10.26.6. Template Haskell Quasi-quotation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#arrow-notation">10.27. Arrow notation</a><ul>
<li><a class="reference internal" href="#do-notation-for-commands">10.27.1. do-notation for commands</a></li>
<li><a class="reference internal" href="#conditional-commands">10.27.2. Conditional commands</a></li>
<li><a class="reference internal" href="#defining-your-own-control-structures">10.27.3. Defining your own control structures</a></li>
<li><a class="reference internal" href="#primitive-constructs">10.27.4. Primitive constructs</a></li>
<li><a class="reference internal" href="#differences-with-the-paper">10.27.5. Differences with the paper</a></li>
<li><a class="reference internal" href="#portability">10.27.6. Portability</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bang-patterns-and-strict-haskell">10.28. Bang patterns and Strict Haskell</a><ul>
<li><a class="reference internal" href="#bang-patterns-informal">10.28.1. Bang patterns</a></li>
<li><a class="reference internal" href="#strict-by-default-data-types">10.28.2. Strict-by-default data types</a></li>
<li><a class="reference internal" href="#strict-by-default-pattern-bindings">10.28.3. Strict-by-default pattern bindings</a></li>
<li><a class="reference internal" href="#modularity">10.28.4. Modularity</a></li>
<li><a class="reference internal" href="#dynamic-semantics-of-bang-patterns">10.28.5. Dynamic semantics of bang patterns</a></li>
</ul>
</li>
<li><a class="reference internal" href="#assertions">10.29. Assertions</a></li>
<li><a class="reference internal" href="#static-pointers">10.30. Static pointers</a><ul>
<li><a class="reference internal" href="#using-static-pointers">10.30.1. Using static pointers</a></li>
<li><a class="reference internal" href="#static-semantics-of-static-pointers">10.30.2. Static semantics of static pointers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pragmas">10.31. Pragmas</a><ul>
<li><a class="reference internal" href="#language-pragma">10.31.1. LANGUAGE pragma</a></li>
<li><a class="reference internal" href="#options-ghc-pragma">10.31.2. <code class="docutils literal"><span class="pre">OPTIONS_GHC</span></code> pragma</a></li>
<li><a class="reference internal" href="#include-pragma">10.31.3. <code class="docutils literal"><span class="pre">INCLUDE</span></code> pragma</a></li>
<li><a class="reference internal" href="#warning-and-deprecated-pragmas">10.31.4. <code class="docutils literal"><span class="pre">WARNING</span></code> and <code class="docutils literal"><span class="pre">DEPRECATED</span></code> pragmas</a></li>
<li><a class="reference internal" href="#minimal-pragma">10.31.5. MINIMAL pragma</a></li>
<li><a class="reference internal" href="#inline-and-noinline-pragmas">10.31.6. INLINE and NOINLINE pragmas</a><ul>
<li><a class="reference internal" href="#inline-pragma">10.31.6.1. INLINE pragma</a></li>
<li><a class="reference internal" href="#inlinable-pragma">10.31.6.2. INLINABLE pragma</a></li>
<li><a class="reference internal" href="#noinline-pragma">10.31.6.3. NOINLINE pragma</a></li>
<li><a class="reference internal" href="#conlike-modifier">10.31.6.4. CONLIKE modifier</a></li>
<li><a class="reference internal" href="#phase-control">10.31.6.5. Phase control</a></li>
</ul>
</li>
<li><a class="reference internal" href="#line-pragma">10.31.7. <code class="docutils literal"><span class="pre">LINE</span></code> pragma</a></li>
<li><a class="reference internal" href="#column-pragma">10.31.8. <code class="docutils literal"><span class="pre">COLUMN</span></code> pragma</a></li>
<li><a class="reference internal" href="#rules-pragma">10.31.9. <code class="docutils literal"><span class="pre">RULES</span></code> pragma</a></li>
<li><a class="reference internal" href="#specialize-pragma">10.31.10. <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> pragma</a><ul>
<li><a class="reference internal" href="#specialize-inline">10.31.10.1. <code class="docutils literal"><span class="pre">SPECIALIZE</span> <span class="pre">INLINE</span></code></a></li>
<li><a class="reference internal" href="#specialize-for-imported-functions">10.31.10.2. <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> for imported functions</a></li>
<li><a class="reference internal" href="#obsolete-specialize-syntax">10.31.10.3. Obsolete <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> syntax</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specialize-instance-pragma">10.31.11. <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> instance pragma</a></li>
<li><a class="reference internal" href="#unpack-pragma">10.31.12. <code class="docutils literal"><span class="pre">UNPACK</span></code> pragma</a></li>
<li><a class="reference internal" href="#nounpack-pragma">10.31.13. <code class="docutils literal"><span class="pre">NOUNPACK</span></code> pragma</a></li>
<li><a class="reference internal" href="#source-pragma">10.31.14. <code class="docutils literal"><span class="pre">SOURCE</span></code> pragma</a></li>
<li><a class="reference internal" href="#complete-pragmas">10.31.15. <code class="docutils literal"><span class="pre">COMPLETE</span></code> pragmas</a></li>
<li><a class="reference internal" href="#overlapping-overlappable-overlaps-and-incoherent-pragmas">10.31.16. <code class="docutils literal"><span class="pre">OVERLAPPING</span></code>, <code class="docutils literal"><span class="pre">OVERLAPPABLE</span></code>, <code class="docutils literal"><span class="pre">OVERLAPS</span></code>, and <code class="docutils literal"><span class="pre">INCOHERENT</span></code> pragmas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rewrite-rules">10.32. Rewrite rules</a><ul>
<li><a class="reference internal" href="#id87">10.32.1. Syntax</a></li>
<li><a class="reference internal" href="#semantics">10.32.2. Semantics</a></li>
<li><a class="reference internal" href="#how-rules-interact-with-inline-noinline-pragmas">10.32.3. How rules interact with <code class="docutils literal"><span class="pre">INLINE</span></code>/<code class="docutils literal"><span class="pre">NOINLINE</span></code> pragmas</a></li>
<li><a class="reference internal" href="#how-rules-interact-with-conlike-pragmas">10.32.4. How rules interact with CONLIKE pragmas</a></li>
<li><a class="reference internal" href="#how-rules-interact-with-class-methods">10.32.5. How rules interact with class methods</a></li>
<li><a class="reference internal" href="#list-fusion">10.32.6. List fusion</a></li>
<li><a class="reference internal" href="#specialisation">10.32.7. Specialisation</a></li>
<li><a class="reference internal" href="#controlling-what-s-going-on-in-rewrite-rules">10.32.8. Controlling what&#8217;s going on in rewrite rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-built-in-functions">10.33. Special built-in functions</a></li>
<li><a class="reference internal" href="#generic-classes">10.34. Generic classes</a></li>
<li><a class="reference internal" href="#generic-programming">10.35. Generic programming</a><ul>
<li><a class="reference internal" href="#deriving-representations">10.35.1. Deriving representations</a></li>
<li><a class="reference internal" href="#writing-generic-functions">10.35.2. Writing generic functions</a></li>
<li><a class="reference internal" href="#unlifted-representation-types">10.35.3. Unlifted representation types</a></li>
<li><a class="reference internal" href="#generic-defaults">10.35.4. Generic defaults</a></li>
<li><a class="reference internal" href="#more-information">10.35.5. More information</a></li>
</ul>
</li>
<li><a class="reference internal" href="#roles">10.36. Roles</a><ul>
<li><a class="reference internal" href="#nominal-representational-and-phantom">10.36.1. Nominal, Representational, and Phantom</a></li>
<li><a class="reference internal" href="#role-inference">10.36.2. Role inference</a></li>
<li><a class="reference internal" href="#role-annotations">10.36.3. Role annotations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hascallstack">10.37. HasCallStack</a><ul>
<li><a class="reference internal" href="#compared-with-other-sources-of-stack-traces">10.37.1. Compared with other sources of stack traces</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="lang.html"
                        title="previous chapter">10. GHC Language Features</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="parallel.html"
                        title="next chapter">10.38. Concurrent and Parallel Haskell</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/glasgow_exts.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p id="index-0">As with all known Haskell systems, GHC implements some extensions to the
standard Haskell language. They can all be enabled or disabled by command line
flags or language pragmas. By default GHC understands the most recent Haskell
version it supports, plus a handful of extensions.</p>
<p>Some of the Glasgow extensions serve to give you access to the
underlying facilities with which we implement Haskell. Thus, you can get
at the Raw Iron, if you are willing to write some non-portable code at a
more primitive level. You need not be “stuck” on performance because of
the implementation costs of Haskell&#8217;s &#8220;high-level&#8221; features—you can
always code &#8220;under&#8221; them. In an extreme case, you can write all your
time-critical code in C, and then just glue it together with Haskell!</p>
<p>Before you get too carried away working at the lowest level (e.g.,
sloshing <code class="docutils literal"><span class="pre">MutableByteArray#</span></code>s around your program), you may wish to
check if there are libraries that provide a &#8220;Haskellised veneer&#8221; over
the features you want. The separate
<a class="reference external" href="../libraries/index.html">libraries documentation</a> describes all the
libraries that come with GHC.</p>
<div class="section" id="language-options">
<span id="options-language"></span><h1>10.1. Language options<a class="headerlink" href="#language-options" title="Permalink to this headline">¶</a></h1>
<p id="index-1">The language option flags control what variation of the language are
permitted.</p>
<p>Language options can be controlled in two ways:</p>
<ul class="simple">
<li>Every language option can switched on by a command-line flag
&#8220;<code class="docutils literal"><span class="pre">-X...</span></code>&#8221; (e.g. <code class="docutils literal"><span class="pre">-XTemplateHaskell</span></code>), and switched off by the
flag &#8220;<code class="docutils literal"><span class="pre">-XNo...</span></code>&#8221;; (e.g. <code class="docutils literal"><span class="pre">-XNoTemplateHaskell</span></code>).</li>
<li>Language options recognised by Cabal can also be enabled using the
<code class="docutils literal"><span class="pre">LANGUAGE</span></code> pragma, thus <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">TemplateHaskell</span> <span class="pre">#-}</span></code> (see
<a class="reference internal" href="#language-pragma"><span>LANGUAGE pragma</span></a>).</li>
</ul>
<p>Although not recommended, the deprecated <a class="reference internal" href="#ghc-flag--fglasgow-exts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fglasgow-exts</span></code></a> flag enables
a large swath of the extensions supported by GHC at once.</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fglasgow-exts">
<code class="descname">-fglasgow-exts</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fglasgow-exts" title="Permalink to this definition">¶</a></dt>
<dd><p>The flag <code class="docutils literal"><span class="pre">-fglasgow-exts</span></code> is equivalent to enabling the following extensions:</p>
<table class="hlist"><tr><td><ul class="simple">
<li><code class="docutils literal"><span class="pre">-XConstrainedClassMethods</span></code></li>
<li><code class="docutils literal"><span class="pre">-XDeriveDataTypeable</span></code></li>
<li><code class="docutils literal"><span class="pre">-XDeriveFoldable</span></code></li>
<li><code class="docutils literal"><span class="pre">-XDeriveFunctor</span></code></li>
<li><code class="docutils literal"><span class="pre">-XDeriveGeneric</span></code></li>
<li><code class="docutils literal"><span class="pre">-XDeriveTraversable</span></code></li>
<li><code class="docutils literal"><span class="pre">-XEmptyDataDecls</span></code></li>
<li><code class="docutils literal"><span class="pre">-XExistentialQuantification</span></code></li>
<li><code class="docutils literal"><span class="pre">-XExplicitNamespaces</span></code></li>
<li><code class="docutils literal"><span class="pre">-XFlexibleContexts</span></code></li>
<li><code class="docutils literal"><span class="pre">-XFlexibleInstances</span></code></li>
<li><code class="docutils literal"><span class="pre">-XForeignFunctionInterface</span></code></li>
<li><code class="docutils literal"><span class="pre">-XFunctionalDependencies</span></code></li>
<li><code class="docutils literal"><span class="pre">-XGeneralizedNewtypeDeriving</span></code></li>
<li><code class="docutils literal"><span class="pre">-XImplicitParams</span></code></li>
<li><code class="docutils literal"><span class="pre">-XKindSignatures</span></code></li>
</ul>
</td><td><ul class="simple">
<li><code class="docutils literal"><span class="pre">-XLiberalTypeSynonyms</span></code></li>
<li><code class="docutils literal"><span class="pre">-XMagicHash</span></code></li>
<li><code class="docutils literal"><span class="pre">-XMultiParamTypeClasses</span></code></li>
<li><code class="docutils literal"><span class="pre">-XParallelListComp</span></code></li>
<li><code class="docutils literal"><span class="pre">-XPatternGuards</span></code></li>
<li><code class="docutils literal"><span class="pre">-XPostfixOperators</span></code></li>
<li><code class="docutils literal"><span class="pre">-XRankNTypes</span></code></li>
<li><code class="docutils literal"><span class="pre">-XRecursiveDo</span></code></li>
<li><code class="docutils literal"><span class="pre">-XScopedTypeVariables</span></code></li>
<li><code class="docutils literal"><span class="pre">-XStandaloneDeriving</span></code></li>
<li><code class="docutils literal"><span class="pre">-XTypeOperators</span></code></li>
<li><code class="docutils literal"><span class="pre">-XTypeSynonymInstances</span></code></li>
<li><code class="docutils literal"><span class="pre">-XUnboxedTuples</span></code></li>
<li><code class="docutils literal"><span class="pre">-XUnicodeSyntax</span></code></li>
<li><code class="docutils literal"><span class="pre">-XUnliftedFFITypes</span></code></li>
</ul>
</td></tr></table>
<p>Enabling these options is the <em>only</em> effect of <code class="docutils literal"><span class="pre">-fglasgow-exts</span></code>. We are trying
to move away from this portmanteau flag, and towards enabling features
individually.</p>
</dd></dl>

</div>
<div class="section" id="unboxed-types-and-primitive-operations">
<span id="primitives"></span><h1>10.2. Unboxed types and primitive operations<a class="headerlink" href="#unboxed-types-and-primitive-operations" title="Permalink to this headline">¶</a></h1>
<p>GHC is built on a raft of primitive data types and operations;
&#8220;primitive&#8221; in the sense that they cannot be defined in Haskell itself.
While you really can use this stuff to write fast code, we generally
find it a lot less painful, and more satisfying in the long run, to use
higher-level language features and libraries. With any luck, the code
you write will be optimised to the efficient unboxed version in any
case. And if it isn&#8217;t, we&#8217;d like to know about it.</p>
<p>All these primitive data types and operations are exported by the
library <code class="docutils literal"><span class="pre">GHC.Prim</span></code>, for which there is
<a class="reference external" href="../libraries/ghc-prim-0.5.1.1/GHC-Prim.html">detailed online documentation</a>. (This
documentation is generated from the file <code class="docutils literal"><span class="pre">compiler/prelude/primops.txt.pp</span></code>.)</p>
<p>If you want to mention any of the primitive data types or operations in
your program, you must first import <code class="docutils literal"><span class="pre">GHC.Prim</span></code> to bring them into
scope. Many of them have names ending in <code class="docutils literal"><span class="pre">#</span></code>, and to mention such names
you need the <a class="reference internal" href="#ghc-flag--XMagicHash"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMagicHash</span></code></a> extension (<a class="reference internal" href="#magic-hash"><span>The magic hash</span></a>).</p>
<p>The primops make extensive use of <a class="reference external" href="#glasgow-unboxed">unboxed types</a>
and <a class="reference external" href="#unboxed-tuples">unboxed tuples</a>, which we briefly summarise
here.</p>
<div class="section" id="unboxed-types">
<span id="glasgow-unboxed"></span><h2>10.2.1. Unboxed types<a class="headerlink" href="#unboxed-types" title="Permalink to this headline">¶</a></h2>
<p>Most types in GHC are boxed, which means that values of that type are
represented by a pointer to a heap object. The representation of a
Haskell <code class="docutils literal"><span class="pre">Int</span></code>, for example, is a two-word heap object. An unboxed
type, however, is represented by the value itself, no pointers or heap
allocation are involved.</p>
<p>Unboxed types correspond to the “raw machine” types you would use in C:
<code class="docutils literal"><span class="pre">Int#</span></code> (long int), <code class="docutils literal"><span class="pre">Double#</span></code> (double), <code class="docutils literal"><span class="pre">Addr#</span></code> (void *), etc. The
<em>primitive operations</em> (PrimOps) on these types are what you might
expect; e.g., <code class="docutils literal"><span class="pre">(+#)</span></code> is addition on <code class="docutils literal"><span class="pre">Int#</span></code>s, and is the
machine-addition that we all know and love—usually one instruction.</p>
<p>Primitive (unboxed) types cannot be defined in Haskell, and are
therefore built into the language and compiler. Primitive types are
always unlifted; that is, a value of a primitive type cannot be bottom.
(Note: a &#8220;boxed&#8221; type means that a value is represented by a pointer to a heap
object; a &#8220;lifted&#8221; type means that terms of that type may be bottom. See
the next paragraph for an example.)
We use the convention (but it is only a convention) that primitive
types, values, and operations have a <code class="docutils literal"><span class="pre">#</span></code> suffix (see
<a class="reference internal" href="#magic-hash"><span>The magic hash</span></a>). For some primitive types we have special syntax for
literals, also described in the <a class="reference external" href="#magic-hash">same section</a>.</p>
<p>Primitive values are often represented by a simple bit-pattern, such as
<code class="docutils literal"><span class="pre">Int#</span></code>, <code class="docutils literal"><span class="pre">Float#</span></code>, <code class="docutils literal"><span class="pre">Double#</span></code>. But this is not necessarily the case:
a primitive value might be represented by a pointer to a heap-allocated
object. Examples include <code class="docutils literal"><span class="pre">Array#</span></code>, the type of primitive arrays. Thus,
<code class="docutils literal"><span class="pre">Array#</span></code> is an unlifted, boxed type. A
primitive array is heap-allocated because it is too big a value to fit
in a register, and would be too expensive to copy around; in a sense, it
is accidental that it is represented by a pointer. If a pointer
represents a primitive value, then it really does point to that value:
no unevaluated thunks, no indirections. Nothing can be at the other end
of the pointer than the primitive value. A numerically-intensive program
using unboxed types can go a <em>lot</em> faster than its “standard”
counterpart—we saw a threefold speedup on one example.</p>
</div>
<div class="section" id="unboxed-type-kinds">
<h2>10.2.2. Unboxed type kinds<a class="headerlink" href="#unboxed-type-kinds" title="Permalink to this headline">¶</a></h2>
<p>Because unboxed types are represented without the use of pointers, we
cannot store them in use a polymorphic datatype at an unboxed type.
For example, the <code class="docutils literal"><span class="pre">Just</span></code> node
of <code class="docutils literal"><span class="pre">Just</span> <span class="pre">42#</span></code> would have to be different from the <code class="docutils literal"><span class="pre">Just</span></code> node of
<code class="docutils literal"><span class="pre">Just</span> <span class="pre">42</span></code>; the former stores an integer directly, while the latter
stores a pointer. GHC currently does not support this variety of <code class="docutils literal"><span class="pre">Just</span></code>
nodes (nor for any other datatype). Accordingly, the <em>kind</em> of an unboxed
type is different from the kind of a boxed type.</p>
<p>The Haskell Report describes that <code class="docutils literal"><span class="pre">*</span></code> is the kind of ordinary datatypes,
such as <code class="docutils literal"><span class="pre">Int</span></code>. Furthermore, type constructors can have kinds with arrows;
for example, <code class="docutils literal"><span class="pre">Maybe</span></code> has kind <code class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. Unboxed types have a kind that
specifies their runtime representation. For example, the type <code class="docutils literal"><span class="pre">Int#</span></code> has
kind <code class="docutils literal"><span class="pre">TYPE</span> <span class="pre">'IntRep</span></code> and <code class="docutils literal"><span class="pre">Double#</span></code> has kind <code class="docutils literal"><span class="pre">TYPE</span> <span class="pre">'DoubleRep</span></code>. These
kinds say that the runtime representation of an <code class="docutils literal"><span class="pre">Int#</span></code> is a machine integer,
and the runtime representation of a <code class="docutils literal"><span class="pre">Double#</span></code> is a machine double-precision
floating point. In contrast, the kind <code class="docutils literal"><span class="pre">*</span></code> is actually just a synonym
for <code class="docutils literal"><span class="pre">TYPE</span> <span class="pre">'PtrRepLifted</span></code>. More details of the <code class="docutils literal"><span class="pre">TYPE</span></code> mechanisms appear in
the <a class="reference external" href="#runtime-rep">section on runtime representation polymorphism</a>.</p>
<p>Given that <code class="docutils literal"><span class="pre">Int#</span></code>&#8216;s kind is not <code class="docutils literal"><span class="pre">*</span></code>, it then it follows that
<code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Int#</span></code> is disallowed. Similarly, because type variables tend
to be of kind <code class="docutils literal"><span class="pre">*</span></code> (for example, in <code class="docutils literal"><span class="pre">(.)</span> <span class="pre">::</span> <span class="pre">(b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code>,
all the type variables have kind <code class="docutils literal"><span class="pre">*</span></code>), polymorphism tends not to work
over primitive types. Stepping back, this makes some sense, because
a polymorphic function needs to manipulate the pointers to its data,
and most primitive types are unboxed.</p>
<p>There are some restrictions on the use of primitive types:</p>
<ul>
<li><p class="first">You cannot define a newtype whose representation type (the argument
type of the data constructor) is an unboxed type. Thus, this is
illegal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">A</span> <span class="ow">=</span> <span class="kt">MkA</span> <span class="kt">Int</span><span class="o">#</span>
</pre></div>
</div>
</li>
<li><p class="first">You cannot bind a variable with an unboxed type in a <em>top-level</em>
binding.</p>
</li>
<li><p class="first">You cannot bind a variable with an unboxed type in a <em>recursive</em>
binding.</p>
</li>
<li><p class="first">You may bind unboxed variables in a (non-recursive, non-top-level)
pattern binding, but you must make any such pattern-match strict.
(Failing to do so emits a warning <a class="reference internal" href="using-warnings.html#ghc-flag--Wunbanged-strict-patterns"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wunbanged-strict-patterns</span></code></a>.)
For example, rather than:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="kt">Foo</span> <span class="kt">Int</span> <span class="kt">Int</span><span class="o">#</span>

<span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=</span> <span class="o">..</span><span class="n">rhs</span><span class="o">..</span> <span class="kr">in</span> <span class="o">..</span><span class="n">body</span><span class="o">..</span>
</pre></div>
</div>
<p>you must write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="kt">Foo</span> <span class="kt">Int</span> <span class="kt">Int</span><span class="o">#</span>

<span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">let</span> <span class="o">!</span><span class="p">(</span><span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=</span> <span class="o">..</span><span class="n">rhs</span><span class="o">..</span> <span class="kr">in</span> <span class="o">..</span><span class="n">body</span><span class="o">..</span>
</pre></div>
</div>
<p>since <code class="docutils literal"><span class="pre">b</span></code> has type <code class="docutils literal"><span class="pre">Int#</span></code>.</p>
</li>
</ul>
</div>
<div class="section" id="unboxed-tuples">
<span id="id1"></span><h2>10.2.3. Unboxed tuples<a class="headerlink" href="#unboxed-tuples" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XUnboxedTuples">
<code class="descname">-XUnboxedTuples</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XUnboxedTuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the use of unboxed tuple syntax.</p>
</dd></dl>

<p>Unboxed tuples aren&#8217;t really exported by <code class="docutils literal"><span class="pre">GHC.Exts</span></code>; they are a
syntactic extension enabled by the language flag <a class="reference internal" href="#ghc-flag--XUnboxedTuples"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUnboxedTuples</span></code></a>. An
unboxed tuple looks like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">#</span> <span class="n">e_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">e_n</span> <span class="o">#</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">e_1..e_n</span></code> are expressions of any type (primitive or
non-primitive). The type of an unboxed tuple looks the same.</p>
<p>Note that when unboxed tuples are enabled, <code class="docutils literal"><span class="pre">(#</span></code> is a single lexeme, so
for example when using operators like <code class="docutils literal"><span class="pre">#</span></code> and <code class="docutils literal"><span class="pre">#-</span></code> you need to write
<code class="docutils literal"><span class="pre">(</span> <span class="pre">#</span> <span class="pre">)</span></code> and <code class="docutils literal"><span class="pre">(</span> <span class="pre">#-</span> <span class="pre">)</span></code> rather than <code class="docutils literal"><span class="pre">(#)</span></code> and <code class="docutils literal"><span class="pre">(#-)</span></code>.</p>
<p>Unboxed tuples are used for functions that need to return multiple
values, but they avoid the heap allocation normally associated with
using fully-fledged tuples. When an unboxed tuple is returned, the
components are put directly into registers or on the stack; the unboxed
tuple itself does not have a composite representation. Many of the
primitive operations listed in <code class="docutils literal"><span class="pre">primops.txt.pp</span></code> return unboxed tuples.
In particular, the <code class="docutils literal"><span class="pre">IO</span></code> and <code class="docutils literal"><span class="pre">ST</span></code> monads use unboxed tuples to avoid
unnecessary allocation during sequences of operations.</p>
<p>There are some restrictions on the use of unboxed tuples:</p>
<ul>
<li><p class="first">The typical use of unboxed tuples is simply to return multiple
values, binding those multiple results with a <code class="docutils literal"><span class="pre">case</span></code> expression,
thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">(</span><span class="o">#</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span> <span class="o">#</span><span class="p">)</span>
<span class="nf">g</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">f</span> <span class="n">x</span> <span class="n">x</span> <span class="kr">of</span> <span class="p">{</span> <span class="p">(</span><span class="o">#</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">#</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span>
</pre></div>
</div>
<p>You can have an unboxed tuple in a pattern binding, thus</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="o">#</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">#</span><span class="p">)</span> <span class="ow">=</span> <span class="n">h</span> <span class="n">x</span> <span class="kr">in</span> <span class="o">..</span><span class="n">body</span><span class="o">..</span>
</pre></div>
</div>
<p>If the types of <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> are not unboxed, the resulting
binding is lazy like any other Haskell pattern binding. The above
example desugars like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">t</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">h</span> <span class="n">x</span> <span class="kr">of</span> <span class="p">{</span> <span class="p">(</span><span class="o">#</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">#</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">p</span> <span class="ow">=</span> <span class="n">fst</span> <span class="n">t</span>
          <span class="n">q</span> <span class="ow">=</span> <span class="n">snd</span> <span class="n">t</span>
      <span class="kr">in</span> <span class="o">..</span><span class="n">body</span><span class="o">..</span>
</pre></div>
</div>
<p>Indeed, the bindings can even be recursive.</p>
</li>
</ul>
</div>
<div class="section" id="unboxed-sums">
<span id="id2"></span><h2>10.2.4. Unboxed sums<a class="headerlink" href="#unboxed-sums" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XUnboxedSums">
<code class="descname">-XUnboxedSums</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XUnboxedSums" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the use of unboxed sum syntax.</p>
</dd></dl>

<p><cite>-XUnboxedSums</cite> enables new syntax for anonymous, unboxed sum types. The syntax
for an unboxed sum type with N alternatives is</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">#</span> <span class="n">t_1</span> <span class="o">|</span> <span class="n">t_2</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="n">t_N</span> <span class="o">#</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>t_1</cite> ... <cite>t_N</cite> are types (which can be unlifted, including unboxed tuple
and sums).</p>
<p>Unboxed tuples can be used for multi-arity alternatives. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">#</span> <span class="p">(</span><span class="o">#</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span> <span class="o">#</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Bool</span> <span class="o">#</span><span class="p">)</span>
</pre></div>
</div>
<p>Term level syntax is similar. Leading and preceding bars (<cite>|</cite>) indicate which
alternative it is. Here is two terms of the type shown above:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">#</span> <span class="p">(</span><span class="o">#</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span> <span class="o">#</span><span class="p">)</span> <span class="o">|</span> <span class="o">#</span><span class="p">)</span> <span class="c1">-- first alternative</span>

<span class="p">(</span><span class="o">#</span> <span class="o">|</span> <span class="kt">True</span> <span class="o">#</span><span class="p">)</span> <span class="c1">-- second alternative</span>
</pre></div>
</div>
<p>Pattern syntax reflects the term syntax:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
  <span class="p">(</span><span class="o">#</span> <span class="p">(</span><span class="o">#</span> <span class="n">i</span><span class="p">,</span> <span class="n">str</span> <span class="o">#</span><span class="p">)</span> <span class="o">|</span> <span class="o">#</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="o">...</span>
  <span class="p">(</span><span class="o">#</span> <span class="o">|</span> <span class="n">bool</span> <span class="o">#</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="o">...</span>
</pre></div>
</div>
<p>Unboxed sums are &#8220;unboxed&#8221; in the sense that, instead of allocating sums in the
heap and representing values as pointers, unboxed sums are represented as their
components, just like unboxed tuples. These &#8220;components&#8221; depend on alternatives
of a sum type. Code generator tries to generate as compact layout as possible.
In the best case, size of an unboxed sum is size of its biggest alternative +
one word (for tag). The algorithm for generating memory layout for a sum type
works like this:</p>
<ul>
<li><p class="first">All types are classified as one of these classes: 32bit word, 64bit word,
32bit float, 64bit float, pointer.</p>
</li>
<li><p class="first">For each alternative of the sum type, a layout that consists of these fields
is generated. For example, if an alternative has <cite>Int</cite>, <cite>Float#</cite> and <cite>String</cite>
fields, the layout will have an 32bit word, 32bit float and pointer fields.</p>
</li>
<li><p class="first">Layout fields are then overlapped so that the final layout will be as compact
as possible. E.g. say two alternatives have these fields:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Word32</span><span class="p">,</span> <span class="kt">String</span><span class="p">,</span> <span class="kt">Float</span><span class="o">#</span>
<span class="kt">Float</span><span class="o">#</span><span class="p">,</span> <span class="kt">Float</span><span class="o">#</span><span class="p">,</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>Final layout will be something like</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Int32</span><span class="p">,</span> <span class="kt">Float32</span><span class="p">,</span> <span class="kt">Float32</span><span class="p">,</span> <span class="kt">Word32</span><span class="p">,</span> <span class="kt">Pointer</span>
</pre></div>
</div>
<p>First <cite>Int32</cite> is for the tag. It has two <cite>Float32</cite> fields because floating
point types can&#8217;t overlap with other types, because of limitations of the code
generator that we&#8217;re hoping to overcome in the future, and second alternative
needs two <cite>Float32</cite> fields. <cite>Word32</cite> field is for the <cite>Word32</cite> in the first
alternative. <cite>Pointer</cite> field is shared between <cite>String</cite> and <cite>Maybe Int</cite> values
of the alternatives.</p>
<p>In the case of enumeration types (like <cite>Bool</cite>), the unboxed sum layout only
has an <cite>Int32</cite> field (i.e. the whole thing is represented by an integer).</p>
</li>
</ul>
<p>In the example above, a value of this type is thus represented as 5 values. As
an another example, this is the layout for unboxed version of <cite>Maybe a</cite> type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Int32</span><span class="p">,</span> <span class="kt">Pointer</span>
</pre></div>
</div>
<p>The <cite>Pointer</cite> field is not used when tag says that it&#8217;s <cite>Nothing</cite>. Otherwise
<cite>Pointer</cite> points to the value in <cite>Just</cite>.</p>
</div>
</div>
<div class="section" id="syntactic-extensions">
<span id="syntax-extns"></span><h1>10.3. Syntactic extensions<a class="headerlink" href="#syntactic-extensions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="unicode-syntax">
<span id="id3"></span><h2>10.3.1. Unicode syntax<a class="headerlink" href="#unicode-syntax" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XUnicodeSyntax">
<code class="descname">-XUnicodeSyntax</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XUnicodeSyntax" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the use of Unicode characters in place of their equivalent ASCII
sequences.</p>
</dd></dl>

<p>The language extension <a class="reference internal" href="#ghc-flag--XUnicodeSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUnicodeSyntax</span></code></a> enables
Unicode characters to be used to stand for certain ASCII character
sequences. The following alternatives are provided:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="18%" />
<col width="16%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ASCII</th>
<th class="head">Unicode
alternative</th>
<th class="head">Code point</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">::</span></code></td>
<td>∷</td>
<td>0x2237</td>
<td>PROPORTION</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">=&gt;</span></code></td>
<td>⇒</td>
<td>0x21D2</td>
<td>RIGHTWARDS DOUBLE ARROW</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">-&gt;</span></code></td>
<td>→</td>
<td>0x2192</td>
<td>RIGHTWARDS ARROW</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;-</span></code></td>
<td>←</td>
<td>0x2190</td>
<td>LEFTWARDS ARROW</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&gt;-</span></code></td>
<td>⤚</td>
<td>0x291a</td>
<td>RIGHTWARDS ARROW-TAIL</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">-&lt;</span></code></td>
<td>⤙</td>
<td>0x2919</td>
<td>LEFTWARDS ARROW-TAIL</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&gt;&gt;-</span></code></td>
<td>⤜</td>
<td>0x291C</td>
<td>RIGHTWARDS DOUBLE ARROW-TAIL</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">-&lt;&lt;</span></code></td>
<td>⤛</td>
<td>0x291B</td>
<td>LEFTWARDS DOUBLE ARROW-TAIL</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">*</span></code></td>
<td>★</td>
<td>0x2605</td>
<td>BLACK STAR</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">forall</span></code></td>
<td>∀</td>
<td>0x2200</td>
<td>FOR ALL</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">(|</span></code></td>
<td>⦇</td>
<td>0x2987</td>
<td>Z NOTATION LEFT IMAGE BRACKET</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">|)</span></code></td>
<td>⦈</td>
<td>0x2988</td>
<td>Z NOTATION RIGHT IMAGE BRACKET</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">[|</span></code></td>
<td>⟦</td>
<td>0x27E6</td>
<td>MATHEMATICAL LEFT WHITE SQUARE BRACKET</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">|]</span></code></td>
<td>⟧</td>
<td>0x27E7</td>
<td>MATHEMATICAL RIGHT WHITE SQUARE BRACKET</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="the-magic-hash">
<span id="magic-hash"></span><h2>10.3.2. The magic hash<a class="headerlink" href="#the-magic-hash" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XMagicHash">
<code class="descname">-XMagicHash</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XMagicHash" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the use of the hash character (<code class="docutils literal"><span class="pre">#</span></code>) as an identifier suffix.</p>
</dd></dl>

<p>The language extension <a class="reference internal" href="#ghc-flag--XMagicHash"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMagicHash</span></code></a> allows <code class="docutils literal"><span class="pre">#</span></code> as a postfix modifier
to identifiers. Thus, <code class="docutils literal"><span class="pre">x#</span></code> is a valid variable, and <code class="docutils literal"><span class="pre">T#</span></code> is a valid type
constructor or data constructor.</p>
<p>The hash sign does not change semantics at all. We tend to use variable
names ending in &#8220;#&#8221; for unboxed values or types (e.g. <code class="docutils literal"><span class="pre">Int#</span></code>), but
there is no requirement to do so; they are just plain ordinary
variables. Nor does the <a class="reference internal" href="#ghc-flag--XMagicHash"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMagicHash</span></code></a> extension bring anything into
scope. For example, to bring <code class="docutils literal"><span class="pre">Int#</span></code> into scope you must import
<code class="docutils literal"><span class="pre">GHC.Prim</span></code> (see <a class="reference internal" href="#primitives"><span>Unboxed types and primitive operations</span></a>); the <a class="reference internal" href="#ghc-flag--XMagicHash"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMagicHash</span></code></a> extension then
allows you to <em>refer</em> to the <code class="docutils literal"><span class="pre">Int#</span></code> that is now in scope. Note that
with this option, the meaning of <code class="docutils literal"><span class="pre">x#y</span> <span class="pre">=</span> <span class="pre">0</span></code> is changed: it defines a
function <code class="docutils literal"><span class="pre">x#</span></code> taking a single argument <code class="docutils literal"><span class="pre">y</span></code>; to define the operator
<code class="docutils literal"><span class="pre">#</span></code>, put a space: <code class="docutils literal"><span class="pre">x</span> <span class="pre">#</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
<p>The <a class="reference internal" href="#ghc-flag--XMagicHash"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMagicHash</span></code></a> also enables some new forms of literals (see
<a class="reference internal" href="#glasgow-unboxed"><span>Unboxed types</span></a>):</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'x'#</span></code> has type <code class="docutils literal"><span class="pre">Char#</span></code></li>
<li><code class="docutils literal"><span class="pre">&quot;foo&quot;#</span></code> has type <code class="docutils literal"><span class="pre">Addr#</span></code></li>
<li><code class="docutils literal"><span class="pre">3#</span></code> has type <code class="docutils literal"><span class="pre">Int#</span></code>. In general, any Haskell integer lexeme
followed by a <code class="docutils literal"><span class="pre">#</span></code> is an <code class="docutils literal"><span class="pre">Int#</span></code> literal, e.g. <code class="docutils literal"><span class="pre">-0x3A#</span></code> as well as
<code class="docutils literal"><span class="pre">32#</span></code>.</li>
<li><code class="docutils literal"><span class="pre">3##</span></code> has type <code class="docutils literal"><span class="pre">Word#</span></code>. In general, any non-negative Haskell
integer lexeme followed by <code class="docutils literal"><span class="pre">##</span></code> is a <code class="docutils literal"><span class="pre">Word#</span></code>.</li>
<li><code class="docutils literal"><span class="pre">3.2#</span></code> has type <code class="docutils literal"><span class="pre">Float#</span></code>.</li>
<li><code class="docutils literal"><span class="pre">3.2##</span></code> has type <code class="docutils literal"><span class="pre">Double#</span></code></li>
</ul>
</div>
<div class="section" id="negative-literals">
<span id="id4"></span><h2>10.3.3. Negative literals<a class="headerlink" href="#negative-literals" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XNegativeLiterals">
<code class="descname">-XNegativeLiterals</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XNegativeLiterals" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.8.1</td>
</tr>
</tbody>
</table>
<p>Enable the use of un-parenthesized negative numeric literals.</p>
</dd></dl>

<p>The literal <code class="docutils literal"><span class="pre">-123</span></code> is, according to Haskell98 and Haskell 2010,
desugared as <code class="docutils literal"><span class="pre">negate</span> <span class="pre">(fromInteger</span> <span class="pre">123)</span></code>. The language extension
<a class="reference internal" href="#ghc-flag--XNegativeLiterals"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNegativeLiterals</span></code></a> means that it is instead desugared as
<code class="docutils literal"><span class="pre">fromInteger</span> <span class="pre">(-123)</span></code>.</p>
<p>This can make a difference when the positive and negative range of a
numeric data type don&#8217;t match up. For example, in 8-bit arithmetic -128
is representable, but +128 is not. So <code class="docutils literal"><span class="pre">negate</span> <span class="pre">(fromInteger</span> <span class="pre">128)</span></code> will
elicit an unexpected integer-literal-overflow message.</p>
</div>
<div class="section" id="fractional-looking-integer-literals">
<span id="num-decimals"></span><h2>10.3.4. Fractional looking integer literals<a class="headerlink" href="#fractional-looking-integer-literals" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XNumDecimals">
<code class="descname">-XNumDecimals</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XNumDecimals" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.8.1</td>
</tr>
</tbody>
</table>
<p>Allow the use of floating-point literal syntax for integral types.</p>
</dd></dl>

<p>Haskell 2010 and Haskell 98 define floating literals with the syntax
<code class="docutils literal"><span class="pre">1.2e6</span></code>. These literals have the type <code class="docutils literal"><span class="pre">Fractional</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code>.</p>
<p>The language extension <a class="reference internal" href="#ghc-flag--XNumDecimals"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNumDecimals</span></code></a> allows you to also use the
floating literal syntax for instances of <code class="docutils literal"><span class="pre">Integral</span></code>, and have values
like <code class="docutils literal"><span class="pre">(1.2e6</span> <span class="pre">::</span> <span class="pre">Num</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a)</span></code></p>
</div>
<div class="section" id="binary-integer-literals">
<span id="binary-literals"></span><h2>10.3.5. Binary integer literals<a class="headerlink" href="#binary-integer-literals" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XBinaryLiterals">
<code class="descname">-XBinaryLiterals</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XBinaryLiterals" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.10.1</td>
</tr>
</tbody>
</table>
<p>Allow the use of binary notation in integer literals.</p>
</dd></dl>

<p>Haskell 2010 and Haskell 98 allows for integer literals to be given in
decimal, octal (prefixed by <code class="docutils literal"><span class="pre">0o</span></code> or <code class="docutils literal"><span class="pre">0O</span></code>), or hexadecimal notation
(prefixed by <code class="docutils literal"><span class="pre">0x</span></code> or <code class="docutils literal"><span class="pre">0X</span></code>).</p>
<p>The language extension <a class="reference internal" href="#ghc-flag--XBinaryLiterals"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XBinaryLiterals</span></code></a> adds support for expressing
integer literals in binary notation with the prefix <code class="docutils literal"><span class="pre">0b</span></code> or <code class="docutils literal"><span class="pre">0B</span></code>. For
instance, the binary integer literal <code class="docutils literal"><span class="pre">0b11001001</span></code> will be desugared into
<code class="docutils literal"><span class="pre">fromInteger</span> <span class="pre">201</span></code> when <a class="reference internal" href="#ghc-flag--XBinaryLiterals"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XBinaryLiterals</span></code></a> is enabled.</p>
</div>
<div class="section" id="pattern-guards">
<span id="id5"></span><h2>10.3.6. Pattern guards<a class="headerlink" href="#pattern-guards" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XNoPatternGuards">
<code class="descname">-XNoPatternGuards</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XNoPatternGuards" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implied by:</th><td class="field-body"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XHaskell98</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Since:</th><td class="field-body">6.8.1</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Disable <a class="reference external" href="http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13">pattern guards</a>.</p>
</div>
<div class="section" id="view-patterns">
<span id="id6"></span><h2>10.3.7. View patterns<a class="headerlink" href="#view-patterns" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XViewPatterns">
<code class="descname">-XViewPatterns</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XViewPatterns" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow use of view pattern syntax.</p>
</dd></dl>

<p>View patterns are enabled by the flag <a class="reference internal" href="#ghc-flag--XViewPatterns"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XViewPatterns</span></code></a>. More
information and examples of view patterns can be found on the
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns">Wiki page</a>.</p>
<p>View patterns are somewhat like pattern guards that can be nested inside
of other patterns. They are a convenient way of pattern-matching against
values of abstract types. For example, in a programming language
implementation, we might represent the syntax of the types of the
language as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Typ</span>

<span class="kr">data</span> <span class="kt">TypView</span> <span class="ow">=</span> <span class="kt">Unit</span>
             <span class="o">|</span> <span class="kt">Arrow</span> <span class="kt">Typ</span> <span class="kt">Typ</span>

<span class="nf">view</span> <span class="ow">::</span> <span class="kt">Typ</span> <span class="ow">-&gt;</span> <span class="kt">TypView</span>

<span class="c1">-- additional operations for constructing Typ&#39;s ...</span>
</pre></div>
</div>
<p>The representation of Typ is held abstract, permitting implementations
to use a fancy representation (e.g., hash-consing to manage sharing).
Without view patterns, using this signature is a little inconvenient:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">size</span> <span class="ow">::</span> <span class="kt">Typ</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">size</span> <span class="n">t</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">view</span> <span class="n">t</span> <span class="kr">of</span>
  <span class="kt">Unit</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
  <span class="kt">Arrow</span> <span class="n">t1</span> <span class="n">t2</span> <span class="ow">-&gt;</span> <span class="n">size</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">size</span> <span class="n">t2</span>
</pre></div>
</div>
<p>It is necessary to iterate the case, rather than using an equational
function definition. And the situation is even worse when the matching
against <code class="docutils literal"><span class="pre">t</span></code> is buried deep inside another pattern.</p>
<p>View patterns permit calling the view function inside the pattern and
matching against the result:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">size</span> <span class="p">(</span><span class="n">view</span> <span class="ow">-&gt;</span> <span class="kt">Unit</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">size</span> <span class="p">(</span><span class="n">view</span> <span class="ow">-&gt;</span> <span class="kt">Arrow</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">size</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">size</span> <span class="n">t2</span>
</pre></div>
</div>
<p>That is, we add a new form of pattern, written ⟨expression⟩ <code class="docutils literal"><span class="pre">-&gt;</span></code>
⟨pattern⟩ that means &#8220;apply the expression to whatever we&#8217;re trying to
match against, and then match the result of that application against the
pattern&#8221;. The expression can be any Haskell expression of function type,
and view patterns can be used wherever patterns are used.</p>
<p>The semantics of a pattern <code class="docutils literal"><span class="pre">(</span></code> ⟨exp⟩ <code class="docutils literal"><span class="pre">-&gt;</span></code> ⟨pat⟩ <code class="docutils literal"><span class="pre">)</span></code> are as
follows:</p>
<ul>
<li><p class="first">Scoping:
The variables bound by the view pattern are the variables bound by
⟨pat⟩.</p>
<p>Any variables in ⟨exp⟩ are bound occurrences, but variables bound &#8220;to
the left&#8221; in a pattern are in scope. This feature permits, for
example, one argument to a function to be used in the view of another
argument. For example, the function <code class="docutils literal"><span class="pre">clunky</span></code> from
<a class="reference internal" href="#pattern-guards"><span>Pattern guards</span></a> can be written using view patterns as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">clunky</span> <span class="n">env</span> <span class="p">(</span><span class="n">lookup</span> <span class="n">env</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">val1</span><span class="p">)</span> <span class="p">(</span><span class="n">lookup</span> <span class="n">env</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">val2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">val1</span> <span class="o">+</span> <span class="n">val2</span>
<span class="o">...</span><span class="n">other</span> <span class="n">equations</span> <span class="n">for</span> <span class="n">clunky</span><span class="o">...</span>
</pre></div>
</div>
<p>More precisely, the scoping rules are:</p>
<ul>
<li><p class="first">In a single pattern, variables bound by patterns to the left of a
view pattern expression are in scope. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">example</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">((</span><span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span><span class="p">,</span><span class="kt">Integer</span><span class="p">),</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">example</span> <span class="kt">Just</span> <span class="p">((</span><span class="n">f</span><span class="p">,</span><span class="kr">_</span><span class="p">),</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Additionally, in function definitions, variables bound by matching
earlier curried arguments may be used in view pattern expressions
in later arguments:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">example</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">example</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="ow">-&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>That is, the scoping is the same as it would be if the curried
arguments were collected into a tuple.</p>
</li>
<li><p class="first">In mutually recursive bindings, such as <code class="docutils literal"><span class="pre">let</span></code>, <code class="docutils literal"><span class="pre">where</span></code>, or the
top level, view patterns in one declaration may not mention
variables bound by other declarations. That is, each declaration
must be self-contained. For example, the following program is not
allowed:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="p">{(</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">e1</span> <span class="p">;</span>
     <span class="p">(</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">e2</span> <span class="p">}</span> <span class="kr">in</span> <span class="n">x</span>
</pre></div>
</div>
</li>
</ul>
<p>(For some amplification on this design choice see <a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/4061">Trac #4061</a>.</p>
</li>
<li><p class="first">Typing: If ⟨exp⟩ has type ⟨T1⟩ <code class="docutils literal"><span class="pre">-&gt;</span></code> ⟨T2⟩ and ⟨pat⟩ matches a ⟨T2⟩,
then the whole view pattern matches a ⟨T1⟩.</p>
</li>
<li><p class="first">Matching: To the equations in Section 3.17.3 of the <a class="reference external" href="http://www.haskell.org/onlinereport/">Haskell 98
Report</a>, add the following:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="p">{</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">e1</span> <span class="p">;</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">e2</span> <span class="p">}</span>
 <span class="ow">=</span>
<span class="kr">case</span> <span class="p">(</span><span class="n">e</span> <span class="n">v</span><span class="p">)</span> <span class="kr">of</span> <span class="p">{</span> <span class="n">p</span> <span class="ow">-&gt;</span> <span class="n">e1</span> <span class="p">;</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">e2</span> <span class="p">}</span>
</pre></div>
</div>
<p>That is, to match a variable ⟨v⟩ against a pattern <code class="docutils literal"><span class="pre">(</span></code> ⟨exp⟩ <code class="docutils literal"><span class="pre">-&gt;</span></code>
⟨pat⟩ <code class="docutils literal"><span class="pre">)</span></code>, evaluate <code class="docutils literal"><span class="pre">(</span></code> ⟨exp⟩ ⟨v⟩ <code class="docutils literal"><span class="pre">)</span></code> and match the result
against ⟨pat⟩.</p>
</li>
<li><p class="first">Efficiency: When the same view function is applied in multiple
branches of a function definition or a case expression (e.g., in
<code class="docutils literal"><span class="pre">size</span></code> above), GHC makes an attempt to collect these applications
into a single nested case expression, so that the view function is
only applied once. Pattern compilation in GHC follows the matrix
algorithm described in Chapter 4 of <a class="reference external" href="http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/">The Implementation of Functional
Programming
Languages</a>.
When the top rows of the first column of a matrix are all view
patterns with the &#8220;same&#8221; expression, these patterns are transformed
into a single nested case. This includes, for example, adjacent view
patterns that line up in a tuple, as in</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="p">((</span><span class="n">view</span> <span class="ow">-&gt;</span> <span class="kt">A</span><span class="p">,</span> <span class="n">p1</span><span class="p">),</span> <span class="n">p2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">e1</span>
<span class="nf">f</span> <span class="p">((</span><span class="n">view</span> <span class="ow">-&gt;</span> <span class="kt">B</span><span class="p">,</span> <span class="n">p3</span><span class="p">),</span> <span class="n">p4</span><span class="p">)</span> <span class="ow">=</span> <span class="n">e2</span>
</pre></div>
</div>
<p>The current notion of when two view pattern expressions are &#8220;the
same&#8221; is very restricted: it is not even full syntactic equality.
However, it does include variables, literals, applications, and
tuples; e.g., two instances of <code class="docutils literal"><span class="pre">view</span> <span class="pre">(&quot;hi&quot;,</span> <span class="pre">&quot;there&quot;)</span></code> will be
collected. However, the current implementation does not compare up to
alpha-equivalence, so two instances of <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">view</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">y)</span></code> will not
be coalesced.</p>
</li>
</ul>
</div>
<div class="section" id="n-k-patterns">
<span id="id7"></span><h2>10.3.8. n+k patterns<a class="headerlink" href="#n-k-patterns" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XNPlusKPatterns">
<code class="descname">-XNPlusKPatterns</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XNPlusKPatterns" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implied by:</th><td class="field-body"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XHaskell98</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Since:</th><td class="field-body">6.12</td>
</tr>
</tbody>
</table>
<p>Enable use of <code class="docutils literal"><span class="pre">n+k</span></code> patterns.</p>
</dd></dl>

</div>
<div class="section" id="the-recursive-do-notation">
<span id="recursive-do-notation"></span><h2>10.3.9. The recursive do-notation<a class="headerlink" href="#the-recursive-do-notation" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XRecursiveDo">
<code class="descname">-XRecursiveDo</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XRecursiveDo" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the use of recursive <code class="docutils literal"><span class="pre">do</span></code> notation.</p>
</dd></dl>

<p>The do-notation of Haskell 98 does not allow <em>recursive bindings</em>, that
is, the variables bound in a do-expression are visible only in the
textually following code block. Compare this to a let-expression, where
bound variables are visible in the entire binding group.</p>
<p>It turns out that such recursive bindings do indeed make sense for a
variety of monads, but not all. In particular, recursion in this sense
requires a fixed-point operator for the underlying monad, captured by
the <code class="docutils literal"><span class="pre">mfix</span></code> method of the <code class="docutils literal"><span class="pre">MonadFix</span></code> class, defined in
<code class="docutils literal"><span class="pre">Control.Monad.Fix</span></code> as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadFix</span> <span class="n">m</span> <span class="kr">where</span>
   <span class="n">mfix</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>Haskell&#8217;s <code class="docutils literal"><span class="pre">Maybe</span></code>, <code class="docutils literal"><span class="pre">[]</span></code> (list), <code class="docutils literal"><span class="pre">ST</span></code> (both strict and lazy
versions), <code class="docutils literal"><span class="pre">IO</span></code>, and many other monads have <code class="docutils literal"><span class="pre">MonadFix</span></code> instances. On
the negative side, the continuation monad, with the signature
<code class="docutils literal"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>, does not.</p>
<p>For monads that do belong to the <code class="docutils literal"><span class="pre">MonadFix</span></code> class, GHC provides an
extended version of the do-notation that allows recursive bindings. The
<a class="reference internal" href="#ghc-flag--XRecursiveDo"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRecursiveDo</span></code></a> (language pragma: <code class="docutils literal"><span class="pre">RecursiveDo</span></code>) provides the
necessary syntactic support, introducing the keywords <code class="docutils literal"><span class="pre">mdo</span></code> and
<code class="docutils literal"><span class="pre">rec</span></code> for higher and lower levels of the notation respectively. Unlike
bindings in a <code class="docutils literal"><span class="pre">do</span></code> expression, those introduced by <code class="docutils literal"><span class="pre">mdo</span></code> and <code class="docutils literal"><span class="pre">rec</span></code>
are recursively defined, much like in an ordinary let-expression. Due to
the new keyword <code class="docutils literal"><span class="pre">mdo</span></code>, we also call this notation the <em>mdo-notation</em>.</p>
<p>Here is a simple (albeit contrived) example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE RecursiveDo #-}</span>
<span class="nf">justOnes</span> <span class="ow">=</span> <span class="n">mdo</span> <span class="p">{</span> <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="p">(</span><span class="mi">1</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
               <span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">map</span> <span class="n">negate</span> <span class="n">xs</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>or equivalently</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE RecursiveDo #-}</span>
<span class="nf">justOnes</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">rec</span> <span class="p">{</span> <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="p">(</span><span class="mi">1</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">}</span>
              <span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">map</span> <span class="n">negate</span> <span class="n">xs</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>As you can guess <code class="docutils literal"><span class="pre">justOnes</span></code> will evaluate to <code class="docutils literal"><span class="pre">Just</span> <span class="pre">[-1,-1,-1,...</span></code>.</p>
<p>GHC&#8217;s implementation the mdo-notation closely follows the original
translation as described in the paper <a class="reference external" href="http://leventerkok.github.io/papers/recdo.pdf">A recursive do for
Haskell</a>, which
in turn is based on the work <a class="reference external" href="http://leventerkok.github.io/papers/erkok-thesis.pdf">Value Recursion in Monadic
Computations</a>.
Furthermore, GHC extends the syntax described in the former paper with a
lower level syntax flagged by the <code class="docutils literal"><span class="pre">rec</span></code> keyword, as we describe next.</p>
<div class="section" id="recursive-binding-groups">
<h3>10.3.9.1. Recursive binding groups<a class="headerlink" href="#recursive-binding-groups" title="Permalink to this headline">¶</a></h3>
<p>The flag <a class="reference internal" href="#ghc-flag--XRecursiveDo"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRecursiveDo</span></code></a> also introduces a new keyword <code class="docutils literal"><span class="pre">rec</span></code>, which
wraps a mutually-recursive group of monadic statements inside a <code class="docutils literal"><span class="pre">do</span></code>
expression, producing a single statement. Similar to a <code class="docutils literal"><span class="pre">let</span></code> statement
inside a <code class="docutils literal"><span class="pre">do</span></code>, variables bound in the <code class="docutils literal"><span class="pre">rec</span></code> are visible throughout
the <code class="docutils literal"><span class="pre">rec</span></code> group, and below it. For example, compare</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="p">{</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">getChar</span>            <span class="kr">do</span> <span class="p">{</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">getChar</span>
   <span class="p">;</span> <span class="kr">let</span> <span class="p">{</span> <span class="n">r1</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">r2</span>          <span class="p">;</span> <span class="n">rec</span> <span class="p">{</span> <span class="n">r1</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">r2</span>
   <span class="p">;</span>     <span class="p">;</span> <span class="n">r2</span> <span class="ow">=</span> <span class="n">g</span> <span class="n">r1</span> <span class="p">}</span>          <span class="p">;</span>     <span class="p">;</span> <span class="n">r2</span> <span class="ow">&lt;-</span> <span class="n">g</span> <span class="n">r1</span> <span class="p">}</span>
   <span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">r1</span> <span class="o">++</span> <span class="n">r2</span><span class="p">)</span> <span class="p">}</span>        <span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">r1</span> <span class="o">++</span> <span class="n">r2</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>In both cases, <code class="docutils literal"><span class="pre">r1</span></code> and <code class="docutils literal"><span class="pre">r2</span></code> are available both throughout the
<code class="docutils literal"><span class="pre">let</span></code> or <code class="docutils literal"><span class="pre">rec</span></code> block, and in the statements that follow it. The
difference is that <code class="docutils literal"><span class="pre">let</span></code> is non-monadic, while <code class="docutils literal"><span class="pre">rec</span></code> is monadic. (In
Haskell <code class="docutils literal"><span class="pre">let</span></code> is really <code class="docutils literal"><span class="pre">letrec</span></code>, of course.)</p>
<p>The semantics of <code class="docutils literal"><span class="pre">rec</span></code> is fairly straightforward. Whenever GHC finds a
<code class="docutils literal"><span class="pre">rec</span></code> group, it will compute its set of bound variables, and will
introduce an appropriate call to the underlying monadic value-recursion
operator <code class="docutils literal"><span class="pre">mfix</span></code>, belonging to the <code class="docutils literal"><span class="pre">MonadFix</span></code> class. Here is an
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">rec</span> <span class="p">{</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span>     <span class="o">===&gt;</span>    <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">mfix</span> <span class="p">(</span><span class="nf">\</span> <span class="o">~</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span>
    <span class="p">;</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span> <span class="p">}</span>                                         <span class="p">;</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span>
                                                           <span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="p">})</span>
</pre></div>
</div>
<p>As usual, the meta-variables <code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">c</span></code> etc., can be arbitrary
patterns. In general, the statement <code class="docutils literal"><span class="pre">rec</span> <span class="pre">ss</span></code> is desugared to the
statement</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">vs</span> <span class="ow">&lt;-</span> <span class="n">mfix</span> <span class="p">(</span><span class="nf">\</span> <span class="o">~</span><span class="n">vs</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">ss</span><span class="p">;</span> <span class="n">return</span> <span class="n">vs</span> <span class="p">})</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">vs</span></code> is a tuple of the variables bound by <code class="docutils literal"><span class="pre">ss</span></code>.</p>
<p>Note in particular that the translation for a <code class="docutils literal"><span class="pre">rec</span></code> block only
involves wrapping a call to <code class="docutils literal"><span class="pre">mfix</span></code>: it performs no other analysis on
the bindings. The latter is the task for the <code class="docutils literal"><span class="pre">mdo</span></code> notation, which is
described next.</p>
</div>
<div class="section" id="the-mdo-notation">
<h3>10.3.9.2. The <code class="docutils literal"><span class="pre">mdo</span></code> notation<a class="headerlink" href="#the-mdo-notation" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal"><span class="pre">rec</span></code>-block tells the compiler where precisely the recursive knot
should be tied. It turns out that the placement of the recursive knots
can be rather delicate: in particular, we would like the knots to be
wrapped around as minimal groups as possible. This process is known as
<em>segmentation</em>, and is described in detail in Section 3.2 of <a class="reference external" href="http://leventerkok.github.io/papers/recdo.pdf">A
recursive do for
Haskell</a>.
Segmentation improves polymorphism and reduces the size of the recursive
knot. Most importantly, it avoids unnecessary interference caused by a
fundamental issue with the so-called <em>right-shrinking</em> axiom for monadic
recursion. In brief, most monads of interest (IO, strict state, etc.) do
<em>not</em> have recursion operators that satisfy this axiom, and thus not
performing segmentation can cause unnecessary interference, changing the
termination behavior of the resulting translation. (Details can be found
in Sections 3.1 and 7.2.2 of <a class="reference external" href="http://leventerkok.github.io/papers/erkok-thesis.pdf">Value Recursion in Monadic
Computations</a>.)</p>
<p>The <code class="docutils literal"><span class="pre">mdo</span></code> notation removes the burden of placing explicit <code class="docutils literal"><span class="pre">rec</span></code>
blocks in the code. Unlike an ordinary <code class="docutils literal"><span class="pre">do</span></code> expression, in which
variables bound by statements are only in scope for later statements,
variables bound in an <code class="docutils literal"><span class="pre">mdo</span></code> expression are in scope for all statements
of the expression. The compiler then automatically identifies minimal
mutually recursively dependent segments of statements, treating them as
if the user had wrapped a <code class="docutils literal"><span class="pre">rec</span></code> qualifier around them.</p>
<p>The definition is syntactic:</p>
<ul class="simple">
<li>A generator ⟨g⟩ <em>depends</em> on a textually following generator ⟨g&#8217;⟩, if<ul>
<li>⟨g&#8217;⟩ defines a variable that is used by ⟨g⟩, or</li>
<li>⟨g&#8217;⟩ textually appears between ⟨g⟩ and ⟨g&#8217;&#8216;⟩, where ⟨g⟩ depends on
⟨g&#8217;&#8216;⟩.</li>
</ul>
</li>
<li>A <em>segment</em> of a given <code class="docutils literal"><span class="pre">mdo</span></code>-expression is a minimal sequence of
generators such that no generator of the sequence depends on an
outside generator. As a special case, although it is not a generator,
the final expression in an <code class="docutils literal"><span class="pre">mdo</span></code>-expression is considered to form a
segment by itself.</li>
</ul>
<p>Segments in this sense are related to <em>strongly-connected components</em>
analysis, with the exception that bindings in a segment cannot be
reordered and must be contiguous.</p>
<p>Here is an example <code class="docutils literal"><span class="pre">mdo</span></code>-expression, and its translation to <code class="docutils literal"><span class="pre">rec</span></code>
blocks:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">mdo</span> <span class="p">{</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">getChar</span>      <span class="o">===&gt;</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">getChar</span>
    <span class="p">;</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span>                <span class="p">;</span> <span class="n">rec</span> <span class="p">{</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span>
    <span class="p">;</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span>                <span class="p">;</span>     <span class="p">;</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span> <span class="p">}</span>
    <span class="p">;</span> <span class="n">z</span> <span class="ow">&lt;-</span> <span class="n">h</span> <span class="n">a</span> <span class="n">b</span>                <span class="p">;</span> <span class="n">z</span> <span class="ow">&lt;-</span> <span class="n">h</span> <span class="n">a</span> <span class="n">b</span>
    <span class="p">;</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">g</span> <span class="n">d</span> <span class="n">e</span>                <span class="p">;</span> <span class="n">rec</span> <span class="p">{</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">g</span> <span class="n">d</span> <span class="n">e</span>
    <span class="p">;</span> <span class="n">e</span> <span class="ow">&lt;-</span> <span class="n">g</span> <span class="n">a</span> <span class="n">z</span>                <span class="p">;</span>     <span class="p">;</span> <span class="n">e</span> <span class="ow">&lt;-</span> <span class="n">g</span> <span class="n">a</span> <span class="n">z</span> <span class="p">}</span>
    <span class="p">;</span> <span class="n">putChar</span> <span class="n">c</span> <span class="p">}</span>               <span class="p">;</span> <span class="n">putChar</span> <span class="n">c</span> <span class="p">}</span>
</pre></div>
</div>
<p>Note that a given <code class="docutils literal"><span class="pre">mdo</span></code> expression can cause the creation of multiple
<code class="docutils literal"><span class="pre">rec</span></code> blocks. If there are no recursive dependencies, <code class="docutils literal"><span class="pre">mdo</span></code> will
introduce no <code class="docutils literal"><span class="pre">rec</span></code> blocks. In this latter case an <code class="docutils literal"><span class="pre">mdo</span></code> expression
is precisely the same as a <code class="docutils literal"><span class="pre">do</span></code> expression, as one would expect.</p>
<p>In summary, given an <code class="docutils literal"><span class="pre">mdo</span></code> expression, GHC first performs
segmentation, introducing <code class="docutils literal"><span class="pre">rec</span></code> blocks to wrap over minimal recursive
groups. Then, each resulting <code class="docutils literal"><span class="pre">rec</span></code> is desugared, using a call to
<code class="docutils literal"><span class="pre">Control.Monad.Fix.mfix</span></code> as described in the previous section. The
original <code class="docutils literal"><span class="pre">mdo</span></code>-expression typechecks exactly when the desugared
version would do so.</p>
<p>Here are some other important points in using the recursive-do notation:</p>
<ul class="simple">
<li>It is enabled with the flag <a class="reference internal" href="#ghc-flag--XRecursiveDo"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRecursiveDo</span></code></a>, or the
<code class="docutils literal"><span class="pre">LANGUAGE</span> <span class="pre">RecursiveDo</span></code> pragma. (The same flag enables both
<code class="docutils literal"><span class="pre">mdo</span></code>-notation, and the use of <code class="docutils literal"><span class="pre">rec</span></code> blocks inside <code class="docutils literal"><span class="pre">do</span></code>
expressions.)</li>
<li><code class="docutils literal"><span class="pre">rec</span></code> blocks can also be used inside <code class="docutils literal"><span class="pre">mdo</span></code>-expressions, which
will be treated as a single statement. However, it is good style to
either use <code class="docutils literal"><span class="pre">mdo</span></code> or <code class="docutils literal"><span class="pre">rec</span></code> blocks in a single expression.</li>
<li>If recursive bindings are required for a monad, then that monad must
be declared an instance of the <code class="docutils literal"><span class="pre">MonadFix</span></code> class.</li>
<li>The following instances of <code class="docutils literal"><span class="pre">MonadFix</span></code> are automatically provided:
List, Maybe, IO. Furthermore, the <code class="docutils literal"><span class="pre">Control.Monad.ST</span></code> and
<code class="docutils literal"><span class="pre">Control.Monad.ST.Lazy</span></code> modules provide the instances of the
<code class="docutils literal"><span class="pre">MonadFix</span></code> class for Haskell&#8217;s internal state monad (strict and
lazy, respectively).</li>
<li>Like <code class="docutils literal"><span class="pre">let</span></code> and <code class="docutils literal"><span class="pre">where</span></code> bindings, name shadowing is not allowed
within an <code class="docutils literal"><span class="pre">mdo</span></code>-expression or a <code class="docutils literal"><span class="pre">rec</span></code>-block; that is, all the
names bound in a single <code class="docutils literal"><span class="pre">rec</span></code> must be distinct. (GHC will complain
if this is not the case.)</li>
</ul>
</div>
</div>
<div class="section" id="applicative-do-notation">
<span id="applicative-do"></span><h2>10.3.10. Applicative do-notation<a class="headerlink" href="#applicative-do-notation" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-2"></span><dl class="ghc-flag">
<dt id="ghc-flag--XApplicativeDo">
<code class="descname">-XApplicativeDo</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XApplicativeDo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Allow use of <code class="docutils literal"><span class="pre">Applicative</span></code> <code class="docutils literal"><span class="pre">do</span></code> notation.</p>
</dd></dl>

<p>The language option <a class="reference internal" href="#ghc-flag--XApplicativeDo"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XApplicativeDo</span></code></a> enables an alternative translation for
the do-notation, which uses the operators <code class="docutils literal"><span class="pre">&lt;$&gt;</span></code>, <code class="docutils literal"><span class="pre">&lt;*&gt;</span></code>, along with <code class="docutils literal"><span class="pre">join</span></code>
as far as possible. There are two main reasons for wanting to do this:</p>
<ul class="simple">
<li>We can use do-notation with types that are an instance of <code class="docutils literal"><span class="pre">Applicative</span></code> and
<code class="docutils literal"><span class="pre">Functor</span></code>, but not <code class="docutils literal"><span class="pre">Monad</span></code></li>
<li>In some monads, using the applicative operators is more efficient than monadic
bind. For example, it may enable more parallelism.</li>
</ul>
<p>Applicative do-notation desugaring preserves the original semantics, provided
that the <code class="docutils literal"><span class="pre">Applicative</span></code> instance satisfies <code class="docutils literal"><span class="pre">&lt;*&gt;</span> <span class="pre">=</span> <span class="pre">ap</span></code> and <code class="docutils literal"><span class="pre">pure</span> <span class="pre">=</span> <span class="pre">return</span></code>
(these are true of all the common monadic types). Thus, you can normally turn on
<a class="reference internal" href="#ghc-flag--XApplicativeDo"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XApplicativeDo</span></code></a> without fear of breaking your program. There is one pitfall
to watch out for; see <a class="reference internal" href="#applicative-do-pitfall"><span>Things to watch out for</span></a>.</p>
<p>There are no syntactic changes with <a class="reference internal" href="#ghc-flag--XApplicativeDo"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XApplicativeDo</span></code></a>. The only way it shows
up at the source level is that you can have a <code class="docutils literal"><span class="pre">do</span></code> expression that doesn&#8217;t
require a <code class="docutils literal"><span class="pre">Monad</span></code> constraint. For example, in GHCi:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">set</span> <span class="o">-</span><span class="kt">XApplicativeDo</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span><span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">not</span> <span class="n">x</span><span class="p">)</span> <span class="p">}</span>
<span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span><span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">not</span> <span class="n">x</span><span class="p">)</span> <span class="p">}</span>
  <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>This example only requires <code class="docutils literal"><span class="pre">Functor</span></code>, because it is translated into <code class="docutils literal"><span class="pre">(\x</span> <span class="pre">-&gt;</span>
<span class="pre">not</span> <span class="pre">x)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">m</span></code>. A more complex example requires <code class="docutils literal"><span class="pre">Applicative</span></code>,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">||</span> <span class="n">y</span><span class="p">)</span> <span class="p">}</span>
<span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">||</span> <span class="n">y</span><span class="p">)</span> <span class="p">}</span>
  <span class="ow">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Here GHC has translated the expression into</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">||</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">m</span> <span class="sc">&#39;a&#39;</span> <span class="o">&lt;*&gt;</span> <span class="n">m</span> <span class="sc">&#39;b&#39;</span>
</pre></div>
</div>
<p>It is possible to see the actual translation by using <a class="reference internal" href="debugging.html#ghc-flag--ddump-ds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-ds</span></code></a>, but be
warned, the output is quite verbose.</p>
<p>Note that if the expression can&#8217;t be translated into uses of <code class="docutils literal"><span class="pre">&lt;$&gt;</span></code>, <code class="docutils literal"><span class="pre">&lt;*&gt;</span></code>
only, then it will incur a <code class="docutils literal"><span class="pre">Monad</span></code> constraint as usual. This happens when
there is a dependency on a value produced by an earlier statement in the
<code class="docutils literal"><span class="pre">do</span></code>-block:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="kt">True</span><span class="p">;</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="n">x</span><span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">||</span> <span class="n">y</span><span class="p">)</span> <span class="p">}</span>
<span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="kt">True</span><span class="p">;</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="n">x</span><span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">||</span> <span class="n">y</span><span class="p">)</span> <span class="p">}</span>
  <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span></code> depends on the value of <code class="docutils literal"><span class="pre">x</span></code> produced by the first statement, so
the expression cannot be translated using <code class="docutils literal"><span class="pre">&lt;*&gt;</span></code>.</p>
<p>In general, the rule for when a <code class="docutils literal"><span class="pre">do</span></code> statement incurs a <code class="docutils literal"><span class="pre">Monad</span></code> constraint
is as follows. If the do-expression has the following form:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="n">p1</span> <span class="ow">&lt;-</span> <span class="kt">E1</span><span class="p">;</span> <span class="o">...</span><span class="p">;</span> <span class="n">pn</span> <span class="ow">&lt;-</span> <span class="kt">En</span><span class="p">;</span> <span class="n">return</span> <span class="kt">E</span>
</pre></div>
</div>
<p>where none of the variables defined by <code class="docutils literal"><span class="pre">p1...pn</span></code> are mentioned in <code class="docutils literal"><span class="pre">E1...En</span></code>,
then the expression will only require <code class="docutils literal"><span class="pre">Applicative</span></code>. Otherwise, the expression
will require <code class="docutils literal"><span class="pre">Monad</span></code>. The block may return a pure expression <code class="docutils literal"><span class="pre">E</span></code> depending
upon the results <code class="docutils literal"><span class="pre">p1...pn</span></code> with either <code class="docutils literal"><span class="pre">return</span></code> or <code class="docutils literal"><span class="pre">pure</span></code>.</p>
<p>Note: the final statement must match one of these patterns exactly:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">return</span> <span class="pre">E</span></code></li>
<li><code class="docutils literal"><span class="pre">return</span> <span class="pre">$</span> <span class="pre">E</span></code></li>
<li><code class="docutils literal"><span class="pre">pure</span> <span class="pre">E</span></code></li>
<li><code class="docutils literal"><span class="pre">pure</span> <span class="pre">$</span> <span class="pre">E</span></code></li>
</ul>
<p>otherwise GHC cannot recognise it as a <code class="docutils literal"><span class="pre">return</span></code> statement, and the
transformation to use <code class="docutils literal"><span class="pre">&lt;$&gt;</span></code> that we saw above does not apply.  In
particular, slight variations such as <code class="docutils literal"><span class="pre">return</span> <span class="pre">.</span> <span class="pre">Just</span> <span class="pre">$</span> <span class="pre">x</span></code> or <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span>
<span class="pre">=</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">return</span> <span class="pre">x</span></code> would not be recognised.</p>
<p>If the final statement is not of one of these forms, GHC falls back to
standard <code class="docutils literal"><span class="pre">do</span></code> desugaring, and the expression will require a
<code class="docutils literal"><span class="pre">Monad</span></code> constraint.</p>
<p>When the statements of a <code class="docutils literal"><span class="pre">do</span></code> expression have dependencies between
them, and <code class="docutils literal"><span class="pre">ApplicativeDo</span></code> cannot infer an <code class="docutils literal"><span class="pre">Applicative</span></code> type, it
uses a heuristic algorithm to try to use <code class="docutils literal"><span class="pre">&lt;*&gt;</span></code> as much as possible.
This algorithm usually finds the best solution, but in rare complex
cases it might miss an opportunity.  There is an algorithm that finds
the optimal solution, provided as an option:</p>
<dl class="ghc-flag">
<dt id="ghc-flag--foptimal-applicative-do">
<code class="descname">-foptimal-applicative-do</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--foptimal-applicative-do" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Enables an alternative algorithm for choosing where to use <code class="docutils literal"><span class="pre">&lt;*&gt;</span></code>
in conjunction with the <code class="docutils literal"><span class="pre">ApplicativeDo</span></code> language extension.
This algorithm always finds the optimal solution, but it is
expensive: <code class="docutils literal"><span class="pre">O(n^3)</span></code>, so this option can lead to long compile
times when there are very large <code class="docutils literal"><span class="pre">do</span></code> expressions (over 100
statements).  The default <code class="docutils literal"><span class="pre">ApplicativeDo</span></code> algorithm is <code class="docutils literal"><span class="pre">O(n^2)</span></code>.</p>
</dd></dl>

<div class="section" id="existential-patterns-and-gadts">
<span id="applicative-do-existential"></span><h3>10.3.10.1. Existential patterns and GADTs<a class="headerlink" href="#existential-patterns-and-gadts" title="Permalink to this headline">¶</a></h3>
<p>Note that when the pattern in a statement matches a constructor with
existential type variables and/or constraints, the transformation that
<code class="docutils literal"><span class="pre">ApplicativeDo</span></code> performs may mean that the pattern does not scope
over the statements that follow it.  This is because the rearrangement
happens before the expression is typechecked.  For example, this
program does not typecheck:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE RankNTypes, GADTs, ApplicativeDo #-}</span>

<span class="kr">data</span> <span class="kt">T</span> <span class="kr">where</span> <span class="kt">A</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span> <span class="o">.</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">T</span>

<span class="nf">test</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kt">A</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">undefined</span>
  <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">return</span> <span class="kt">True</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>The reason is that the <code class="docutils literal"><span class="pre">Eq</span></code> constraint that would be brought into
scope from the pattern match <code class="docutils literal"><span class="pre">A</span> <span class="pre">x</span></code> is not available when
typechecking the expression <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code>, because <code class="docutils literal"><span class="pre">ApplicativeDo</span></code> has
rearranged the expression to look like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">test</span> <span class="ow">=</span>
  <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
    <span class="o">&lt;$&gt;</span> <span class="kr">do</span> <span class="kt">A</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">undefined</span><span class="p">;</span> <span class="n">return</span> <span class="n">x</span>
    <span class="o">&lt;*&gt;</span> <span class="n">return</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Turning off <code class="docutils literal"><span class="pre">ApplicativeDo</span></code> lets the program typecheck.  This is
something to bear in mind when using <code class="docutils literal"><span class="pre">ApplicativeDo</span></code> in combination
with <a class="reference internal" href="#existential-quantification"><span>Existentially quantified data constructors</span></a> or <a class="reference internal" href="#gadt"><span>Generalised Algebraic Data Types (GADTs)</span></a>.</p>
</div>
<div class="section" id="things-to-watch-out-for">
<span id="applicative-do-pitfall"></span><h3>10.3.10.2. Things to watch out for<a class="headerlink" href="#things-to-watch-out-for" title="Permalink to this headline">¶</a></h3>
<p>Your code should just work as before when <a class="reference internal" href="#ghc-flag--XApplicativeDo"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XApplicativeDo</span></code></a> is enabled,
provided you use conventional <code class="docutils literal"><span class="pre">Applicative</span></code> instances. However, if you define
a <code class="docutils literal"><span class="pre">Functor</span></code> or <code class="docutils literal"><span class="pre">Applicative</span></code> instance using do-notation, then it will likely
get turned into an infinite loop by GHC. For example, if you do this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">MyType</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span><span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Then applicative desugaring will turn it into</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">MyType</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">m</span>
</pre></div>
</div>
<p>And the program will loop at runtime. Similarly, an <code class="docutils literal"><span class="pre">Applicative</span></code> instance
like this</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">MyType</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="ow">=</span> <span class="n">return</span>
    <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">x</span><span class="p">;</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">y</span><span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>will result in an infinte loop when <code class="docutils literal"><span class="pre">&lt;*&gt;</span></code> is called.</p>
<p>Just as you wouldn&#8217;t define a <code class="docutils literal"><span class="pre">Monad</span></code> instance using the do-notation, you
shouldn&#8217;t define <code class="docutils literal"><span class="pre">Functor</span></code> or <code class="docutils literal"><span class="pre">Applicative</span></code> instance using do-notation (when
using <code class="docutils literal"><span class="pre">ApplicativeDo</span></code>) either. The correct way to define these instances in
terms of <code class="docutils literal"><span class="pre">Monad</span></code> is to use the <code class="docutils literal"><span class="pre">Monad</span></code> operations directly, e.g.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">MyType</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span> <span class="o">.</span> <span class="n">f</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">MyType</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="ow">=</span> <span class="n">return</span>
    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">ap</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="parallel-list-comprehensions">
<span id="id8"></span><h2>10.3.11. Parallel List Comprehensions<a class="headerlink" href="#parallel-list-comprehensions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-3"></span><dl class="ghc-flag">
<dt id="ghc-flag--XParallelListComp">
<code class="descname">-XParallelListComp</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XParallelListComp" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow parallel list comprehension syntax.</p>
</dd></dl>

<p>Parallel list comprehensions are a natural extension to list
comprehensions. List comprehensions can be thought of as a nice syntax
for writing maps and filters. Parallel comprehensions extend this to
include the <code class="docutils literal"><span class="pre">zipWith</span></code> family.</p>
<p>A parallel list comprehension has multiple independent branches of
qualifier lists, each separated by a <code class="docutils literal"><span class="pre">|</span></code> symbol. For example, the
following zips together two lists:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">ys</span> <span class="p">]</span>
</pre></div>
</div>
<p>The behaviour of parallel list comprehensions follows that of zip, in
that the resulting list will have the same length as the shortest
branch.</p>
<p>We can define parallel list comprehensions by translation to regular
comprehensions. Here&#8217;s the basic idea:</p>
<p>Given a parallel comprehension of the form:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="n">e</span> <span class="o">|</span> <span class="n">p1</span> <span class="ow">&lt;-</span> <span class="n">e11</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">&lt;-</span> <span class="n">e12</span><span class="p">,</span> <span class="o">...</span>
    <span class="o">|</span> <span class="n">q1</span> <span class="ow">&lt;-</span> <span class="n">e21</span><span class="p">,</span> <span class="n">q2</span> <span class="ow">&lt;-</span> <span class="n">e22</span><span class="p">,</span> <span class="o">...</span>
    <span class="o">...</span>
<span class="p">]</span>
</pre></div>
</div>
<p>This will be translated to:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="n">e</span> <span class="o">|</span> <span class="p">((</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">),</span> <span class="p">(</span><span class="n">q1</span><span class="p">,</span><span class="n">q2</span><span class="p">),</span> <span class="o">...</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">zipN</span> <span class="p">[(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span> <span class="o">|</span> <span class="n">p1</span> <span class="ow">&lt;-</span> <span class="n">e11</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">&lt;-</span> <span class="n">e12</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                                      <span class="p">[(</span><span class="n">q1</span><span class="p">,</span><span class="n">q2</span><span class="p">)</span> <span class="o">|</span> <span class="n">q1</span> <span class="ow">&lt;-</span> <span class="n">e21</span><span class="p">,</span> <span class="n">q2</span> <span class="ow">&lt;-</span> <span class="n">e22</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                                      <span class="o">...</span>
<span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">zipN</span></code> is the appropriate zip for the given number of branches.</p>
</div>
<div class="section" id="generalised-sql-like-list-comprehensions">
<span id="generalised-list-comprehensions"></span><h2>10.3.12. Generalised (SQL-like) List Comprehensions<a class="headerlink" href="#generalised-sql-like-list-comprehensions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><dl class="ghc-flag">
<dt id="ghc-flag--XTransformListComp">
<code class="descname">-XTransformListComp</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XTransformListComp" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow use of generalised list (SQL-like) comprehension syntax. This
introduces the <code class="docutils literal"><span class="pre">group</span></code>, <code class="docutils literal"><span class="pre">by</span></code>, and <code class="docutils literal"><span class="pre">using</span></code> keywords.</p>
</dd></dl>

<p>Generalised list comprehensions are a further enhancement to the list
comprehension syntactic sugar to allow operations such as sorting and
grouping which are familiar from SQL. They are fully described in the
paper <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf">Comprehensive comprehensions: comprehensions with &#8220;order by&#8221; and
&#8220;group by&#8221;</a>,
except that the syntax we use differs slightly from the paper.</p>
<p>The extension is enabled with the flag <a class="reference internal" href="#ghc-flag--XTransformListComp"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTransformListComp</span></code></a>.</p>
<p>Here is an example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">employees</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="s">&quot;Simon&quot;</span><span class="p">,</span> <span class="s">&quot;MS&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
            <span class="p">,</span> <span class="p">(</span><span class="s">&quot;Erik&quot;</span><span class="p">,</span> <span class="s">&quot;MS&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
            <span class="p">,</span> <span class="p">(</span><span class="s">&quot;Phil&quot;</span><span class="p">,</span> <span class="s">&quot;Ed&quot;</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
            <span class="p">,</span> <span class="p">(</span><span class="s">&quot;Gordon&quot;</span><span class="p">,</span> <span class="s">&quot;Ed&quot;</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
            <span class="p">,</span> <span class="p">(</span><span class="s">&quot;Paul&quot;</span><span class="p">,</span> <span class="s">&quot;Yale&quot;</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span> <span class="p">]</span>

<span class="nf">output</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">the</span> <span class="n">dept</span><span class="p">,</span> <span class="n">sum</span> <span class="n">salary</span><span class="p">)</span>
         <span class="o">|</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dept</span><span class="p">,</span> <span class="n">salary</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">employees</span>
         <span class="p">,</span> <span class="kr">then</span> <span class="n">group</span> <span class="n">by</span> <span class="n">dept</span> <span class="n">using</span> <span class="n">groupWith</span>
         <span class="p">,</span> <span class="kr">then</span> <span class="n">sortWith</span> <span class="n">by</span> <span class="p">(</span><span class="n">sum</span> <span class="n">salary</span><span class="p">)</span>
         <span class="p">,</span> <span class="kr">then</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">]</span>
</pre></div>
</div>
<p>In this example, the list <code class="docutils literal"><span class="pre">output</span></code> would take on the value:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[(</span><span class="s">&quot;Yale&quot;</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;Ed&quot;</span><span class="p">,</span> <span class="mi">85</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;MS&quot;</span><span class="p">,</span> <span class="mi">180</span><span class="p">)]</span>
</pre></div>
</div>
<p>There are three new keywords: <code class="docutils literal"><span class="pre">group</span></code>, <code class="docutils literal"><span class="pre">by</span></code>, and <code class="docutils literal"><span class="pre">using</span></code>. (The
functions <code class="docutils literal"><span class="pre">sortWith</span></code> and <code class="docutils literal"><span class="pre">groupWith</span></code> are not keywords; they are
ordinary functions that are exported by <code class="docutils literal"><span class="pre">GHC.Exts</span></code>.)</p>
<p>There are five new forms of comprehension qualifier, all introduced by
the (existing) keyword <code class="docutils literal"><span class="pre">then</span></code>:</p>
<ul>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kr">then</span> <span class="n">f</span>
</pre></div>
</div>
<p>This statement requires that
f
have the type
forall a. [a] -&gt; [a]
. You can see an example of its use in the motivating example, as
this form is used to apply
take 5
.</p>
</li>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kr">then</span> <span class="n">f</span> <span class="n">by</span> <span class="n">e</span>
</pre></div>
</div>
<p>This form is similar to the previous one, but allows you to create a
function which will be passed as the first argument to f. As a
consequence f must have the type
<code class="docutils literal"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">t)</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code>. As you can see from the type,
this function lets f &#8220;project out&#8221; some information from the elements
of the list it is transforming.</p>
<p>An example is shown in the opening example, where <code class="docutils literal"><span class="pre">sortWith</span></code> is
supplied with a function that lets it find out the <code class="docutils literal"><span class="pre">sum</span> <span class="pre">salary</span></code> for
any item in the list comprehension it transforms.</p>
</li>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kr">then</span> <span class="n">group</span> <span class="n">by</span> <span class="n">e</span> <span class="n">using</span> <span class="n">f</span>
</pre></div>
</div>
<p>This is the most general of the grouping-type statements. In this
form, f is required to have type
<code class="docutils literal"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">t)</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[[a]]</span></code>. As with the <code class="docutils literal"><span class="pre">then</span> <span class="pre">f</span> <span class="pre">by</span> <span class="pre">e</span></code>
case above, the first argument is a function supplied to f by the
compiler which lets it compute e on every element of the list being
transformed. However, unlike the non-grouping case, f additionally
partitions the list into a number of sublists: this means that at
every point after this statement, binders occurring before it in the
comprehension refer to <em>lists</em> of possible values, not single values.
To help understand this, let&#8217;s look at an example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- This works similarly to groupWith in GHC.Exts, but doesn&#39;t sort its input first</span>
<span class="nf">groupRuns</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="nf">groupRuns</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">groupBy</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">==</span> <span class="n">f</span> <span class="n">y</span><span class="p">)</span>

<span class="nf">output</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">the</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">([</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">])</span>
<span class="p">,</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">6</span><span class="p">]</span>
<span class="p">,</span> <span class="kr">then</span> <span class="n">group</span> <span class="n">by</span> <span class="n">x</span> <span class="n">using</span> <span class="n">groupRuns</span> <span class="p">]</span>
</pre></div>
</div>
<p>This results in the variable <code class="docutils literal"><span class="pre">output</span></code> taking on the value below:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])]</span>
</pre></div>
</div>
<p>Note that we have used the <code class="docutils literal"><span class="pre">the</span></code> function to change the type of x
from a list to its original numeric type. The variable y, in
contrast, is left unchanged from the list form introduced by the
grouping.</p>
</li>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kr">then</span> <span class="n">group</span> <span class="n">using</span> <span class="n">f</span>
</pre></div>
</div>
<p>With this form of the group statement, f is required to simply have
the type <code class="docutils literal"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[[a]]</span></code>, which will be used to group up
the comprehension so far directly. An example of this form is as
follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">output</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">x</span>
<span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>
<span class="p">,</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="s">&quot;hello&quot;</span>
<span class="p">,</span> <span class="kr">then</span> <span class="n">group</span> <span class="n">using</span> <span class="n">inits</span><span class="p">]</span>
</pre></div>
</div>
<p>This will yield a list containing every prefix of the word &#8220;hello&#8221;
written out 5 times:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;h&quot;</span><span class="p">,</span><span class="s">&quot;he&quot;</span><span class="p">,</span><span class="s">&quot;hel&quot;</span><span class="p">,</span><span class="s">&quot;hell&quot;</span><span class="p">,</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="s">&quot;helloh&quot;</span><span class="p">,</span><span class="s">&quot;hellohe&quot;</span><span class="p">,</span><span class="s">&quot;hellohel&quot;</span><span class="p">,</span><span class="s">&quot;hellohell&quot;</span><span class="p">,</span><span class="s">&quot;hellohello&quot;</span><span class="p">,</span><span class="s">&quot;hellohelloh&quot;</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="monad-comprehensions">
<span id="id9"></span><h2>10.3.13. Monad comprehensions<a class="headerlink" href="#monad-comprehensions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-5"></span><dl class="ghc-flag">
<dt id="ghc-flag--XMonadComprehensions">
<code class="descname">-XMonadComprehensions</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XMonadComprehensions" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.2</td>
</tr>
</tbody>
</table>
<p>Enable list comprehension syntax for arbitrary monads.</p>
</dd></dl>

<p>Monad comprehensions generalise the list comprehension notation,
including parallel comprehensions (<a class="reference internal" href="#parallel-list-comprehensions"><span>Parallel List Comprehensions</span></a>)
and transform comprehensions (<a class="reference internal" href="#generalised-list-comprehensions"><span>Generalised (SQL-like) List Comprehensions</span></a>) to
work for any monad.</p>
<p>Monad comprehensions support:</p>
<ul>
<li><p class="first">Bindings:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="mi">2</span> <span class="p">]</span>
</pre></div>
</div>
<p>Bindings are translated with the <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> and <code class="docutils literal"><span class="pre">return</span></code> functions
to the usual do-notation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="mi">1</span>
   <span class="n">y</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="mi">2</span>
   <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Guards:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="p">]</span>
</pre></div>
</div>
<p>Guards are translated with the <code class="docutils literal"><span class="pre">guard</span></code> function, which requires a
<code class="docutils literal"><span class="pre">MonadPlus</span></code> instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
   <span class="n">guard</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span>
   <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
</li>
<li><p class="first">Transform statements (as with <a class="reference internal" href="#ghc-flag--XTransformListComp"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTransformListComp</span></code></a>):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="p">],</span> <span class="kr">then</span> <span class="n">take</span> <span class="mi">2</span> <span class="p">]</span>
</pre></div>
</div>
<p>This translates to:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">take</span> <span class="mi">2</span> <span class="p">(</span><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
                       <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="p">]</span>
                       <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
   <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Group statements (as with <a class="reference internal" href="#ghc-flag--XTransformListComp"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTransformListComp</span></code></a>):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="kr">then</span> <span class="n">group</span> <span class="n">by</span> <span class="n">x</span> <span class="n">using</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Exts</span><span class="o">.</span><span class="n">groupWith</span> <span class="p">]</span>
<span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="kr">then</span> <span class="n">group</span> <span class="n">using</span> <span class="n">myGroup</span> <span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">Parallel statements (as with <a class="reference internal" href="#ghc-flag--XParallelListComp"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XParallelListComp</span></code></a>):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">11</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
        <span class="p">]</span>
</pre></div>
</div>
<p>Parallel statements are translated using the <code class="docutils literal"><span class="pre">mzip</span></code> function, which
requires a <code class="docutils literal"><span class="pre">MonadZip</span></code> instance defined in
<a class="reference external" href="../libraries/base-4.10.1.0/Control-Monad-Zip.html">Control.Monad.Zip</a>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">mzip</span> <span class="p">(</span><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
                     <span class="n">return</span> <span class="n">x</span><span class="p">)</span>
                 <span class="p">(</span><span class="kr">do</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">11</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
                     <span class="n">return</span> <span class="n">y</span><span class="p">)</span>
   <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>All these features are enabled by default if the <a class="reference internal" href="#ghc-flag--XMonadComprehensions"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonadComprehensions</span></code></a>
extension is enabled. The types and more detailed examples on how to use
comprehensions are explained in the previous chapters
<a class="reference internal" href="#generalised-list-comprehensions"><span>Generalised (SQL-like) List Comprehensions</span></a> and
<a class="reference internal" href="#parallel-list-comprehensions"><span>Parallel List Comprehensions</span></a>. In general you just have to replace
the type <code class="docutils literal"><span class="pre">[a]</span></code> with the type <code class="docutils literal"><span class="pre">Monad</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code> for monad
comprehensions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Even though most of these examples are using the list monad, monad
comprehensions work for any monad. The <code class="docutils literal"><span class="pre">base</span></code> package offers all
necessary instances for lists, which make <a class="reference internal" href="#ghc-flag--XMonadComprehensions"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonadComprehensions</span></code></a>
backward compatible to built-in, transform and parallel list
comprehensions.</p>
</div>
<p>More formally, the desugaring is as follows. We write <code class="docutils literal"><span class="pre">D[</span> <span class="pre">e</span> <span class="pre">|</span> <span class="pre">Q]</span></code> to
mean the desugaring of the monad comprehension <code class="docutils literal"><span class="pre">[</span> <span class="pre">e</span> <span class="pre">|</span> <span class="pre">Q]</span></code>:</p>
<div class="highlight-none"><div class="highlight"><pre>Expressions: e
Declarations: d
Lists of qualifiers: Q,R,S

-- Basic forms
D[ e | ]               = return e
D[ e | p &lt;- e, Q ]  = e &gt;&gt;= \p -&gt; D[ e | Q ]
D[ e | e, Q ]          = guard e &gt;&gt; \p -&gt; D[ e | Q ]
D[ e | let d, Q ]      = let d in D[ e | Q ]

-- Parallel comprehensions (iterate for multiple parallel branches)
D[ e | (Q | R), S ]    = mzip D[ Qv | Q ] D[ Rv | R ] &gt;&gt;= \(Qv,Rv) -&gt; D[ e | S ]

-- Transform comprehensions
D[ e | Q then f, R ]                  = f D[ Qv | Q ] &gt;&gt;= \Qv -&gt; D[ e | R ]

D[ e | Q then f by b, R ]             = f (\Qv -&gt; b) D[ Qv | Q ] &gt;&gt;= \Qv -&gt; D[ e | R ]

D[ e | Q then group using f, R ]      = f D[ Qv | Q ] &gt;&gt;= \ys -&gt;
                                        case (fmap selQv1 ys, ..., fmap selQvn ys) of
                                         Qv -&gt; D[ e | R ]

D[ e | Q then group by b using f, R ] = f (\Qv -&gt; b) D[ Qv | Q ] &gt;&gt;= \ys -&gt;
                                        case (fmap selQv1 ys, ..., fmap selQvn ys) of
                                           Qv -&gt; D[ e | R ]

where  Qv is the tuple of variables bound by Q (and used subsequently)
       selQvi is a selector mapping Qv to the ith component of Qv

Operator     Standard binding       Expected type
--------------------------------------------------------------------
return       GHC.Base               t1 -&gt; m t2
(&gt;&gt;=)        GHC.Base               m1 t1 -&gt; (t2 -&gt; m2 t3) -&gt; m3 t3
(&gt;&gt;)         GHC.Base               m1 t1 -&gt; m2 t2         -&gt; m3 t3
guard        Control.Monad          t1 -&gt; m t2
fmap         GHC.Base               forall a b. (a-&gt;b) -&gt; n a -&gt; n b
mzip         Control.Monad.Zip      forall a b. m a -&gt; m b -&gt; m (a,b)
</pre></div>
</div>
<p>The comprehension should typecheck when its desugaring would typecheck,
except that (as discussed in <a class="reference internal" href="#generalised-list-comprehensions"><span>Generalised (SQL-like) List Comprehensions</span></a>) in the
&#8220;then <code class="docutils literal"><span class="pre">f</span></code>&#8221; and &#8220;then group using <code class="docutils literal"><span class="pre">f</span></code>&#8221; clauses, when the &#8220;by <code class="docutils literal"><span class="pre">b</span></code>&#8221; qualifier
is omitted, argument <code class="docutils literal"><span class="pre">f</span></code> should have a polymorphic type. In particular, &#8220;then
<code class="docutils literal"><span class="pre">Data.List.sort</span></code>&#8221; and &#8220;then group using <code class="docutils literal"><span class="pre">Data.List.group</span></code>&#8221; are
insufficiently polymorphic.</p>
<p>Monad comprehensions support rebindable syntax
(<a class="reference internal" href="#rebindable-syntax"><span>Rebindable syntax and the implicit Prelude import</span></a>). Without rebindable syntax, the operators
from the &#8220;standard binding&#8221; module are used; with rebindable syntax, the
operators are looked up in the current lexical scope. For example,
parallel comprehensions will be typechecked and desugared using whatever
&#8220;<code class="docutils literal"><span class="pre">mzip</span></code>&#8221; is in scope.</p>
<p>The rebindable operators must have the &#8220;Expected type&#8221; given in the
table above. These types are surprisingly general. For example, you can
use a bind operator with the type</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">x</span> <span class="n">y</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">y</span> <span class="n">z</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">x</span> <span class="n">z</span> <span class="n">b</span>
</pre></div>
</div>
<p>In the case of transform comprehensions, notice that the groups are
parameterised over some arbitrary type <code class="docutils literal"><span class="pre">n</span></code> (provided it has an
<code class="docutils literal"><span class="pre">fmap</span></code>, as well as the comprehension being over an arbitrary monad.</p>
</div>
<div class="section" id="new-monadic-failure-desugaring-mechanism">
<span id="monadfail-desugaring"></span><h2>10.3.14. New monadic failure desugaring mechanism<a class="headerlink" href="#new-monadic-failure-desugaring-mechanism" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XMonadFailDesugaring">
<code class="descname">-XMonadFailDesugaring</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XMonadFailDesugaring" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Use the <code class="docutils literal"><span class="pre">MonadFail.fail</span></code> instead of the legacy <code class="docutils literal"><span class="pre">Monad.fail</span></code> function
when desugaring refutable patterns in <code class="docutils literal"><span class="pre">do</span></code> blocks.</p>
</dd></dl>

<p>The <code class="docutils literal"><span class="pre">-XMonadFailDesugaring</span></code> extension switches the desugaring of
<code class="docutils literal"><span class="pre">do</span></code>-blocks to use <code class="docutils literal"><span class="pre">MonadFail.fail</span></code> instead of <code class="docutils literal"><span class="pre">Monad.fail</span></code>. This will
eventually be the default behaviour in a future GHC release, under the
<a class="reference external" href="https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail">MonadFail Proposal (MFP)</a>.</p>
<p>This extension is temporary, and will be deprecated in a future release. It is
included so that library authors have a hard check for whether their code
will work with future GHC versions.</p>
</div>
<div class="section" id="rebindable-syntax-and-the-implicit-prelude-import">
<span id="rebindable-syntax"></span><h2>10.3.15. Rebindable syntax and the implicit Prelude import<a class="headerlink" href="#rebindable-syntax-and-the-implicit-prelude-import" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XNoImplicitPrelude">
<code class="descname">-XNoImplicitPrelude</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XNoImplicitPrelude" title="Permalink to this definition">¶</a></dt>
<dd><p>Don&#8217;t import <code class="docutils literal"><span class="pre">Prelude</span></code> by default.</p>
</dd></dl>

<p>GHC normally imports <code class="docutils literal"><span class="pre">Prelude.hi</span></code> files for
you. If you&#8217;d rather it didn&#8217;t, then give it a <code class="docutils literal"><span class="pre">-XNoImplicitPrelude</span></code>
option. The idea is that you can then import a Prelude of your own. (But
don&#8217;t call it <code class="docutils literal"><span class="pre">Prelude</span></code>; the Haskell module namespace is flat, and you
must not conflict with any Prelude module.)</p>
<dl class="ghc-flag">
<dt id="ghc-flag--XRebindableSyntax">
<code class="descname">-XRebindableSyntax</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XRebindableSyntax" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XNoImplicitPrelude"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNoImplicitPrelude</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Since:</th><td class="field-body">7.0.1</td>
</tr>
</tbody>
</table>
<p>Enable rebinding of a variety of usually-built-in operations.</p>
</dd></dl>

<p>Suppose you are importing a Prelude of your own in order to define your
own numeric class hierarchy. It completely defeats that purpose if the
literal &#8220;1&#8221; means &#8220;<code class="docutils literal"><span class="pre">Prelude.fromInteger</span> <span class="pre">1</span></code>&#8221;, which is what the Haskell
Report specifies. So the <a class="reference internal" href="#ghc-flag--XRebindableSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRebindableSyntax</span></code></a> flag causes the
following pieces of built-in syntax to refer to <em>whatever is in scope</em>,
not the Prelude versions:</p>
<ul class="simple">
<li>An integer literal <code class="docutils literal"><span class="pre">368</span></code> means &#8220;<code class="docutils literal"><span class="pre">fromInteger</span> <span class="pre">(368::Integer)</span></code>&#8221;,
rather than &#8220;<code class="docutils literal"><span class="pre">Prelude.fromInteger</span> <span class="pre">(368::Integer)</span></code>&#8221;.</li>
<li>Fractional literals are handed in just the same way, except that the
translation is <code class="docutils literal"><span class="pre">fromRational</span> <span class="pre">(3.68::Rational)</span></code>.</li>
<li>The equality test in an overloaded numeric pattern uses whatever
<code class="docutils literal"><span class="pre">(==)</span></code> is in scope.</li>
<li>The subtraction operation, and the greater-than-or-equal test, in
<code class="docutils literal"><span class="pre">n+k</span></code> patterns use whatever <code class="docutils literal"><span class="pre">(-)</span></code> and <code class="docutils literal"><span class="pre">(&gt;=)</span></code> are in scope.</li>
<li>Negation (e.g. &#8220;<code class="docutils literal"><span class="pre">-</span> <span class="pre">(f</span> <span class="pre">x)</span></code>&#8221;) means &#8220;<code class="docutils literal"><span class="pre">negate</span> <span class="pre">(f</span> <span class="pre">x)</span></code>&#8221;, both in
numeric patterns, and expressions.</li>
<li>Conditionals (e.g. &#8220;<code class="docutils literal"><span class="pre">if</span></code> e1 <code class="docutils literal"><span class="pre">then</span></code> e2 <code class="docutils literal"><span class="pre">else</span></code> e3&#8221;) means
&#8220;<code class="docutils literal"><span class="pre">ifThenElse</span></code> e1 e2 e3&#8221;. However <code class="docutils literal"><span class="pre">case</span></code> expressions are
unaffected.</li>
<li>&#8220;Do&#8221; notation is translated using whatever functions <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code>,
<code class="docutils literal"><span class="pre">(&gt;&gt;)</span></code>, and <code class="docutils literal"><span class="pre">fail</span></code>, are in scope (not the Prelude versions). List
comprehensions, <code class="docutils literal"><span class="pre">mdo</span></code> (<a class="reference internal" href="#recursive-do-notation"><span>The recursive do-notation</span></a>), and parallel
array comprehensions, are unaffected.</li>
<li>Arrow notation (see <a class="reference internal" href="#arrow-notation"><span>Arrow notation</span></a>) uses whatever <code class="docutils literal"><span class="pre">arr</span></code>,
<code class="docutils literal"><span class="pre">(&gt;&gt;&gt;)</span></code>, <code class="docutils literal"><span class="pre">first</span></code>, <code class="docutils literal"><span class="pre">app</span></code>, <code class="docutils literal"><span class="pre">(|||)</span></code> and <code class="docutils literal"><span class="pre">loop</span></code> functions are
in scope. But unlike the other constructs, the types of these
functions must match the Prelude types very closely. Details are in
flux; if you want to use this, ask!</li>
<li>List notation, such as <code class="docutils literal"><span class="pre">[x,y]</span></code> or <code class="docutils literal"><span class="pre">[m..n]</span></code> can also be treated
via rebindable syntax if you use <cite>-XOverloadedLists</cite>;
see <a class="reference internal" href="#overloaded-lists"><span>Overloaded lists</span></a>.</li>
<li>An overloaded label &#8220;<code class="docutils literal"><span class="pre">#foo</span></code>&#8221; means &#8220;<code class="docutils literal"><span class="pre">fromLabel</span> <span class="pre">&#64;&quot;foo&quot;</span></code>&#8221;, rather than
&#8220;<code class="docutils literal"><span class="pre">GHC.OverloadedLabels.fromLabel</span> <span class="pre">&#64;&quot;foo&quot;</span></code>&#8221; (see <a class="reference internal" href="#overloaded-labels"><span>Overloaded labels</span></a>).</li>
</ul>
<p><a class="reference internal" href="#ghc-flag--XRebindableSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRebindableSyntax</span></code></a> implies <a class="reference internal" href="#ghc-flag--XNoImplicitPrelude"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNoImplicitPrelude</span></code></a>.</p>
<p>In all cases (apart from arrow notation), the static semantics should be
that of the desugared form, even if that is a little unexpected. For
example, the static semantics of the literal <code class="docutils literal"><span class="pre">368</span></code> is exactly that of
<code class="docutils literal"><span class="pre">fromInteger</span> <span class="pre">(368::Integer)</span></code>; it&#8217;s fine for <code class="docutils literal"><span class="pre">fromInteger</span></code> to have
any of the types:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">fromInteger</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">fromInteger</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">fromInteger</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">fromInteger</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Be warned: this is an experimental facility, with fewer checks than
usual. Use <code class="docutils literal"><span class="pre">-dcore-lint</span></code> to typecheck the desugared program. If Core
Lint is happy you should be all right.</p>
<div class="section" id="things-unaffected-by-xrebindablesyntax">
<h3>10.3.15.1. Things unaffected by <a class="reference internal" href="#ghc-flag--XRebindableSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRebindableSyntax</span></code></a><a class="headerlink" href="#things-unaffected-by-xrebindablesyntax" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#ghc-flag--XRebindableSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRebindableSyntax</span></code></a> does not apply to any code generated from a
<code class="docutils literal"><span class="pre">deriving</span></code> clause or declaration. To see why, consider the following code:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE RebindableSyntax, OverloadedStrings #-}</span>
<span class="kr">newtype</span> <span class="kt">Text</span> <span class="ow">=</span> <span class="kt">Text</span> <span class="kt">String</span>

<span class="nf">fromString</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Text</span>
<span class="nf">fromString</span> <span class="ow">=</span> <span class="kt">Text</span>

<span class="kr">data</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="kt">Foo</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>This will generate code to the effect of:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Foo</span> <span class="kr">where</span>
  <span class="n">showsPrec</span> <span class="kr">_</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="n">showString</span> <span class="s">&quot;Foo&quot;</span>
</pre></div>
</div>
<p>But because <a class="reference internal" href="#ghc-flag--XRebindableSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRebindableSyntax</span></code></a> and <a class="reference internal" href="#ghc-flag--XOverloadedStrings"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverloadedStrings</span></code></a>
are enabled, the <code class="docutils literal"><span class="pre">&quot;Foo&quot;</span></code> string literal would now be of type <code class="docutils literal"><span class="pre">Text</span></code>, not
<code class="docutils literal"><span class="pre">String</span></code>, which <code class="docutils literal"><span class="pre">showString</span></code> doesn&#8217;t accept! This causes the generated
<code class="docutils literal"><span class="pre">Show</span></code> instance to fail to typecheck. It&#8217;s hard to imagine any scenario where
it would be desirable have <a class="reference internal" href="#ghc-flag--XRebindableSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRebindableSyntax</span></code></a> behavior within
derived code, so GHC simply ignores <a class="reference internal" href="#ghc-flag--XRebindableSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRebindableSyntax</span></code></a> entirely
when checking derived code.</p>
</div>
</div>
<div class="section" id="postfix-operators">
<span id="id10"></span><h2>10.3.16. Postfix operators<a class="headerlink" href="#postfix-operators" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XPostfixOperators">
<code class="descname">-XPostfixOperators</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XPostfixOperators" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the use of post-fix operators</p>
</dd></dl>

<p>The <a class="reference internal" href="#ghc-flag--XPostfixOperators"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPostfixOperators</span></code></a> flag enables a small extension to the syntax
of left operator sections, which allows you to define postfix operators.
The extension is this: the left section</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="n">e</span> <span class="o">!</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent (from the point of view of both type checking and
execution) to the expression</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">((</span><span class="o">!</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>(for any expression <code class="docutils literal"><span class="pre">e</span></code> and operator <code class="docutils literal"><span class="pre">(!)</span></code>. The strict Haskell 98
interpretation is that the section is equivalent to</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="o">!</span><span class="p">)</span> <span class="n">e</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>That is, the operator must be a function of two arguments. GHC allows it
to take only one argument, and that in turn allows you to write the
function postfix.</p>
<p>The extension does not extend to the left-hand side of function
definitions; you must define such a function in prefix form.</p>
</div>
<div class="section" id="tuple-sections">
<span id="id11"></span><h2>10.3.17. Tuple sections<a class="headerlink" href="#tuple-sections" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XTupleSections">
<code class="descname">-XTupleSections</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XTupleSections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">6.12</td>
</tr>
</tbody>
</table>
<p>Allow the use of tuple section syntax</p>
</dd></dl>

<p>The <a class="reference internal" href="#ghc-flag--XTupleSections"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTupleSections</span></code></a> flag enables partially applied
tuple constructors. For example, the following program</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(,</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>is considered to be an alternative notation for the more unwieldy
alternative</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>You can omit any combination of arguments to the tuple, as in the
following</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(,</span> <span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="p">,</span> <span class="p">,</span> <span class="s">&quot;Love&quot;</span><span class="p">,</span> <span class="p">,</span> <span class="mi">1337</span><span class="p">)</span>
</pre></div>
</div>
<p>which translates to</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">\</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="s">&quot;Love&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mi">1337</span><span class="p">)</span>
</pre></div>
</div>
<p>If you have <a class="reference external" href="#unboxed-tuples">unboxed tuples</a> enabled, tuple sections
will also be available for them, like so</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">#</span> <span class="p">,</span> <span class="kt">True</span> <span class="o">#</span><span class="p">)</span>
</pre></div>
</div>
<p>Because there is no unboxed unit tuple, the following expression</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">#</span> <span class="o">#</span><span class="p">)</span>
</pre></div>
</div>
<p>continues to stand for the unboxed singleton tuple data constructor.</p>
</div>
<div class="section" id="lambda-case">
<span id="id12"></span><h2>10.3.18. Lambda-case<a class="headerlink" href="#lambda-case" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XLambdaCase">
<code class="descname">-XLambdaCase</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XLambdaCase" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.6.1</td>
</tr>
</tbody>
</table>
<p>Allow the use of lambda-case syntax.</p>
</dd></dl>

<p>The <a class="reference internal" href="#ghc-flag--XLambdaCase"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XLambdaCase</span></code></a> flag enables expressions of the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">\</span><span class="kr">case</span> <span class="p">{</span> <span class="n">p1</span> <span class="ow">-&gt;</span> <span class="n">e1</span><span class="p">;</span> <span class="o">...</span><span class="p">;</span> <span class="n">pN</span> <span class="ow">-&gt;</span> <span class="n">eN</span> <span class="p">}</span>
</pre></div>
</div>
<p>which is equivalent to</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">\</span><span class="n">freshName</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">freshName</span> <span class="kr">of</span> <span class="p">{</span> <span class="n">p1</span> <span class="ow">-&gt;</span> <span class="n">e1</span><span class="p">;</span> <span class="o">...</span><span class="p">;</span> <span class="n">pN</span> <span class="ow">-&gt;</span> <span class="n">eN</span> <span class="p">}</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">\case</span></code> starts a layout, so you can write</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">\</span><span class="kr">case</span>
  <span class="n">p1</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
  <span class="o">...</span>
  <span class="n">pN</span> <span class="ow">-&gt;</span> <span class="n">eN</span>
</pre></div>
</div>
</div>
<div class="section" id="empty-case-alternatives">
<span id="empty-case"></span><h2>10.3.19. Empty case alternatives<a class="headerlink" href="#empty-case-alternatives" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XEmptyCase">
<code class="descname">-XEmptyCase</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XEmptyCase" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.8.1</td>
</tr>
</tbody>
</table>
<p>Allow empty case expressions.</p>
</dd></dl>

<p>The <a class="reference internal" href="#ghc-flag--XEmptyCase"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XEmptyCase</span></code></a> flag enables case expressions, or lambda-case
expressions, that have no alternatives, thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">e</span> <span class="kr">of</span> <span class="p">{</span> <span class="p">}</span>   <span class="c1">-- No alternatives</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">\</span><span class="kr">case</span> <span class="p">{</span> <span class="p">}</span>       <span class="c1">-- -XLambdaCase is also required</span>
</pre></div>
</div>
<p>This can be useful when you know that the expression being scrutinised
has no non-bottom values. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Void</span>
<span class="nf">f</span> <span class="ow">::</span> <span class="kt">Void</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>With dependently-typed features it is more useful (see <a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/2431">Trac #2431</a>). For
example, consider these two candidate definitions of <code class="docutils literal"><span class="pre">absurd</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">a</span> <span class="kt">:==:</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kt">Refl</span> <span class="ow">::</span> <span class="n">a</span> <span class="kt">:==:</span> <span class="n">a</span>

<span class="nf">absurd</span> <span class="ow">::</span> <span class="kt">True</span> <span class="kt">:~:</span> <span class="kt">False</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">absurd</span> <span class="n">x</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;absurd&quot;</span>    <span class="c1">-- (A)</span>
<span class="nf">absurd</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="p">{}</span>      <span class="c1">-- (B)</span>
</pre></div>
</div>
<p>We much prefer (B). Why? Because GHC can figure out that
<code class="docutils literal"><span class="pre">(True</span> <span class="pre">:~:</span> <span class="pre">False)</span></code> is an empty type. So (B) has no partiality and GHC
should be able to compile with <a class="reference internal" href="using-warnings.html#ghc-flag--Wincomplete-patterns"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wincomplete-patterns</span></code></a>. (Though
the pattern match checking is not yet clever enough to do that.) On the
other hand (A) looks dangerous, and GHC doesn&#8217;t check to make sure that,
in fact, the function can never get called.</p>
</div>
<div class="section" id="multi-way-if-expressions">
<span id="multi-way-if"></span><h2>10.3.20. Multi-way if-expressions<a class="headerlink" href="#multi-way-if-expressions" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XMultiWayIf">
<code class="descname">-XMultiWayIf</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XMultiWayIf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.6.1</td>
</tr>
</tbody>
</table>
<p>Allow the use of multi-way-<code class="docutils literal"><span class="pre">if</span></code> syntax.</p>
</dd></dl>

<p>With <a class="reference internal" href="#ghc-flag--XMultiWayIf"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMultiWayIf</span></code></a> flag GHC accepts conditional expressions with
multiple branches:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">if</span> <span class="o">|</span> <span class="n">guard1</span> <span class="ow">-&gt;</span> <span class="n">expr1</span>
   <span class="o">|</span> <span class="o">...</span>
   <span class="o">|</span> <span class="n">guardN</span> <span class="ow">-&gt;</span> <span class="n">exprN</span>
</pre></div>
</div>
<p>which is roughly equivalent to</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="nb">()</span> <span class="kr">of</span>
  <span class="kr">_</span> <span class="o">|</span> <span class="n">guard1</span> <span class="ow">-&gt;</span> <span class="n">expr1</span>
  <span class="o">...</span>
  <span class="kr">_</span> <span class="o">|</span> <span class="n">guardN</span> <span class="ow">-&gt;</span> <span class="n">exprN</span>
</pre></div>
</div>
<p>Multi-way if expressions introduce a new layout context. So the example
above is equivalent to:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">if</span> <span class="p">{</span> <span class="o">|</span> <span class="n">guard1</span> <span class="ow">-&gt;</span> <span class="n">expr1</span>
   <span class="p">;</span> <span class="o">|</span> <span class="o">...</span>
   <span class="p">;</span> <span class="o">|</span> <span class="n">guardN</span> <span class="ow">-&gt;</span> <span class="n">exprN</span>
   <span class="p">}</span>
</pre></div>
</div>
<p>The following behaves as expected:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">if</span> <span class="o">|</span> <span class="n">guard1</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="o">|</span> <span class="n">guard2</span> <span class="ow">-&gt;</span> <span class="n">expr2</span>
                  <span class="o">|</span> <span class="n">guard3</span> <span class="ow">-&gt;</span> <span class="n">expr3</span>
   <span class="o">|</span> <span class="n">guard4</span> <span class="ow">-&gt;</span> <span class="n">expr4</span>
</pre></div>
</div>
<p>because layout translates it as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">if</span> <span class="p">{</span> <span class="o">|</span> <span class="n">guard1</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="p">{</span> <span class="o">|</span> <span class="n">guard2</span> <span class="ow">-&gt;</span> <span class="n">expr2</span>
                    <span class="p">;</span> <span class="o">|</span> <span class="n">guard3</span> <span class="ow">-&gt;</span> <span class="n">expr3</span>
                    <span class="p">}</span>
   <span class="p">;</span> <span class="o">|</span> <span class="n">guard4</span> <span class="ow">-&gt;</span> <span class="n">expr4</span>
   <span class="p">}</span>
</pre></div>
</div>
<p>Layout with multi-way if works in the same way as other layout contexts,
except that the semi-colons between guards in a multi-way if are
optional. So it is not necessary to line up all the guards at the same
column; this is consistent with the way guards work in function
definitions and case expressions.</p>
</div>
<div class="section" id="local-fixity-declarations">
<span id="id13"></span><h2>10.3.21. Local Fixity Declarations<a class="headerlink" href="#local-fixity-declarations" title="Permalink to this headline">¶</a></h2>
<p>A careful reading of the Haskell 98 Report reveals that fixity
declarations (<code class="docutils literal"><span class="pre">infix</span></code>, <code class="docutils literal"><span class="pre">infixl</span></code>, and <code class="docutils literal"><span class="pre">infixr</span></code>) are permitted to
appear inside local bindings such those introduced by <code class="docutils literal"><span class="pre">let</span></code> and
<code class="docutils literal"><span class="pre">where</span></code>. However, the Haskell Report does not specify the semantics of
such bindings very precisely.</p>
<p>In GHC, a fixity declaration may accompany a local binding:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">f</span> <span class="ow">=</span> <span class="o">...</span>
    <span class="kr">infixr</span> <span class="mi">3</span> <span class="p">`</span><span class="n">f</span><span class="p">`</span>
<span class="kr">in</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>and the fixity declaration applies wherever the binding is in scope. For
example, in a <code class="docutils literal"><span class="pre">let</span></code>, it applies in the right-hand sides of other
<code class="docutils literal"><span class="pre">let</span></code>-bindings and the body of the <code class="docutils literal"><span class="pre">let</span></code>C. Or, in recursive <code class="docutils literal"><span class="pre">do</span></code>
expressions (<a class="reference internal" href="#recursive-do-notation"><span>The recursive do-notation</span></a>), the local fixity
declarations of a <code class="docutils literal"><span class="pre">let</span></code> statement scope over other statements in the
group, just as the bound name does.</p>
<p>Moreover, a local fixity declaration <em>must</em> accompany a local binding
of that name: it is not possible to revise the fixity of name bound
elsewhere, as in</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="kr">infixr</span> <span class="mi">9</span> <span class="o">$</span> <span class="kr">in</span> <span class="o">...</span>
</pre></div>
</div>
<p>Because local fixity declarations are technically Haskell 98, no flag is
necessary to enable them.</p>
</div>
<div class="section" id="import-and-export-extensions">
<span id="package-imports"></span><h2>10.3.22. Import and export extensions<a class="headerlink" href="#import-and-export-extensions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="hiding-things-the-imported-module-doesn-t-export">
<h3>10.3.22.1. Hiding things the imported module doesn&#8217;t export<a class="headerlink" href="#hiding-things-the-imported-module-doesn-t-export" title="Permalink to this headline">¶</a></h3>
<p>Technically in Haskell 2010 this is illegal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">A</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="kr">where</span>
  <span class="n">f</span> <span class="ow">=</span> <span class="kt">True</span>

<span class="kr">module</span> <span class="nn">B</span> <span class="kr">where</span>
  <span class="kr">import</span> <span class="nn">A</span> <span class="n">hiding</span><span class="p">(</span> <span class="n">g</span> <span class="p">)</span>  <span class="c1">-- A does not export g</span>
  <span class="n">g</span> <span class="ow">=</span> <span class="n">f</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">import</span> <span class="pre">A</span> <span class="pre">hiding(</span> <span class="pre">g</span> <span class="pre">)</span></code> in module <code class="docutils literal"><span class="pre">B</span></code> is technically an error
(<a class="reference external" href="http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1">Haskell Report,
5.3.1</a>)
because <code class="docutils literal"><span class="pre">A</span></code> does not export <code class="docutils literal"><span class="pre">g</span></code>. However GHC allows it, in the
interests of supporting backward compatibility; for example, a newer
version of <code class="docutils literal"><span class="pre">A</span></code> might export <code class="docutils literal"><span class="pre">g</span></code>, and you want <code class="docutils literal"><span class="pre">B</span></code> to work in
either case.</p>
<p>The warning <a class="reference internal" href="using-warnings.html#ghc-flag--Wdodgy-imports"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wdodgy-imports</span></code></a>, which is off by default but included
with <a class="reference internal" href="using-warnings.html#ghc-flag--W"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-W</span></code></a>, warns if you hide something that the imported module does
not export.</p>
</div>
<div class="section" id="package-qualified-imports">
<span id="id14"></span><h3>10.3.22.2. Package-qualified imports<a class="headerlink" href="#package-qualified-imports" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XPackageImports">
<code class="descname">-XPackageImports</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XPackageImports" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the use of package-qualified <code class="docutils literal"><span class="pre">import</span></code> syntax.</p>
</dd></dl>

<p>With the <a class="reference internal" href="#ghc-flag--XPackageImports"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPackageImports</span></code></a> flag, GHC allows import declarations to be
qualified by the package name that the module is intended to be imported
from. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="s">&quot;network&quot;</span> <span class="nn">Network.Socket</span>
</pre></div>
</div>
<p>would import the module <code class="docutils literal"><span class="pre">Network.Socket</span></code> from the package <code class="docutils literal"><span class="pre">network</span></code>
(any version). This may be used to disambiguate an import when the same
module is available from multiple packages, or is present in both the
current package being built and an external package.</p>
<p>The special package name <code class="docutils literal"><span class="pre">this</span></code> can be used to refer to the current
package being built.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You probably don&#8217;t need to use this feature, it was added mainly so that we
can build backwards-compatible versions of packages when APIs change. It can
lead to fragile dependencies in the common case: modules occasionally move
from one package to another, rendering any package-qualified imports broken.
See also <a class="reference internal" href="packages.html#package-thinning-and-renaming"><span>Thinning and renaming modules</span></a> for an alternative way of
disambiguating between module names.</p>
</div>
</div>
<div class="section" id="safe-imports">
<span id="safe-imports-ext"></span><h3>10.3.22.3. Safe imports<a class="headerlink" href="#safe-imports" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt>
<code class="descname">-XSafe</code><code class="descclassname"></code></dt>
<dt>
<code class="descname">-XTrustworthy</code><code class="descclassname"></code></dt>
<dt>
<code class="descname">-XUnsafe</code><code class="descclassname"></code></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.2</td>
</tr>
</tbody>
</table>
<p>Declare the Safe Haskell state of the current module.</p>
</dd></dl>

<p>With the <a class="reference internal" href="safe_haskell.html#ghc-flag--XSafe"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XSafe</span></code></a>, <a class="reference internal" href="safe_haskell.html#ghc-flag--XTrustworthy"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTrustworthy</span></code></a> and <a class="reference internal" href="safe_haskell.html#ghc-flag--XUnsafe"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUnsafe</span></code></a>
language flags, GHC extends the import declaration syntax to take an optional
<code class="docutils literal"><span class="pre">safe</span></code> keyword after the <code class="docutils literal"><span class="pre">import</span></code> keyword. This feature is part of the Safe
Haskell GHC extension. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">safe</span> <span class="n">qualified</span> <span class="kt">Network</span><span class="o">.</span><span class="kt">Socket</span> <span class="n">as</span> <span class="kt">NS</span>
</pre></div>
</div>
<p>would import the module <code class="docutils literal"><span class="pre">Network.Socket</span></code> with compilation only
succeeding if <code class="docutils literal"><span class="pre">Network.Socket</span></code> can be safely imported. For a description of
when a import is considered safe see <a class="reference internal" href="safe_haskell.html#safe-haskell"><span>Safe Haskell</span></a>.</p>
</div>
<div class="section" id="explicit-namespaces-in-import-export">
<span id="explicit-namespaces"></span><h3>10.3.22.4. Explicit namespaces in import/export<a class="headerlink" href="#explicit-namespaces-in-import-export" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XExplicitNamespaces">
<code class="descname">-XExplicitNamespaces</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XExplicitNamespaces" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.6.1</td>
</tr>
</tbody>
</table>
<p>Enable use of explicit namespaces in module export lists.</p>
</dd></dl>

<p>In an import or export list, such as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">M</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
  <span class="kr">import</span> <span class="nn">N</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="p">)</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>the entities <code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">(++)</span></code> are <em>values</em>. However, with type
operators (<a class="reference internal" href="#type-operators"><span>Type operators</span></a>) it becomes possible to declare
<code class="docutils literal"><span class="pre">(++)</span></code> as a <em>type constructor</em>. In that case, how would you export or
import it?</p>
<p>The <a class="reference internal" href="#ghc-flag--XExplicitNamespaces"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitNamespaces</span></code></a> extension allows you to prefix the name of
a type constructor in an import or export list with &#8220;<code class="docutils literal"><span class="pre">type</span></code>&#8221; to
disambiguate this case, thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">M</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="kr">type</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
  <span class="kr">import</span> <span class="nn">N</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="kr">type</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="p">)</span>
  <span class="o">...</span>
<span class="kr">module</span> <span class="nn">N</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="kr">type</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="p">)</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="n">family</span> <span class="n">a</span> <span class="o">++</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">L</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">R</span> <span class="n">b</span>
</pre></div>
</div>
<p>The extension <a class="reference internal" href="#ghc-flag--XExplicitNamespaces"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitNamespaces</span></code></a> is implied by
<a class="reference internal" href="#ghc-flag--XTypeOperators"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeOperators</span></code></a> and (for some reason) by <a class="reference internal" href="#ghc-flag--XTypeFamilies"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeFamilies</span></code></a>.</p>
<p>In addition, with <a class="reference internal" href="#ghc-flag--XPatternSynonyms"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPatternSynonyms</span></code></a> you can prefix the name of a
data constructor in an import or export list with the keyword
<code class="docutils literal"><span class="pre">pattern</span></code>, to allow the import or export of a data constructor without
its parent type constructor (see <a class="reference internal" href="#patsyn-impexp"><span>Import and export of pattern synonyms</span></a>).</p>
</div>
</div>
<div class="section" id="summary-of-stolen-syntax">
<span id="syntax-stolen"></span><h2>10.3.23. Summary of stolen syntax<a class="headerlink" href="#summary-of-stolen-syntax" title="Permalink to this headline">¶</a></h2>
<p>Turning on an option that enables special syntax <em>might</em> cause working
Haskell 98 code to fail to compile, perhaps because it uses a variable
name which has become a reserved word. This section lists the syntax
that is &#8220;stolen&#8221; by language extensions. We use notation and nonterminal
names from the Haskell 98 lexical syntax (see the Haskell 98 Report). We
only list syntax changes here that might affect existing working
programs (i.e. &#8220;stolen&#8221; syntax). Many of these extensions will also
enable new context-free syntax, but in all cases programs written to use
the new syntax would not be compilable without the option enabled.</p>
<p>There are two classes of special syntax:</p>
<ul class="simple">
<li>New reserved words and symbols: character sequences which are no
longer available for use as identifiers in the program.</li>
<li>Other special syntax: sequences of characters that have a different
meaning when this particular option is turned on.</li>
</ul>
<p>The following syntax is stolen:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">forall</span></code></dt>
<dd><p class="first last" id="index-6">Stolen (in types) by: <a class="reference internal" href="#ghc-flag--XExplicitForAll"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitForAll</span></code></a>, and hence by
<a class="reference internal" href="#ghc-flag--XScopedTypeVariables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XScopedTypeVariables</span></code></a>, <a class="reference internal" href="#ghc-flag--XLiberalTypeSynonyms"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XLiberalTypeSynonyms</span></code></a>,
<a class="reference internal" href="#ghc-flag--XRankNTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRankNTypes</span></code></a>, <a class="reference internal" href="#ghc-flag--XExistentialQuantification"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExistentialQuantification</span></code></a></p>
</dd>
<dt><code class="docutils literal"><span class="pre">mdo</span></code></dt>
<dd><p class="first last" id="index-7">Stolen by: <a class="reference internal" href="#ghc-flag--XRecursiveDo"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRecursiveDo</span></code></a></p>
</dd>
<dt><code class="docutils literal"><span class="pre">foreign</span></code></dt>
<dd><p class="first last" id="index-8">Stolen by: <a class="reference internal" href="ffi-chap.html#ghc-flag--XForeignFunctionInterface"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XForeignFunctionInterface</span></code></a></p>
</dd>
<dt><code class="docutils literal"><span class="pre">rec</span></code>, <code class="docutils literal"><span class="pre">proc</span></code>, <code class="docutils literal"><span class="pre">-&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;-</span></code>, <code class="docutils literal"><span class="pre">-&lt;&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;-</span></code>, <code class="docutils literal"><span class="pre">(|</span></code>, <code class="docutils literal"><span class="pre">|)</span></code></dt>
<dd><p class="first last" id="index-9">Stolen by: <a class="reference internal" href="#ghc-flag--XArrows"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XArrows</span></code></a></p>
</dd>
<dt><code class="docutils literal"><span class="pre">?varid</span></code></dt>
<dd><p class="first last" id="index-10">Stolen by: <a class="reference internal" href="#ghc-flag--XImplicitParams"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XImplicitParams</span></code></a></p>
</dd>
<dt><code class="docutils literal"><span class="pre">[|</span></code>, <code class="docutils literal"><span class="pre">[e|</span></code>, <code class="docutils literal"><span class="pre">[p|</span></code>, <code class="docutils literal"><span class="pre">[d|</span></code>, <code class="docutils literal"><span class="pre">[t|</span></code>, <code class="docutils literal"><span class="pre">[||</span></code>, <code class="docutils literal"><span class="pre">[e||</span></code></dt>
<dd><p class="first last" id="index-11">Stolen by: <a class="reference internal" href="#ghc-flag--XQuasiQuotes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XQuasiQuotes</span></code></a>. Moreover, this introduces an ambiguity
with list comprehension syntax. See the
<a class="reference internal" href="#quasi-quotes-list-comprehension-ambiguity"><span>discussion on quasi-quoting</span></a>
for details.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">$(</span></code>, <code class="docutils literal"><span class="pre">$$(</span></code>, <code class="docutils literal"><span class="pre">$varid</span></code>, <code class="docutils literal"><span class="pre">$$varid</span></code></dt>
<dd><p class="first last" id="index-12">Stolen by: <a class="reference internal" href="#ghc-flag--XTemplateHaskell"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTemplateHaskell</span></code></a></p>
</dd>
<dt><code class="docutils literal"><span class="pre">[varid|</span></code></dt>
<dd><p class="first last" id="index-13">Stolen by: <a class="reference internal" href="#ghc-flag--XQuasiQuotes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XQuasiQuotes</span></code></a></p>
</dd>
<dt>⟨varid⟩, <code class="docutils literal"><span class="pre">#</span></code>⟨char⟩, <code class="docutils literal"><span class="pre">#</span></code>, ⟨string⟩, <code class="docutils literal"><span class="pre">#</span></code>, ⟨integer⟩, <code class="docutils literal"><span class="pre">#</span></code>, ⟨float⟩, <code class="docutils literal"><span class="pre">#</span></code>, ⟨float⟩, <code class="docutils literal"><span class="pre">##</span></code></dt>
<dd>Stolen by: <a class="reference internal" href="#ghc-flag--XMagicHash"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMagicHash</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">(#</span></code>, <code class="docutils literal"><span class="pre">#)</span></code></dt>
<dd>Stolen by: <a class="reference internal" href="#ghc-flag--XUnboxedTuples"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUnboxedTuples</span></code></a></dd>
<dt>⟨varid⟩, <code class="docutils literal"><span class="pre">!</span></code>, ⟨varid⟩</dt>
<dd>Stolen by: <a class="reference internal" href="#ghc-flag--XBangPatterns"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XBangPatterns</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">pattern</span></code></dt>
<dd>Stolen by: <a class="reference internal" href="#ghc-flag--XPatternSynonyms"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPatternSynonyms</span></code></a></dd>
</dl>
</div>
</div>
<div class="section" id="extensions-to-data-types-and-type-synonyms">
<span id="data-type-extensions"></span><h1>10.4. Extensions to data types and type synonyms<a class="headerlink" href="#extensions-to-data-types-and-type-synonyms" title="Permalink to this headline">¶</a></h1>
<div class="section" id="data-types-with-no-constructors">
<span id="nullary-types"></span><h2>10.4.1. Data types with no constructors<a class="headerlink" href="#data-types-with-no-constructors" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XEmptyDataDecls">
<code class="descname">-XEmptyDataDecls</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XEmptyDataDecls" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow definition of empty <code class="docutils literal"><span class="pre">data</span></code> types.</p>
</dd></dl>

<p>With the <a class="reference internal" href="#ghc-flag--XEmptyDataDecls"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XEmptyDataDecls</span></code></a> flag (or equivalent <code class="docutils literal"><span class="pre">LANGUAGE</span></code> pragma), GHC
lets you declare a data type with no constructors. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">S</span>      <span class="c1">-- S :: *</span>
<span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span>    <span class="c1">-- T :: * -&gt; *</span>
</pre></div>
</div>
<p>Syntactically, the declaration lacks the &#8220;= constrs&#8221; part. The type can
be parameterised over types of any kind, but if the kind is not <code class="docutils literal"><span class="pre">*</span></code>
then an explicit kind annotation must be used (see <a class="reference internal" href="#kinding"><span>Explicitly-kinded quantification</span></a>).</p>
<p>Such data types have only one value, namely bottom. Nevertheless, they
can be useful when defining &#8220;phantom types&#8221;.</p>
</div>
<div class="section" id="data-type-contexts">
<span id="datatype-contexts"></span><h2>10.4.2. Data type contexts<a class="headerlink" href="#data-type-contexts" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XDatatypeContexts">
<code class="descname">-XDatatypeContexts</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDatatypeContexts" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.0.1</td>
</tr>
</tbody>
</table>
<p>Allow contexts on <code class="docutils literal"><span class="pre">data</span></code> types.</p>
</dd></dl>

<p>Haskell allows datatypes to be given contexts, e.g.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Set</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">NilSet</span> <span class="o">|</span> <span class="kt">ConsSet</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>give constructors with types:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">NilSet</span> <span class="ow">::</span> <span class="kt">Set</span> <span class="n">a</span>
<span class="kt">ConsSet</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span>
</pre></div>
</div>
<p>This is widely considered a misfeature, and is going to be removed from
the language. In GHC, it is controlled by the deprecated extension
<code class="docutils literal"><span class="pre">DatatypeContexts</span></code>.</p>
</div>
<div class="section" id="infix-type-constructors-classes-and-type-variables">
<span id="infix-tycons"></span><h2>10.4.3. Infix type constructors, classes, and type variables<a class="headerlink" href="#infix-type-constructors-classes-and-type-variables" title="Permalink to this headline">¶</a></h2>
<p>GHC allows type constructors, classes, and type variables to be
operators, and to be written infix, very much like expressions. More
specifically:</p>
<ul>
<li><p class="first">A type constructor or class can be any non-reserved operator.
Symbols used in types are always like capitalized identifiers; they
are never variables. Note that this is different from the lexical
syntax of data constructors, which are required to begin with a
<code class="docutils literal"><span class="pre">:</span></code>.</p>
</li>
<li><p class="first">Data type and type-synonym declarations can be written infix,
parenthesised if you want further arguments. E.g.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">a</span> <span class="kt">:*:</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span>
<span class="kr">type</span> <span class="n">a</span> <span class="kt">:+:</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span>
<span class="kr">class</span> <span class="n">a</span> <span class="kt">:=:</span> <span class="n">b</span> <span class="kr">where</span> <span class="o">...</span>

<span class="kr">data</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:**:</span> <span class="n">b</span><span class="p">)</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Baz</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span>
<span class="kr">type</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:++:</span> <span class="n">b</span><span class="p">)</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Either</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="n">y</span>
</pre></div>
</div>
</li>
<li><p class="first">Types, and class constraints, can be written infix. For example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">x</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="kt">:*:</span> <span class="kt">Bool</span>
<span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:=:</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
</li>
<li><p class="first">Back-quotes work as for expressions, both for type constructors and
type variables; e.g. <code class="docutils literal"><span class="pre">Int</span> <span class="pre">`Either`</span> <span class="pre">Bool</span></code>, or <code class="docutils literal"><span class="pre">Int</span> <span class="pre">`a`</span> <span class="pre">Bool</span></code>.
Similarly, parentheses work the same; e.g. <code class="docutils literal"><span class="pre">(:*:)</span> <span class="pre">Int</span> <span class="pre">Bool</span></code>.</p>
</li>
<li><p class="first">Fixities may be declared for type constructors, or classes, just as
for data constructors. However, one cannot distinguish between the
two in a fixity declaration; a fixity declaration sets the fixity for
a data constructor and the corresponding type constructor. For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">infixl</span> <span class="mi">7</span> <span class="kt">T</span><span class="p">,</span> <span class="kt">:*:</span>
</pre></div>
</div>
<p>sets the fixity for both type constructor <code class="docutils literal"><span class="pre">T</span></code> and data constructor
<code class="docutils literal"><span class="pre">T</span></code>, and similarly for <code class="docutils literal"><span class="pre">:*:</span></code>. <code class="docutils literal"><span class="pre">Int</span> <span class="pre">`a`</span> <span class="pre">Bool</span></code>.</p>
</li>
<li><p class="first">Function arrow is <code class="docutils literal"><span class="pre">infixr</span></code> with fixity 0 (this might change; it&#8217;s
not clear what it should be).</p>
</li>
</ul>
</div>
<div class="section" id="type-operators">
<span id="id15"></span><h2>10.4.4. Type operators<a class="headerlink" href="#type-operators" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XTypeOperators">
<code class="descname">-XTypeOperators</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XTypeOperators" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XExplicitNamespaces"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitNamespaces</span></code></a></td>
</tr>
</tbody>
</table>
<p>Allow the use and definition of types with operator names.</p>
</dd></dl>

<p>In types, an operator symbol like <code class="docutils literal"><span class="pre">(+)</span></code> is normally treated as a type
<em>variable</em>, just like <code class="docutils literal"><span class="pre">a</span></code>. Thus in Haskell 98 you can say</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">T</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">=</span> <span class="p">((</span><span class="o">+</span><span class="p">),</span> <span class="p">(</span><span class="o">+</span><span class="p">))</span>
<span class="c1">-- Just like: type T a = (a,a)</span>

<span class="nf">f</span> <span class="ow">::</span> <span class="kt">T</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">f</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="ow">=</span> <span class="n">x</span>
</pre></div>
</div>
<p>As you can see, using operators in this way is not very useful, and
Haskell 98 does not even allow you to write them infix.</p>
<p>The language <a class="reference internal" href="#ghc-flag--XTypeOperators"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeOperators</span></code></a> changes this behaviour:</p>
<ul>
<li><p class="first">Operator symbols become type <em>constructors</em> rather than type
<em>variables</em>.</p>
</li>
<li><p class="first">Operator symbols in types can be written infix, both in definitions
and uses. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Plus</span> <span class="n">a</span> <span class="n">b</span>
<span class="kr">type</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="kt">Int</span> <span class="o">+</span> <span class="kt">Bool</span>
</pre></div>
</div>
</li>
<li><p class="first">There is now some potential ambiguity in import and export lists; for
example if you write <code class="docutils literal"><span class="pre">import</span> <span class="pre">M(</span> <span class="pre">(+)</span> <span class="pre">)</span></code> do you mean the <em>function</em>
<code class="docutils literal"><span class="pre">(+)</span></code> or the <em>type constructor</em> <code class="docutils literal"><span class="pre">(+)</span></code>? The default is the former,
but with <a class="reference internal" href="#ghc-flag--XExplicitNamespaces"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitNamespaces</span></code></a> (which is implied by
<a class="reference internal" href="#ghc-flag--XTypeOperators"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeOperators</span></code></a>) GHC allows you to specify the latter by
preceding it with the keyword <code class="docutils literal"><span class="pre">type</span></code>, thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">M</span><span class="p">(</span> <span class="kr">type</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#explicit-namespaces"><span>Explicit namespaces in import/export</span></a>.</p>
</li>
<li><p class="first">The fixity of a type operator may be set using the usual fixity
declarations but, as in <a class="reference internal" href="#infix-tycons"><span>Infix type constructors, classes, and type variables</span></a>, the function and type
constructor share a single fixity.</p>
</li>
</ul>
</div>
<div class="section" id="liberalised-type-synonyms">
<span id="type-synonyms"></span><h2>10.4.5. Liberalised type synonyms<a class="headerlink" href="#liberalised-type-synonyms" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XLiberalTypeSynonyms">
<code class="descname">-XLiberalTypeSynonyms</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XLiberalTypeSynonyms" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XExplicitForAll"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitForAll</span></code></a></td>
</tr>
</tbody>
</table>
<p>Relax many of the Haskell 98 rules on type synonym definitions.</p>
</dd></dl>

<p>Type synonyms are like macros at the type level, but Haskell 98 imposes
many rules on individual synonym declarations. With the
<a class="reference internal" href="#ghc-flag--XLiberalTypeSynonyms"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XLiberalTypeSynonyms</span></code></a> extension, GHC does validity checking on types
<em>only after expanding type synonyms</em>. That means that GHC can be very
much more liberal about type synonyms than Haskell 98.</p>
<ul>
<li><p class="first">You can write a <code class="docutils literal"><span class="pre">forall</span></code> (including overloading) in a type synonym,
thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Discard</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="kt">Show</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>

<span class="nf">f</span> <span class="ow">::</span> <span class="kt">Discard</span> <span class="n">a</span>
<span class="nf">f</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">show</span> <span class="n">y</span><span class="p">)</span>

<span class="nf">g</span> <span class="ow">::</span> <span class="kt">Discard</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">String</span><span class="p">)</span>    <span class="c1">-- A rank-2 type</span>
<span class="nf">g</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="mi">3</span> <span class="kt">True</span>
</pre></div>
</div>
</li>
<li><p class="first">If you also use <a class="reference internal" href="#ghc-flag--XUnboxedTuples"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUnboxedTuples</span></code></a>, you can write an unboxed tuple
in a type synonym:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Pr</span> <span class="ow">=</span> <span class="p">(</span><span class="o">#</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span> <span class="o">#</span><span class="p">)</span>

<span class="nf">h</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Pr</span>
<span class="nf">h</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="o">#</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">#</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">You can apply a type synonym to a forall type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>

<span class="nf">f</span> <span class="ow">::</span> <span class="kt">Foo</span> <span class="p">(</span><span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>After expanding the synonym, <code class="docutils literal"><span class="pre">f</span></code> has the legal (in GHC) type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
</li>
<li><p class="first">You can apply a type synonym to a partially applied type synonym:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Generic</span> <span class="n">i</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="n">i</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">o</span> <span class="n">x</span>
<span class="kr">type</span> <span class="kt">Id</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>

<span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Generic</span> <span class="kt">Id</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>After expanding the synonym, <code class="docutils literal"><span class="pre">foo</span></code> has the legal (in GHC) type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foo</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
<p>GHC currently does kind checking before expanding synonyms (though even
that could be changed).</p>
<p>After expanding type synonyms, GHC does validity checking on types,
looking for the following malformedness which isn&#8217;t detected simply by
kind checking:</p>
<ul class="simple">
<li>Type constructor applied to a type involving for-alls (if
<a class="reference internal" href="#ghc-flag--XImpredicativeTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XImpredicativeTypes</span></code></a> is off)</li>
<li>Partially-applied type synonym.</li>
</ul>
<p>So, for example, this will be rejected:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Pr</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span>

<span class="nf">h</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Pr</span><span class="p">]</span>
<span class="nf">h</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>because GHC does not allow type constructors applied to for-all types.</p>
</div>
<div class="section" id="existentially-quantified-data-constructors">
<span id="existential-quantification"></span><h2>10.4.6. Existentially quantified data constructors<a class="headerlink" href="#existentially-quantified-data-constructors" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XExistentialQuantification">
<code class="descname">-XExistentialQuantification</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XExistentialQuantification" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XExplicitForAll"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitForAll</span></code></a></td>
</tr>
</tbody>
</table>
<p>Allow existentially quantified type variables in types.</p>
</dd></dl>

<p>The idea of using existential quantification in data type declarations
was suggested by Perry, and implemented in Hope+ (Nigel Perry, <em>The
Implementation of Practical Functional Programming Languages</em>, PhD
Thesis, University of London, 1991). It was later formalised by Laufer
and Odersky (<em>Polymorphic type inference and abstract data types</em>,
TOPLAS, 16(5), pp. 1411-1430, 1994). It&#8217;s been in Lennart Augustsson&#8217;s
<code class="docutils literal"><span class="pre">hbc</span></code> Haskell compiler for several years, and proved very useful.
Here&#8217;s the idea. Consider the declaration:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">MkFoo</span> <span class="n">a</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
         <span class="o">|</span> <span class="kt">Nil</span>
</pre></div>
</div>
<p>The data type <code class="docutils literal"><span class="pre">Foo</span></code> has two constructors with types:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">MkFoo</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Foo</span>
<span class="kt">Nil</span>   <span class="ow">::</span> <span class="kt">Foo</span>
</pre></div>
</div>
<p>Notice that the type variable <code class="docutils literal"><span class="pre">a</span></code> in the type of <code class="docutils literal"><span class="pre">MkFoo</span></code> does not
appear in the data type itself, which is plain <code class="docutils literal"><span class="pre">Foo</span></code>. For example, the
following expression is fine:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="kt">MkFoo</span> <span class="mi">3</span> <span class="n">even</span><span class="p">,</span> <span class="kt">MkFoo</span> <span class="sc">&#39;c&#39;</span> <span class="n">isUpper</span><span class="p">]</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Foo</span><span class="p">]</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">(MkFoo</span> <span class="pre">3</span> <span class="pre">even)</span></code> packages an integer with a function <code class="docutils literal"><span class="pre">even</span></code>
that maps an integer to <code class="docutils literal"><span class="pre">Bool</span></code>; and <code class="docutils literal"><span class="pre">MkFoo</span> <span class="pre">'c'</span>
<span class="pre">isUpper</span></code> packages a character with a compatible function. These two
things are each of type <code class="docutils literal"><span class="pre">Foo</span></code> and can be put in a list.</p>
<p>What can we do with a value of type <code class="docutils literal"><span class="pre">Foo</span></code>? In particular, what
happens when we pattern-match on <code class="docutils literal"><span class="pre">MkFoo</span></code>?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="p">(</span><span class="kt">MkFoo</span> <span class="n">val</span> <span class="n">fn</span><span class="p">)</span> <span class="ow">=</span> <span class="o">???</span>
</pre></div>
</div>
<p>Since all we know about <code class="docutils literal"><span class="pre">val</span></code> and <code class="docutils literal"><span class="pre">fn</span></code> is that they are compatible,
the only (useful) thing we can do with them is to apply <code class="docutils literal"><span class="pre">fn</span></code> to
<code class="docutils literal"><span class="pre">val</span></code> to get a boolean. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">Foo</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">MkFoo</span> <span class="n">val</span> <span class="n">fn</span><span class="p">)</span> <span class="ow">=</span> <span class="n">fn</span> <span class="n">val</span>
</pre></div>
</div>
<p>What this allows us to do is to package heterogeneous values together
with a bunch of functions that manipulate them, and then treat that
collection of packages in a uniform manner. You can express quite a bit
of object-oriented-like programming this way.</p>
<div class="section" id="why-existential">
<span id="existential"></span><h3>10.4.6.1. Why existential?<a class="headerlink" href="#why-existential" title="Permalink to this headline">¶</a></h3>
<p>What has this to do with <em>existential</em> quantification? Simply that
<code class="docutils literal"><span class="pre">MkFoo</span></code> has the (nearly) isomorphic type</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">MkFoo</span> <span class="ow">::</span> <span class="p">(</span><span class="n">exists</span> <span class="n">a</span> <span class="o">.</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kt">Foo</span>
</pre></div>
</div>
<p>But Haskell programmers can safely think of the ordinary <em>universally</em>
quantified type given above, thereby avoiding adding a new existential
quantification construct.</p>
</div>
<div class="section" id="existentials-and-type-classes">
<span id="existential-with-context"></span><h3>10.4.6.2. Existentials and type classes<a class="headerlink" href="#existentials-and-type-classes" title="Permalink to this headline">¶</a></h3>
<p>An easy extension is to allow arbitrary contexts before the constructor.
For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Baz</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Baz1</span> <span class="n">a</span> <span class="n">a</span>
         <span class="o">|</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="kt">Show</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">Baz2</span> <span class="n">b</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The two constructors have the types you&#8217;d expect:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Baz1</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Baz</span>
<span class="kt">Baz2</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="kt">Show</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Baz</span>
</pre></div>
</div>
<p>But when pattern matching on <code class="docutils literal"><span class="pre">Baz1</span></code> the matched values can be compared
for equality, and when pattern matching on <code class="docutils literal"><span class="pre">Baz2</span></code> the first matched
value can be converted to a string (as well as applying the function to
it). So this program is legal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">Baz</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">Baz1</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="o">|</span> <span class="n">p</span> <span class="o">==</span> <span class="n">q</span>    <span class="ow">=</span> <span class="s">&quot;Yes&quot;</span>
             <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="s">&quot;No&quot;</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">Baz2</span> <span class="n">v</span> <span class="n">fn</span><span class="p">)</span>            <span class="ow">=</span> <span class="n">show</span> <span class="p">(</span><span class="n">fn</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>Operationally, in a dictionary-passing implementation, the constructors
<code class="docutils literal"><span class="pre">Baz1</span></code> and <code class="docutils literal"><span class="pre">Baz2</span></code> must store the dictionaries for <code class="docutils literal"><span class="pre">Eq</span></code> and
<code class="docutils literal"><span class="pre">Show</span></code> respectively, and extract it on pattern matching.</p>
</div>
<div class="section" id="record-constructors">
<span id="existential-records"></span><h3>10.4.6.3. Record Constructors<a class="headerlink" href="#record-constructors" title="Permalink to this headline">¶</a></h3>
<p>GHC allows existentials to be used with records syntax as well. For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Counter</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">self</span><span class="o">.</span> <span class="kt">NewCounter</span>
    <span class="p">{</span> <span class="n">_this</span>    <span class="ow">::</span> <span class="n">self</span>
    <span class="p">,</span> <span class="n">_inc</span>     <span class="ow">::</span> <span class="n">self</span> <span class="ow">-&gt;</span> <span class="n">self</span>
    <span class="p">,</span> <span class="n">_display</span> <span class="ow">::</span> <span class="n">self</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
    <span class="p">,</span> <span class="n">tag</span>      <span class="ow">::</span> <span class="n">a</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">tag</span></code> is a public field, with a well-typed selector function
<code class="docutils literal"><span class="pre">tag</span> <span class="pre">::</span> <span class="pre">Counter</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>. The <code class="docutils literal"><span class="pre">self</span></code> type is hidden from the outside;
any attempt to apply <code class="docutils literal"><span class="pre">_this</span></code>, <code class="docutils literal"><span class="pre">_inc</span></code> or <code class="docutils literal"><span class="pre">_display</span></code> as functions
will raise a compile-time error. In other words, <em>GHC defines a record
selector function only for fields whose type does not mention the
existentially-quantified variables</em>. (This example used an underscore in
the fields for which record selectors will not be defined, but that is
only programming style; GHC ignores them.)</p>
<p>To make use of these hidden fields, we need to create some helper
functions:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">inc</span> <span class="ow">::</span> <span class="kt">Counter</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Counter</span> <span class="n">a</span>
<span class="nf">inc</span> <span class="p">(</span><span class="kt">NewCounter</span> <span class="n">x</span> <span class="n">i</span> <span class="n">d</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">NewCounter</span>
    <span class="p">{</span> <span class="n">_this</span> <span class="ow">=</span> <span class="n">i</span> <span class="n">x</span><span class="p">,</span> <span class="n">_inc</span> <span class="ow">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">_display</span> <span class="ow">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">=</span> <span class="n">t</span> <span class="p">}</span>

<span class="nf">display</span> <span class="ow">::</span> <span class="kt">Counter</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">display</span> <span class="kt">NewCounter</span><span class="p">{</span> <span class="n">_this</span> <span class="ow">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">_display</span> <span class="ow">=</span> <span class="n">d</span> <span class="p">}</span> <span class="ow">=</span> <span class="n">d</span> <span class="n">x</span>
</pre></div>
</div>
<p>Now we can define counters with different underlying implementations:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">counterA</span> <span class="ow">::</span> <span class="kt">Counter</span> <span class="kt">String</span>
<span class="nf">counterA</span> <span class="ow">=</span> <span class="kt">NewCounter</span>
    <span class="p">{</span> <span class="n">_this</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_inc</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="p">),</span> <span class="n">_display</span> <span class="ow">=</span> <span class="n">print</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">=</span> <span class="s">&quot;A&quot;</span> <span class="p">}</span>

<span class="nf">counterB</span> <span class="ow">::</span> <span class="kt">Counter</span> <span class="kt">String</span>
<span class="nf">counterB</span> <span class="ow">=</span> <span class="kt">NewCounter</span>
    <span class="p">{</span> <span class="n">_this</span> <span class="ow">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">_inc</span> <span class="ow">=</span> <span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="kt">:</span><span class="p">),</span> <span class="n">_display</span> <span class="ow">=</span> <span class="n">putStrLn</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">=</span> <span class="s">&quot;B&quot;</span> <span class="p">}</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">display</span> <span class="p">(</span><span class="n">inc</span> <span class="n">counterA</span><span class="p">)</span>         <span class="c1">-- prints &quot;1&quot;</span>
    <span class="n">display</span> <span class="p">(</span><span class="n">inc</span> <span class="p">(</span><span class="n">inc</span> <span class="n">counterB</span><span class="p">))</span>   <span class="c1">-- prints &quot;##&quot;</span>
</pre></div>
</div>
<p>Record update syntax is supported for existentials (and GADTs):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">setTag</span> <span class="ow">::</span> <span class="kt">Counter</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Counter</span> <span class="n">a</span>
<span class="nf">setTag</span> <span class="n">obj</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">obj</span><span class="p">{</span> <span class="n">tag</span> <span class="ow">=</span> <span class="n">t</span> <span class="p">}</span>
</pre></div>
</div>
<p>The rule for record update is this:</p>
<blockquote>
<div>the types of the updated fields may mention only the universally-quantified
type variables of the data constructor. For GADTs, the field may mention
only types that appear as a simple type-variable argument in the
constructor&#8217;s result type.</div></blockquote>
<p>For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span> <span class="p">{</span> <span class="kt">T1</span> <span class="p">{</span> <span class="n">f1</span><span class="ow">::</span><span class="n">a</span><span class="p">,</span> <span class="n">f2</span><span class="ow">::</span><span class="n">b</span><span class="p">,</span> <span class="n">f3</span><span class="ow">::</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="p">}</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">a</span> <span class="n">b</span> <span class="p">}</span> <span class="c1">-- c is existential</span>
<span class="nf">upd1</span> <span class="n">t</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">t</span> <span class="p">{</span> <span class="n">f1</span><span class="ow">=</span><span class="n">x</span> <span class="p">}</span>   <span class="c1">-- OK:   upd1 :: T a b -&gt; a&#39; -&gt; T a&#39; b</span>
<span class="nf">upd2</span> <span class="n">t</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">t</span> <span class="p">{</span> <span class="n">f3</span><span class="ow">=</span><span class="n">x</span> <span class="p">}</span>   <span class="c1">-- BAD   (f3&#39;s type mentions c, which is</span>
                        <span class="c1">--        existentially quantified)</span>

<span class="kr">data</span> <span class="kt">G</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span> <span class="p">{</span> <span class="kt">G1</span> <span class="p">{</span> <span class="n">g1</span><span class="ow">::</span><span class="n">a</span><span class="p">,</span> <span class="n">g2</span><span class="ow">::</span><span class="n">c</span> <span class="p">}</span> <span class="ow">::</span> <span class="kt">G</span> <span class="n">a</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="p">}</span>
<span class="nf">upd3</span> <span class="n">g</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">g</span> <span class="p">{</span> <span class="n">g1</span><span class="ow">=</span><span class="n">x</span> <span class="p">}</span>   <span class="c1">-- OK:   upd3 :: G a b -&gt; c -&gt; G c b</span>
<span class="nf">upd4</span> <span class="n">g</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">g</span> <span class="p">{</span> <span class="n">g2</span><span class="ow">=</span><span class="n">x</span> <span class="p">}</span>   <span class="c1">-- BAD (f2&#39;s type mentions c, which is not a simple</span>
                        <span class="c1">--      type-variable argument in G1&#39;s result type)</span>
</pre></div>
</div>
</div>
<div class="section" id="restrictions">
<h3>10.4.6.4. Restrictions<a class="headerlink" href="#restrictions" title="Permalink to this headline">¶</a></h3>
<p>There are several restrictions on the ways in which existentially-quantified
constructors can be used.</p>
<ul>
<li><p class="first">When pattern matching, each pattern match introduces a new, distinct,
type for each existential type variable. These types cannot be
unified with any other type, nor can they escape from the scope of
the pattern match. For example, these fragments are incorrect:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f1</span> <span class="p">(</span><span class="kt">MkFoo</span> <span class="n">a</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>
</pre></div>
</div>
<p>Here, the type bound by <code class="docutils literal"><span class="pre">MkFoo</span></code> &#8220;escapes&#8221;, because <code class="docutils literal"><span class="pre">a</span></code> is the
result of <code class="docutils literal"><span class="pre">f1</span></code>. One way to see why this is wrong is to ask what
type <code class="docutils literal"><span class="pre">f1</span></code> has:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f1</span> <span class="ow">::</span> <span class="kt">Foo</span> <span class="ow">-&gt;</span> <span class="n">a</span>             <span class="c1">-- Weird!</span>
</pre></div>
</div>
<p>What is this &#8220;<code class="docutils literal"><span class="pre">a</span></code>&#8221; in the result type? Clearly we don&#8217;t mean this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f1</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Foo</span> <span class="ow">-&gt;</span> <span class="n">a</span>   <span class="c1">-- Wrong!</span>
</pre></div>
</div>
<p>The original program is just plain wrong. Here&#8217;s another sort of
error</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f2</span> <span class="p">(</span><span class="kt">Baz1</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="kt">Baz1</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span><span class="o">==</span><span class="n">q</span>
</pre></div>
</div>
<p>It&#8217;s ok to say <code class="docutils literal"><span class="pre">a==b</span></code> or <code class="docutils literal"><span class="pre">p==q</span></code>, but <code class="docutils literal"><span class="pre">a==q</span></code> is wrong because it
equates the two distinct types arising from the two <code class="docutils literal"><span class="pre">Baz1</span></code>
constructors.</p>
</li>
<li><p class="first">You can&#8217;t pattern-match on an existentially quantified constructor in
a <code class="docutils literal"><span class="pre">let</span></code> or <code class="docutils literal"><span class="pre">where</span></code> group of bindings. So this is illegal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f3</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">a</span><span class="o">==</span><span class="n">b</span> <span class="kr">where</span> <span class="p">{</span> <span class="kt">Baz1</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">}</span>
</pre></div>
</div>
<p>Instead, use a <code class="docutils literal"><span class="pre">case</span></code> expression:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f3</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="kt">Baz1</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="o">==</span><span class="n">b</span>
</pre></div>
</div>
<p>In general, you can only pattern-match on an existentially-quantified
constructor in a <code class="docutils literal"><span class="pre">case</span></code> expression or in the patterns of a function
definition. The reason for this restriction is really an
implementation one. Type-checking binding groups is already a
nightmare without existentials complicating the picture. Also an
existential pattern binding at the top level of a module doesn&#8217;t make
sense, because it&#8217;s not clear how to prevent the
existentially-quantified type &#8220;escaping&#8221;. So for now, there&#8217;s a
simple-to-state restriction. We&#8217;ll see how annoying it is.</p>
</li>
<li><p class="first">You can&#8217;t use existential quantification for <code class="docutils literal"><span class="pre">newtype</span></code>
declarations. So this is illegal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">T</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">MkT</span> <span class="n">a</span>
</pre></div>
</div>
<p>Reason: a value of type <code class="docutils literal"><span class="pre">T</span></code> must be represented as a pair of a
dictionary for <code class="docutils literal"><span class="pre">Ord</span> <span class="pre">t</span></code> and a value of type <code class="docutils literal"><span class="pre">t</span></code>. That contradicts
the idea that <code class="docutils literal"><span class="pre">newtype</span></code> should have no concrete representation. You
can get just the same efficiency and effect by using <code class="docutils literal"><span class="pre">data</span></code> instead
of <code class="docutils literal"><span class="pre">newtype</span></code>. If there is no overloading involved, then there is
more of a case for allowing an existentially-quantified <code class="docutils literal"><span class="pre">newtype</span></code>,
because the <code class="docutils literal"><span class="pre">data</span></code> version does carry an implementation cost, but
single-field existentially quantified constructors aren&#8217;t much use.
So the simple restriction (no existential stuff on <code class="docutils literal"><span class="pre">newtype</span></code>)
stands, unless there are convincing reasons to change it.</p>
</li>
<li><p class="first">You can&#8217;t use <code class="docutils literal"><span class="pre">deriving</span></code> to define instances of a data type with
existentially quantified data constructors. Reason: in most cases it
would not make sense. For example:;</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">MkT</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">deriving</span><span class="p">(</span> <span class="kt">Eq</span> <span class="p">)</span>
</pre></div>
</div>
<p>To derive <code class="docutils literal"><span class="pre">Eq</span></code> in the standard way we would need to have equality
between the single component of two <code class="docutils literal"><span class="pre">MkT</span></code> constructors:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">T</span> <span class="kr">where</span>
  <span class="p">(</span><span class="kt">MkT</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">MkT</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="o">???</span>
</pre></div>
</div>
<p>But <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> have distinct types, and so can&#8217;t be compared.
It&#8217;s just about possible to imagine examples in which the derived
instance would make sense, but it seems altogether simpler simply to
prohibit such declarations. Define your own instances!</p>
</li>
</ul>
</div>
</div>
<div class="section" id="declaring-data-types-with-explicit-constructor-signatures">
<span id="gadt-style"></span><h2>10.4.7. Declaring data types with explicit constructor signatures<a class="headerlink" href="#declaring-data-types-with-explicit-constructor-signatures" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XGADTSyntax">
<code class="descname">-XGADTSyntax</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XGADTSyntax" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.2</td>
</tr>
</tbody>
</table>
<p>Allow the use of GADT syntax in data type definitions (but not GADTs
themselves; for this see <a class="reference internal" href="#ghc-flag--XGADTs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGADTs</span></code></a>)</p>
</dd></dl>

<p>When the <code class="docutils literal"><span class="pre">GADTSyntax</span></code> extension is enabled, GHC allows you to declare
an algebraic data type by giving the type signatures of constructors
explicitly. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="kt">Nothing</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span>
    <span class="kt">Just</span>    <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div>
</div>
<p>The form is called a &#8220;GADT-style declaration&#8221; because Generalised
Algebraic Data Types, described in <a class="reference internal" href="#gadt"><span>Generalised Algebraic Data Types (GADTs)</span></a>, can only be declared
using this form.</p>
<p>Notice that GADT-style syntax generalises existential types
(<a class="reference internal" href="#existential-quantification"><span>Existentially quantified data constructors</span></a>). For example, these two declarations
are equivalent:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">MkFoo</span> <span class="n">a</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Foo&#39;</span> <span class="kr">where</span> <span class="p">{</span> <span class="kt">MKFoo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Foo&#39;</span> <span class="p">}</span>
</pre></div>
</div>
<p>Any data type that can be declared in standard Haskell 98 syntax can
also be declared using GADT-style syntax. The choice is largely
stylistic, but GADT-style declarations differ in one important respect:
they treat class constraints on the data constructors differently.
Specifically, if the constructor is given a type-class context, that
context is made available by pattern matching. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Set</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">MkSet</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span>

<span class="nf">makeSet</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span>
<span class="nf">makeSet</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">MkSet</span> <span class="p">(</span><span class="n">nub</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">insert</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span>
<span class="nf">insert</span> <span class="n">a</span> <span class="p">(</span><span class="kt">MkSet</span> <span class="n">as</span><span class="p">)</span> <span class="o">|</span> <span class="n">a</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">as</span> <span class="ow">=</span> <span class="kt">MkSet</span> <span class="n">as</span>
                    <span class="o">|</span> <span class="n">otherwise</span>   <span class="ow">=</span> <span class="kt">MkSet</span> <span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">as</span><span class="p">)</span>
</pre></div>
</div>
<p>A use of <code class="docutils literal"><span class="pre">MkSet</span></code> as a constructor (e.g. in the definition of
<code class="docutils literal"><span class="pre">makeSet</span></code>) gives rise to a <code class="docutils literal"><span class="pre">(Eq</span> <span class="pre">a)</span></code> constraint, as you would expect.
The new feature is that pattern-matching on <code class="docutils literal"><span class="pre">MkSet</span></code> (as in the
definition of <code class="docutils literal"><span class="pre">insert</span></code>) makes <em>available</em> an <code class="docutils literal"><span class="pre">(Eq</span> <span class="pre">a)</span></code> context. In
implementation terms, the <code class="docutils literal"><span class="pre">MkSet</span></code> constructor has a hidden field that
stores the <code class="docutils literal"><span class="pre">(Eq</span> <span class="pre">a)</span></code> dictionary that is passed to <code class="docutils literal"><span class="pre">MkSet</span></code>; so when
pattern-matching that dictionary becomes available for the right-hand
side of the match. In the example, the equality dictionary is used to
satisfy the equality constraint generated by the call to <code class="docutils literal"><span class="pre">elem</span></code>, so
that the type of <code class="docutils literal"><span class="pre">insert</span></code> itself has no <code class="docutils literal"><span class="pre">Eq</span></code> constraint.</p>
<p>For example, one possible application is to reify dictionaries:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">NumInst</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">MkNumInst</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">NumInst</span> <span class="n">a</span>

<span class="nf">intInst</span> <span class="ow">::</span> <span class="kt">NumInst</span> <span class="kt">Int</span>
<span class="nf">intInst</span> <span class="ow">=</span> <span class="kt">MkNumInst</span>

<span class="nf">plus</span> <span class="ow">::</span> <span class="kt">NumInst</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">plus</span> <span class="kt">MkNumInst</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span>
</pre></div>
</div>
<p>Here, a value of type <code class="docutils literal"><span class="pre">NumInst</span> <span class="pre">a</span></code> is equivalent to an explicit
<code class="docutils literal"><span class="pre">(Num</span> <span class="pre">a)</span></code> dictionary.</p>
<p>All this applies to constructors declared using the syntax of
<a class="reference internal" href="#existential-with-context"><span>Existentials and type classes</span></a>. For example, the <code class="docutils literal"><span class="pre">NumInst</span></code> data type
above could equivalently be declared like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">NumInst</span> <span class="n">a</span>
   <span class="ow">=</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">MkNumInst</span> <span class="p">(</span><span class="kt">NumInst</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that, unlike the situation when declaring an existential, there
is no <code class="docutils literal"><span class="pre">forall</span></code>, because the <code class="docutils literal"><span class="pre">Num</span></code> constrains the data type&#8217;s
universally quantified type variable <code class="docutils literal"><span class="pre">a</span></code>. A constructor may have both
universal and existential type variables: for example, the following two
declarations are equivalent:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T1</span> <span class="n">a</span>
 <span class="ow">=</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MkT1</span> <span class="n">a</span> <span class="n">b</span>
<span class="kr">data</span> <span class="kt">T2</span> <span class="n">a</span> <span class="kr">where</span>
 <span class="kt">MkT2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">T2</span> <span class="n">a</span>
</pre></div>
</div>
<p>All this behaviour contrasts with Haskell 98&#8217;s peculiar treatment of
contexts on a data type declaration (Section 4.2.1 of the Haskell 98
Report). In Haskell 98 the definition</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Set&#39;</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkSet&#39;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>gives <code class="docutils literal"><span class="pre">MkSet'</span></code> the same type as <code class="docutils literal"><span class="pre">MkSet</span></code> above. But instead of
<em>making available</em> an <code class="docutils literal"><span class="pre">(Eq</span> <span class="pre">a)</span></code> constraint, pattern-matching on
<code class="docutils literal"><span class="pre">MkSet'</span></code> <em>requires</em> an <code class="docutils literal"><span class="pre">(Eq</span> <span class="pre">a)</span></code> constraint! GHC faithfully
implements this behaviour, odd though it is. But for GADT-style
declarations, GHC&#8217;s behaviour is much more useful, as well as much more
intuitive.</p>
<p>The rest of this section gives further details about GADT-style data
type declarations.</p>
<ul>
<li><p class="first">The result type of each data constructor must begin with the type
constructor being defined. If the result type of all constructors has
the form <code class="docutils literal"><span class="pre">T</span> <span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an</span></code>, where <code class="docutils literal"><span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an</span></code> are distinct type
variables, then the data type is <em>ordinary</em>; otherwise is a
<em>generalised</em> data type (<a class="reference internal" href="#gadt"><span>Generalised Algebraic Data Types (GADTs)</span></a>).</p>
</li>
<li><p class="first">As with other type signatures, you can give a single signature for
several data constructors. In this example we give a single signature
for <code class="docutils literal"><span class="pre">T1</span></code> and <code class="docutils literal"><span class="pre">T2</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">T1</span><span class="p">,</span><span class="kt">T2</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">a</span>
  <span class="kt">T3</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">a</span>
</pre></div>
</div>
</li>
<li><p class="first">The type signature of each constructor is independent, and is
implicitly universally quantified as usual. In particular, the type
variable(s) in the &#8220;<code class="docutils literal"><span class="pre">data</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">where</span></code>&#8221; header have no scope, and
different constructors may have different universally-quantified type
variables:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="kr">where</span>        <span class="c1">-- The &#39;a&#39; has no scope</span>
  <span class="kt">T1</span><span class="p">,</span><span class="kt">T2</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">b</span>   <span class="c1">-- Means forall b. b -&gt; T b</span>
  <span class="kt">T3</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">a</span>           <span class="c1">-- Means forall a. T a</span>
</pre></div>
</div>
</li>
<li><p class="first">A constructor signature may mention type class constraints, which can
differ for different constructors. For example, this is fine:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">T1</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">b</span>
  <span class="kt">T2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Ix</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">c</span>
</pre></div>
</div>
<p>When pattern matching, these constraints are made available to
discharge constraints in the body of the match. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">T1</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span><span class="o">==</span><span class="n">y</span>      <span class="ow">=</span> <span class="s">&quot;yes&quot;</span>
           <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="s">&quot;no&quot;</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">T2</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>             <span class="ow">=</span> <span class="n">show</span> <span class="n">a</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">f</span></code> is not overloaded; the <code class="docutils literal"><span class="pre">Eq</span></code> constraint arising from
the use of <code class="docutils literal"><span class="pre">==</span></code> is discharged by the pattern match on <code class="docutils literal"><span class="pre">T1</span></code> and
similarly the <code class="docutils literal"><span class="pre">Show</span></code> constraint arising from the use of <code class="docutils literal"><span class="pre">show</span></code>.</p>
</li>
<li><p class="first">Unlike a Haskell-98-style data type declaration, the type variable(s)
in the &#8220;<code class="docutils literal"><span class="pre">data</span> <span class="pre">Set</span> <span class="pre">a</span> <span class="pre">where</span></code>&#8221; header have no scope. Indeed, one can
write a kind signature instead:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Set</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>or even a mixture of the two:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Bar</span> <span class="n">a</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>The type variables (if given) may be explicitly kinded, so we could
also write the header for <code class="docutils literal"><span class="pre">Foo</span></code> like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Bar</span> <span class="n">a</span> <span class="p">(</span><span class="n">b</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first">You can use strictness annotations, in the obvious places in the
constructor type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Term</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="kt">Lit</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">Int</span>
    <span class="kt">If</span>     <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="o">!</span><span class="p">(</span><span class="kt">Term</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="o">!</span><span class="p">(</span><span class="kt">Term</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">a</span>
    <span class="kt">Pair</span>   <span class="ow">::</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">You can use a <code class="docutils literal"><span class="pre">deriving</span></code> clause on a GADT-style data type
declaration. For example, these two declarations are equivalent</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Maybe1</span> <span class="n">a</span> <span class="kr">where</span> <span class="p">{</span>
    <span class="kt">Nothing1</span> <span class="ow">::</span> <span class="kt">Maybe1</span> <span class="n">a</span> <span class="p">;</span>
    <span class="kt">Just1</span>    <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe1</span> <span class="n">a</span>
  <span class="p">}</span> <span class="kr">deriving</span><span class="p">(</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span> <span class="p">)</span>

<span class="kr">data</span> <span class="kt">Maybe2</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing2</span> <span class="o">|</span> <span class="kt">Just2</span> <span class="n">a</span>
     <span class="kr">deriving</span><span class="p">(</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span> <span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">The type signature may have quantified type variables that do not
appear in the result type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Foo</span> <span class="kr">where</span>
   <span class="kt">MkFoo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Foo</span>
   <span class="kt">Nil</span>   <span class="ow">::</span> <span class="kt">Foo</span>
</pre></div>
</div>
<p>Here the type variable <code class="docutils literal"><span class="pre">a</span></code> does not appear in the result type of
either constructor. Although it is universally quantified in the type
of the constructor, such a type variable is often called
&#8220;existential&#8221;. Indeed, the above declaration declares precisely the
same type as the <code class="docutils literal"><span class="pre">data</span> <span class="pre">Foo</span></code> in <a class="reference internal" href="#existential-quantification"><span>Existentially quantified data constructors</span></a>.</p>
<p>The type may contain a class context too, of course:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Showable</span> <span class="kr">where</span>
  <span class="kt">MkShowable</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Showable</span>
</pre></div>
</div>
</li>
<li><p class="first">You can use record syntax on a GADT-style data type declaration:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Person</span> <span class="kr">where</span>
    <span class="kt">Adult</span> <span class="ow">::</span> <span class="p">{</span> <span class="n">name</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">children</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Person</span><span class="p">]</span> <span class="p">}</span> <span class="ow">-&gt;</span> <span class="kt">Person</span>
    <span class="kt">Child</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">{</span> <span class="n">name</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">String</span><span class="p">,</span> <span class="n">funny</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">}</span> <span class="ow">-&gt;</span> <span class="kt">Person</span>
</pre></div>
</div>
<p>As usual, for every constructor that has a field <code class="docutils literal"><span class="pre">f</span></code>, the type of
field <code class="docutils literal"><span class="pre">f</span></code> must be the same (modulo alpha conversion). The <code class="docutils literal"><span class="pre">Child</span></code>
constructor above shows that the signature may have a context,
existentially-quantified variables, and strictness annotations, just
as in the non-record case. (NB: the &#8220;type&#8221; that follows the
double-colon is not really a type, because of the record syntax and
strictness annotations. A &#8220;type&#8221; of this form can appear only in a
constructor signature.)</p>
</li>
<li><p class="first">Record updates are allowed with GADT-style declarations, only fields
that have the following property: the type of the field mentions no
existential type variables.</p>
</li>
<li><p class="first">As in the case of existentials declared using the Haskell-98-like
record syntax (<a class="reference internal" href="#existential-records"><span>Record Constructors</span></a>), record-selector functions
are generated only for those fields that have well-typed selectors.
Here is the example of that section, in GADT-style syntax:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Counter</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="kt">NewCounter</span> <span class="ow">::</span> <span class="p">{</span> <span class="n">_this</span>    <span class="ow">::</span> <span class="n">self</span>
                  <span class="p">,</span> <span class="n">_inc</span>     <span class="ow">::</span> <span class="n">self</span> <span class="ow">-&gt;</span> <span class="n">self</span>
                  <span class="p">,</span> <span class="n">_display</span> <span class="ow">::</span> <span class="n">self</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
                  <span class="p">,</span> <span class="n">tag</span>      <span class="ow">::</span> <span class="n">a</span>
                  <span class="p">}</span> <span class="ow">-&gt;</span> <span class="kt">Counter</span> <span class="n">a</span>
</pre></div>
</div>
<p>As before, only one selector function is generated here, that for
<code class="docutils literal"><span class="pre">tag</span></code>. Nevertheless, you can still use all the field names in
pattern matching and record construction.</p>
</li>
<li><p class="first">In a GADT-style data type declaration there is no obvious way to
specify that a data constructor should be infix, which makes a
difference if you derive <code class="docutils literal"><span class="pre">Show</span></code> for the type. (Data constructors
declared infix are displayed infix by the derived <code class="docutils literal"><span class="pre">show</span></code>.) So GHC
implements the following design: a data constructor declared in a
GADT-style data type declaration is displayed infix by <code class="docutils literal"><span class="pre">Show</span></code> iff
(a) it is an operator symbol, (b) it has two arguments, (c) it has a
programmer-supplied fixity declaration. For example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">infix</span> <span class="mi">6</span> <span class="p">(</span><span class="kt">:--:</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="p">(</span><span class="kt">:--:</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="kt">Int</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="generalised-algebraic-data-types-gadts">
<span id="gadt"></span><h2>10.4.8. Generalised Algebraic Data Types (GADTs)<a class="headerlink" href="#generalised-algebraic-data-types-gadts" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XGADTs">
<code class="descname">-XGADTs</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XGADTs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XMonoLocalBinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonoLocalBinds</span></code></a>, <a class="reference internal" href="#ghc-flag--XGADTSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGADTSyntax</span></code></a></td>
</tr>
</tbody>
</table>
<p>Allow use of Generalised Algebraic Data Types (GADTs).</p>
</dd></dl>

<p>Generalised Algebraic Data Types generalise ordinary algebraic data
types by allowing constructors to have richer return types. Here is an
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Term</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="kt">Lit</span>    <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">Int</span>
    <span class="kt">Succ</span>   <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">Int</span>
    <span class="kt">IsZero</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">Bool</span>
    <span class="kt">If</span>     <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">a</span>
    <span class="kt">Pair</span>   <span class="ow">::</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that the return type of the constructors is not always
<code class="docutils literal"><span class="pre">Term</span> <span class="pre">a</span></code>, as is the case with ordinary data types. This generality
allows us to write a well-typed <code class="docutils literal"><span class="pre">eval</span></code> function for these <code class="docutils literal"><span class="pre">Terms</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">i</span><span class="p">)</span>      <span class="ow">=</span> <span class="n">i</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">t</span><span class="p">)</span>     <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">eval</span> <span class="n">t</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">IsZero</span> <span class="n">t</span><span class="p">)</span>   <span class="ow">=</span> <span class="n">eval</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">If</span> <span class="n">b</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">eval</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">eval</span> <span class="n">e1</span> <span class="kr">else</span> <span class="n">eval</span> <span class="n">e2</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">Pair</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">eval</span> <span class="n">e1</span><span class="p">,</span> <span class="n">eval</span> <span class="n">e2</span><span class="p">)</span>
</pre></div>
</div>
<p>The key point about GADTs is that <em>pattern matching causes type
refinement</em>. For example, in the right hand side of the equation</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">i</span><span class="p">)</span> <span class="ow">=</span>  <span class="o">...</span>
</pre></div>
</div>
<p>the type <code class="docutils literal"><span class="pre">a</span></code> is refined to <code class="docutils literal"><span class="pre">Int</span></code>. That&#8217;s the whole point! A precise
specification of the type rules is beyond what this user manual aspires
to, but the design closely follows that described in the paper <a class="reference external" href="http://research.microsoft.com/%7Esimonpj/papers/gadt/">Simple
unification-based type inference for
GADTs</a>, (ICFP
2006). The general principle is this: <em>type refinement is only carried
out based on user-supplied type annotations</em>. So if no type signature is
supplied for <code class="docutils literal"><span class="pre">eval</span></code>, no type refinement happens, and lots of obscure
error messages will occur. However, the refinement is quite general. For
example, if we had:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">i</span><span class="p">)</span> <span class="n">j</span> <span class="ow">=</span>  <span class="n">i</span><span class="o">+</span><span class="n">j</span>
</pre></div>
</div>
<p>the pattern match causes the type <code class="docutils literal"><span class="pre">a</span></code> to be refined to <code class="docutils literal"><span class="pre">Int</span></code>
(because of the type of the constructor <code class="docutils literal"><span class="pre">Lit</span></code>), and that refinement
also applies to the type of <code class="docutils literal"><span class="pre">j</span></code>, and the result type of the <code class="docutils literal"><span class="pre">case</span></code>
expression. Hence the addition <code class="docutils literal"><span class="pre">i+j</span></code> is legal.</p>
<p>These and many other examples are given in papers by Hongwei Xi, and Tim
Sheard. There is a longer introduction <a class="reference external" href="http://www.haskell.org/haskellwiki/GADT">on the
wiki</a>, and Ralf Hinze&#8217;s <a class="reference external" href="http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf">Fun
with phantom
types</a> also
has a number of examples. Note that papers may use different notation to
that implemented in GHC.</p>
<p>The rest of this section outlines the extensions to GHC that support
GADTs. The extension is enabled with <a class="reference internal" href="#ghc-flag--XGADTs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGADTs</span></code></a>. The <a class="reference internal" href="#ghc-flag--XGADTs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGADTs</span></code></a> flag
also sets <a class="reference internal" href="#ghc-flag--XGADTSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGADTSyntax</span></code></a> and <a class="reference internal" href="#ghc-flag--XMonoLocalBinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonoLocalBinds</span></code></a>.</p>
<ul>
<li><p class="first">A GADT can only be declared using GADT-style syntax
(<a class="reference internal" href="#gadt-style"><span>Declaring data types with explicit constructor signatures</span></a>); the old Haskell 98 syntax for data declarations
always declares an ordinary data type. The result type of each
constructor must begin with the type constructor being defined, but
for a GADT the arguments to the type constructor can be arbitrary
monotypes. For example, in the <code class="docutils literal"><span class="pre">Term</span></code> data type above, the type of
each constructor must end with <code class="docutils literal"><span class="pre">Term</span> <span class="pre">ty</span></code>, but the <code class="docutils literal"><span class="pre">ty</span></code> need not
be a type variable (e.g. the <code class="docutils literal"><span class="pre">Lit</span></code> constructor).</p>
</li>
<li><p class="first">It is permitted to declare an ordinary algebraic data type using
GADT-style syntax. What makes a GADT into a GADT is not the syntax,
but rather the presence of data constructors whose result type is not
just <code class="docutils literal"><span class="pre">T</span> <span class="pre">a</span> <span class="pre">b</span></code>.</p>
</li>
<li><p class="first">You cannot use a <code class="docutils literal"><span class="pre">deriving</span></code> clause for a GADT; only for an ordinary
data type.</p>
</li>
<li><p class="first">As mentioned in <a class="reference internal" href="#gadt-style"><span>Declaring data types with explicit constructor signatures</span></a>, record syntax is supported. For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Term</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="kt">Lit</span>    <span class="ow">::</span> <span class="p">{</span> <span class="n">val</span>  <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>      <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">Int</span>
    <span class="kt">Succ</span>   <span class="ow">::</span> <span class="p">{</span> <span class="n">num</span>  <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">Int</span> <span class="p">}</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">Int</span>
    <span class="kt">Pred</span>   <span class="ow">::</span> <span class="p">{</span> <span class="n">num</span>  <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">Int</span> <span class="p">}</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">Int</span>
    <span class="kt">IsZero</span> <span class="ow">::</span> <span class="p">{</span> <span class="n">arg</span>  <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">Int</span> <span class="p">}</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">Bool</span>
    <span class="kt">Pair</span>   <span class="ow">::</span> <span class="p">{</span> <span class="n">arg1</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="n">a</span>
              <span class="p">,</span> <span class="n">arg2</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="n">b</span>
              <span class="p">}</span>                    <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="kt">If</span>     <span class="ow">::</span> <span class="p">{</span> <span class="n">cnd</span>  <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">Bool</span>
              <span class="p">,</span> <span class="n">tru</span>  <span class="ow">::</span> <span class="kt">Term</span> <span class="n">a</span>
              <span class="p">,</span> <span class="n">fls</span>  <span class="ow">::</span> <span class="kt">Term</span> <span class="n">a</span>
              <span class="p">}</span>                    <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">a</span>
</pre></div>
</div>
<p>However, for GADTs there is the following additional constraint:
every constructor that has a field <code class="docutils literal"><span class="pre">f</span></code> must have the same result
type (modulo alpha conversion) Hence, in the above example, we cannot
merge the <code class="docutils literal"><span class="pre">num</span></code> and <code class="docutils literal"><span class="pre">arg</span></code> fields above into a single name.
Although their field types are both <code class="docutils literal"><span class="pre">Term</span> <span class="pre">Int</span></code>, their selector
functions actually have different types:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">num</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">Int</span>
<span class="nf">arg</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="kt">Int</span>
</pre></div>
</div>
</li>
<li><p class="first">When pattern-matching against data constructors drawn from a GADT,
for example in a <code class="docutils literal"><span class="pre">case</span></code> expression, the following rules apply:</p>
<ul class="simple">
<li>The type of the scrutinee must be rigid.</li>
<li>The type of the entire <code class="docutils literal"><span class="pre">case</span></code> expression must be rigid.</li>
<li>The type of any free variable mentioned in any of the <code class="docutils literal"><span class="pre">case</span></code>
alternatives must be rigid.</li>
</ul>
<p>A type is &#8220;rigid&#8221; if it is completely known to the compiler at its
binding site. The easiest way to ensure that a variable a rigid type
is to give it a type signature. For more precise details see <a class="reference external" href="http://research.microsoft.com/%7Esimonpj/papers/gadt/">Simple
unification-based type inference for
GADTs</a>. The
criteria implemented by GHC are given in the Appendix.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="extensions-to-the-record-system">
<span id="record-system-extensions"></span><h1>10.5. Extensions to the record system<a class="headerlink" href="#extensions-to-the-record-system" title="Permalink to this headline">¶</a></h1>
<div class="section" id="traditional-record-syntax">
<span id="id16"></span><h2>10.5.1. Traditional record syntax<a class="headerlink" href="#traditional-record-syntax" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XNoTraditionalRecordSyntax">
<code class="descname">-XNoTraditionalRecordSyntax</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XNoTraditionalRecordSyntax" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.4.1</td>
</tr>
</tbody>
</table>
<p>Disallow use of record syntax.</p>
</dd></dl>

<p>Traditional record syntax, such as <code class="docutils literal"><span class="pre">C</span> <span class="pre">{f</span> <span class="pre">=</span> <span class="pre">x}</span></code>, is enabled by default.
To disable it, you can use the <a class="reference internal" href="#ghc-flag--XNoTraditionalRecordSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNoTraditionalRecordSyntax</span></code></a> flag.</p>
</div>
<div class="section" id="record-field-disambiguation">
<span id="disambiguate-fields"></span><h2>10.5.2. Record field disambiguation<a class="headerlink" href="#record-field-disambiguation" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XDisambiguateRecordFields">
<code class="descname">-XDisambiguateRecordFields</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDisambiguateRecordFields" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the compiler to automatically choose between identically-named
record selectors based on type (if the choice is unambiguous).</p>
</dd></dl>

<p>In record construction and record pattern matching it is entirely
unambiguous which field is referred to, even if there are two different
data types in scope with a common field name. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">M</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">S</span> <span class="ow">=</span> <span class="kt">MkS</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">y</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>

<span class="kr">module</span> <span class="nn">Foo</span> <span class="kr">where</span>
  <span class="kr">import</span> <span class="nn">M</span>

  <span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>

  <span class="n">ok1</span> <span class="p">(</span><span class="kt">MkS</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">n</span> <span class="p">})</span> <span class="ow">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span>   <span class="c1">-- Unambiguous</span>
  <span class="n">ok2</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="p">}</span>     <span class="c1">-- Unambiguous</span>

  <span class="n">bad1</span> <span class="n">k</span> <span class="ow">=</span> <span class="n">k</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">3</span> <span class="p">}</span>        <span class="c1">-- Ambiguous</span>
  <span class="n">bad2</span> <span class="n">k</span> <span class="ow">=</span> <span class="n">x</span> <span class="n">k</span>                <span class="c1">-- Ambiguous</span>
</pre></div>
</div>
<p>Even though there are two <code class="docutils literal"><span class="pre">x</span></code>&#8216;s in scope, it is clear that the <code class="docutils literal"><span class="pre">x</span></code>
in the pattern in the definition of <code class="docutils literal"><span class="pre">ok1</span></code> can only mean the field
<code class="docutils literal"><span class="pre">x</span></code> from type <code class="docutils literal"><span class="pre">S</span></code>. Similarly for the function <code class="docutils literal"><span class="pre">ok2</span></code>. However, in
the record update in <code class="docutils literal"><span class="pre">bad1</span></code> and the record selection in <code class="docutils literal"><span class="pre">bad2</span></code> it is
not clear which of the two types is intended.</p>
<p>Haskell 98 regards all four as ambiguous, but with the
<a class="reference internal" href="#ghc-flag--XDisambiguateRecordFields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDisambiguateRecordFields</span></code></a> flag, GHC will accept the former two. The
rules are precisely the same as those for instance declarations in
Haskell 98, where the method names on the left-hand side of the method
bindings in an instance declaration refer unambiguously to the method of
that class (provided they are in scope at all), even if there are other
variables in scope with the same name. This reduces the clutter of
qualified names when you import two records from different modules that
use the same field name.</p>
<p>Some details:</p>
<ul>
<li><p class="first">Field disambiguation can be combined with punning (see
<a class="reference internal" href="#record-puns"><span>Record puns</span></a>). For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Foo</span> <span class="kr">where</span>
  <span class="kr">import</span> <span class="nn">M</span>
  <span class="n">x</span><span class="ow">=</span><span class="kt">True</span>
  <span class="n">ok3</span> <span class="p">(</span><span class="kt">MkS</span> <span class="p">{</span> <span class="n">x</span> <span class="p">})</span> <span class="ow">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>   <span class="c1">-- Uses both disambiguation and punning</span>
</pre></div>
</div>
</li>
<li><p class="first">With <a class="reference internal" href="#ghc-flag--XDisambiguateRecordFields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDisambiguateRecordFields</span></code></a> you can use <em>unqualified</em> field
names even if the corresponding selector is only in scope <em>qualified</em>
For example, assuming the same module <code class="docutils literal"><span class="pre">M</span></code> as in our earlier
example, this is legal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Foo</span> <span class="kr">where</span>
  <span class="kr">import</span> <span class="k">qualified</span> <span class="nn">M</span>    <span class="c1">-- Note qualified</span>

  <span class="n">ok4</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="kt">MkS</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">n</span> <span class="p">})</span> <span class="ow">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span>   <span class="c1">-- Unambiguous</span>
</pre></div>
</div>
<p>Since the constructor <code class="docutils literal"><span class="pre">MkS</span></code> is only in scope qualified, you must
name it <code class="docutils literal"><span class="pre">M.MkS</span></code>, but the field <code class="docutils literal"><span class="pre">x</span></code> does not need to be qualified
even though <code class="docutils literal"><span class="pre">M.x</span></code> is in scope but <code class="docutils literal"><span class="pre">x</span></code> is not (In effect, it is
qualified by the constructor).</p>
</li>
</ul>
</div>
<div class="section" id="duplicate-record-fields">
<span id="id17"></span><h2>10.5.3. Duplicate record fields<a class="headerlink" href="#duplicate-record-fields" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XDuplicateRecordFields">
<code class="descname">-XDuplicateRecordFields</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDuplicateRecordFields" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XDisambiguateRecordFields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDisambiguateRecordFields</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Allow definition of record types with identically-named fields.</p>
</dd></dl>

<p>Going beyond <a class="reference internal" href="#ghc-flag--XDisambiguateRecordFields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDisambiguateRecordFields</span></code></a> (see <a class="reference internal" href="#disambiguate-fields"><span>Record field disambiguation</span></a>),
the <a class="reference internal" href="#ghc-flag--XDuplicateRecordFields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDuplicateRecordFields</span></code></a> extension allows multiple datatypes to be
declared using the same field names in a single module. For example, it allows
this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">M</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">S</span> <span class="ow">=</span> <span class="kt">MkS</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>
  <span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
</pre></div>
</div>
<p>Uses of fields that are always unambiguous because they mention the constructor,
including construction and pattern-matching, may freely use duplicated field
names. For example, the following are permitted (just as with
<a class="reference internal" href="#ghc-flag--XDisambiguateRecordFields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDisambiguateRecordFields</span></code></a>):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">s</span> <span class="ow">=</span> <span class="kt">MkS</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">3</span> <span class="p">}</span>

<span class="nf">f</span> <span class="p">(</span><span class="kt">MkT</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">b</span> <span class="p">})</span> <span class="ow">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>Field names used as selector functions or in record updates must be unambiguous,
either because there is only one such field in scope, or because a type
signature is supplied, as described in the following sections.</p>
<div class="section" id="selector-functions">
<h3>10.5.3.1. Selector functions<a class="headerlink" href="#selector-functions" title="Permalink to this headline">¶</a></h3>
<p>Fields may be used as selector functions only if they are unambiguous, so this
is still not allowed if both <code class="docutils literal"><span class="pre">S(x)</span></code> and <code class="docutils literal"><span class="pre">T(x)</span></code> are in scope:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bad</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">x</span> <span class="n">r</span>
</pre></div>
</div>
<p>An ambiguous selector may be disambiguated by the type being &#8220;pushed down&#8221; to
the occurrence of the selector (see <a class="reference internal" href="#higher-rank-type-inference"><span>Type inference</span></a> for more
details on what &#8220;pushed down&#8221; means). For example, the following are permitted:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ok1</span> <span class="ow">=</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">S</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>

<span class="nf">ok2</span> <span class="ow">::</span> <span class="kt">S</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">ok2</span> <span class="ow">=</span> <span class="n">x</span>

<span class="nf">ok3</span> <span class="ow">=</span> <span class="n">k</span> <span class="n">x</span> <span class="c1">-- assuming we already have k :: (S -&gt; Int) -&gt; _</span>
</pre></div>
</div>
<p>In addition, the datatype that is meant may be given as a type signature on the
argument to the selector:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ok4</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">(</span><span class="n">s</span> <span class="ow">::</span> <span class="kt">S</span><span class="p">)</span>
</pre></div>
</div>
<p>However, we do not infer the type of the argument to determine the datatype, or
have any way of deferring the choice to the constraint solver. Thus the
following is ambiguous:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bad</span> <span class="ow">::</span> <span class="kt">S</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">bad</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">x</span> <span class="n">s</span>
</pre></div>
</div>
<p>Even though a field label is duplicated in its defining module, it may be
possible to use the selector unambiguously elsewhere. For example, another
module could import <code class="docutils literal"><span class="pre">S(x)</span></code> but not <code class="docutils literal"><span class="pre">T(x)</span></code>, and then use <code class="docutils literal"><span class="pre">x</span></code> unambiguously.</p>
</div>
<div class="section" id="record-updates">
<h3>10.5.3.2. Record updates<a class="headerlink" href="#record-updates" title="Permalink to this headline">¶</a></h3>
<p>In a record update such as <code class="docutils literal"><span class="pre">e</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">}</span></code>, if there are multiple <code class="docutils literal"><span class="pre">x</span></code> fields
in scope, then the type of the context must fix which record datatype is
intended, or a type annotation must be supplied. Consider the following
definitions:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">S</span> <span class="ow">=</span> <span class="kt">MkS</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>
<span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">bar</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>
<span class="kr">data</span> <span class="kt">U</span> <span class="ow">=</span> <span class="kt">MkU</span> <span class="p">{</span> <span class="n">bar</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">baz</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>
</pre></div>
</div>
<p>Without <a class="reference internal" href="#ghc-flag--XDuplicateRecordFields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDuplicateRecordFields</span></code></a>, an update mentioning <code class="docutils literal"><span class="pre">foo</span></code> will always be
ambiguous if all these definitions were in scope. When the extension is enabled,
there are several options for disambiguating updates:</p>
<ul>
<li><p class="first">Check for types that have all the fields being updated. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">bar</span> <span class="ow">=</span> <span class="mi">2</span> <span class="p">}</span>
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">f</span></code> must be updating <code class="docutils literal"><span class="pre">T</span></code> because neither <code class="docutils literal"><span class="pre">S</span></code> nor <code class="docutils literal"><span class="pre">U</span></code> have both
fields.</p>
</li>
<li><p class="first">Use the type being pushed in to the record update, as in the following:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">g1</span> <span class="ow">::</span> <span class="kt">T</span> <span class="ow">-&gt;</span> <span class="kt">T</span>
<span class="nf">g1</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">=</span> <span class="mi">3</span> <span class="p">}</span>

<span class="nf">g2</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">=</span> <span class="mi">3</span> <span class="p">}</span> <span class="ow">::</span> <span class="kt">T</span>

<span class="nf">g3</span> <span class="ow">=</span> <span class="n">k</span> <span class="p">(</span><span class="n">x</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">=</span> <span class="mi">3</span> <span class="p">})</span> <span class="c1">-- assuming we already have k :: T -&gt; _</span>
</pre></div>
</div>
</li>
<li><p class="first">Use an explicit type signature on the record expression, as in:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">h</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">=</span> <span class="mi">3</span> <span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>The type of the expression being updated will not be inferred, and no
constraint-solving will be performed, so the following will be rejected as
ambiguous:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">T</span>
    <span class="n">x</span> <span class="ow">=</span> <span class="n">blah</span>
<span class="kr">in</span> <span class="n">x</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">=</span> <span class="mi">3</span> <span class="p">}</span>

<span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">=</span> <span class="mi">3</span> <span class="p">},</span>  <span class="n">blah</span> <span class="ow">::</span> <span class="kt">T</span> <span class="p">]</span>

<span class="nf">\</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="kt">T</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">=</span> <span class="mi">3</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="import-and-export-of-record-fields">
<h3>10.5.3.3. Import and export of record fields<a class="headerlink" href="#import-and-export-of-record-fields" title="Permalink to this headline">¶</a></h3>
<p>When <a class="reference internal" href="#ghc-flag--XDuplicateRecordFields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDuplicateRecordFields</span></code></a> is enabled, an ambiguous field must be exported
as part of its datatype, rather than at the top level. For example, the
following is legal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">M</span> <span class="p">(</span><span class="kt">S</span><span class="p">(</span><span class="nf">x</span><span class="p">),</span> <span class="kt">T</span><span class="p">(</span><span class="o">..</span><span class="p">))</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">S</span> <span class="ow">=</span> <span class="kt">MkS</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>
  <span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
</pre></div>
</div>
<p>However, this would not be permitted, because <code class="docutils literal"><span class="pre">x</span></code> is ambiguous:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">M</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>Similar restrictions apply on import.</p>
</div>
</div>
<div class="section" id="record-puns">
<span id="id18"></span><h2>10.5.4. Record puns<a class="headerlink" href="#record-puns" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XNamedFieldPuns">
<code class="descname">-XNamedFieldPuns</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XNamedFieldPuns" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow use of record puns.</p>
</dd></dl>

<p>Record puns are enabled by the flag <a class="reference internal" href="#ghc-flag--XNamedFieldPuns"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNamedFieldPuns</span></code></a>.</p>
<p>When using records, it is common to write a pattern that binds a
variable with the same name as a record field, such as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">C</span> <span class="ow">=</span> <span class="kt">C</span> <span class="p">{</span><span class="n">a</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">}</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">C</span> <span class="p">{</span><span class="n">a</span> <span class="ow">=</span> <span class="n">a</span><span class="p">})</span> <span class="ow">=</span> <span class="n">a</span>
</pre></div>
</div>
<p>Record punning permits the variable name to be elided, so one can simply
write</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="p">(</span><span class="kt">C</span> <span class="p">{</span><span class="n">a</span><span class="p">})</span> <span class="ow">=</span> <span class="n">a</span>
</pre></div>
</div>
<p>to mean the same pattern as above. That is, in a record pattern, the
pattern <code class="docutils literal"><span class="pre">a</span></code> expands into the pattern <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span></code> for the same name
<code class="docutils literal"><span class="pre">a</span></code>.</p>
<p>Note that:</p>
<ul>
<li><p class="first">Record punning can also be used in an expression, writing, for
example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kr">in</span> <span class="kt">C</span> <span class="p">{</span><span class="n">a</span><span class="p">}</span>
</pre></div>
</div>
<p>instead of</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kr">in</span> <span class="kt">C</span> <span class="p">{</span><span class="n">a</span> <span class="ow">=</span> <span class="n">a</span><span class="p">}</span>
</pre></div>
</div>
<p>The expansion is purely syntactic, so the expanded right-hand side
expression refers to the nearest enclosing variable that is spelled
the same as the field name.</p>
</li>
<li><p class="first">Puns and other patterns can be mixed in the same record:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">C</span> <span class="ow">=</span> <span class="kt">C</span> <span class="p">{</span><span class="n">a</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">b</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">}</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">C</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">4</span><span class="p">})</span> <span class="ow">=</span> <span class="n">a</span>
</pre></div>
</div>
</li>
<li><p class="first">Puns can be used wherever record patterns occur (e.g. in <code class="docutils literal"><span class="pre">let</span></code>
bindings or at the top-level).</p>
</li>
<li><p class="first">A pun on a qualified field name is expanded by stripping off the
module qualifier. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="p">(</span><span class="kt">C</span> <span class="p">{</span><span class="kt">M</span><span class="o">.</span><span class="n">a</span><span class="p">})</span> <span class="ow">=</span> <span class="n">a</span>
</pre></div>
</div>
<p>means</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="kt">C</span> <span class="p">{</span><span class="kt">M</span><span class="o">.</span><span class="n">a</span> <span class="ow">=</span> <span class="n">a</span><span class="p">})</span> <span class="ow">=</span> <span class="n">a</span>
</pre></div>
</div>
<p>(This is useful if the field selector <code class="docutils literal"><span class="pre">a</span></code> for constructor <code class="docutils literal"><span class="pre">M.C</span></code>
is only in scope in qualified form.)</p>
</li>
</ul>
</div>
<div class="section" id="record-wildcards">
<span id="id19"></span><h2>10.5.5. Record wildcards<a class="headerlink" href="#record-wildcards" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XRecordWildCards">
<code class="descname">-XRecordWildCards</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XRecordWildCards" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XDisambiguateRecordFields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDisambiguateRecordFields</span></code></a>.</td>
</tr>
</tbody>
</table>
<p>Allow the use of wildcards in record construction and pattern matching.</p>
</dd></dl>

<p>Record wildcards are enabled by the flag <a class="reference internal" href="#ghc-flag--XRecordWildCards"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRecordWildCards</span></code></a>. This
flag implies <a class="reference internal" href="#ghc-flag--XDisambiguateRecordFields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDisambiguateRecordFields</span></code></a>.</p>
<p>For records with many fields, it can be tiresome to write out each field
individually in a record pattern, as in</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">C</span> <span class="ow">=</span> <span class="kt">C</span> <span class="p">{</span><span class="n">a</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">b</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">c</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">d</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">}</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">C</span> <span class="p">{</span><span class="n">a</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="ow">=</span> <span class="n">d</span><span class="p">})</span> <span class="ow">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span>
</pre></div>
</div>
<p>Record wildcard syntax permits a &#8220;<code class="docutils literal"><span class="pre">..</span></code>&#8221; in a record pattern, where
each elided field <code class="docutils literal"><span class="pre">f</span></code> is replaced by the pattern <code class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">f</span></code>. For
example, the above pattern can be written as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="p">(</span><span class="kt">C</span> <span class="p">{</span><span class="n">a</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">..</span><span class="p">})</span> <span class="ow">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span>
</pre></div>
</div>
<p>More details:</p>
<ul>
<li><p class="first">Record wildcards in patterns can be mixed with other patterns,
including puns (<a class="reference internal" href="#record-puns"><span>Record puns</span></a>); for example, in a pattern
<code class="docutils literal"><span class="pre">(C</span> <span class="pre">{a</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">b,</span> <span class="pre">..})</span></code>. Additionally, record wildcards can be used
wherever record patterns occur, including in <code class="docutils literal"><span class="pre">let</span></code> bindings and at
the top-level. For example, the top-level binding</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">C</span> <span class="p">{</span><span class="n">a</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="n">e</span>
</pre></div>
</div>
<p>defines <code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">c</span></code>, and <code class="docutils literal"><span class="pre">d</span></code>.</p>
</li>
<li><p class="first">Record wildcards can also be used in an expression, when constructing
a record. For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="p">{</span><span class="n">a</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">c</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">d</span> <span class="ow">=</span> <span class="mi">4</span><span class="p">}</span> <span class="kr">in</span> <span class="kt">C</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
</pre></div>
</div>
<p>in place of</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="p">{</span><span class="n">a</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">c</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">d</span> <span class="ow">=</span> <span class="mi">4</span><span class="p">}</span> <span class="kr">in</span> <span class="kt">C</span> <span class="p">{</span><span class="n">a</span><span class="ow">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="ow">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="ow">=</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="ow">=</span><span class="n">d</span><span class="p">}</span>
</pre></div>
</div>
<p>The expansion is purely syntactic, so the record wildcard expression
refers to the nearest enclosing variables that are spelled the same
as the omitted field names.</p>
</li>
<li><p class="first">Record wildcards may <em>not</em> be used in record <em>updates</em>. For example
this is illegal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">r</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">For both pattern and expression wildcards, the &#8220;<code class="docutils literal"><span class="pre">..</span></code>&#8221; expands to
the missing <em>in-scope</em> record fields. Specifically the expansion of
&#8220;<code class="docutils literal"><span class="pre">C</span> <span class="pre">{..}</span></code>&#8221; includes <code class="docutils literal"><span class="pre">f</span></code> if and only if:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">f</span></code> is a record field of constructor <code class="docutils literal"><span class="pre">C</span></code>.</li>
<li>The record field <code class="docutils literal"><span class="pre">f</span></code> is in scope somehow (either qualified or
unqualified).</li>
<li>In the case of expressions (but not patterns), the variable <code class="docutils literal"><span class="pre">f</span></code>
is in scope unqualified, and is not imported or bound at top level.
For example, <code class="docutils literal"><span class="pre">f</span></code> can be bound by an enclosing pattern match or
let/where-binding.  (The motivation here is that it should be
easy for the reader to figure out what the &#8220;<code class="docutils literal"><span class="pre">..</span></code>&#8221; expands to.)</li>
</ul>
<p>These rules restrict record wildcards to the situations in which the
user could have written the expanded version. For example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">M</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">R</span> <span class="ow">=</span> <span class="kt">R</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>
<span class="kr">module</span> <span class="nn">X</span> <span class="kr">where</span>
  <span class="kr">import</span> <span class="nn">M</span><span class="p">(</span> <span class="kt">R</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="p">)</span>
  <span class="n">f</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">R</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">R{..}</span></code> expands to <code class="docutils literal"><span class="pre">R{M.a=a}</span></code>, omitting <code class="docutils literal"><span class="pre">b</span></code> since the
record field is not in scope, and omitting <code class="docutils literal"><span class="pre">c</span></code> since the variable
<code class="docutils literal"><span class="pre">c</span></code> is not in scope (apart from the binding of the record selector
<code class="docutils literal"><span class="pre">c</span></code>, of course).</p>
</li>
<li><p class="first">Record wildcards cannot be used (a) in a record update construct, and
(b) for data constructors that are not declared with record fields.
For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">{</span> <span class="n">v</span><span class="ow">=</span><span class="kt">True</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span>   <span class="c1">-- Illegal (a)</span>

<span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="kt">Int</span> <span class="kt">Bool</span>
<span class="nf">g</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span>           <span class="c1">-- Illegal (b)</span>
<span class="nf">h</span> <span class="p">(</span><span class="kt">MkT</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span> <span class="ow">=</span> <span class="kt">True</span>    <span class="c1">-- Illegal (b)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="record-field-selector-polymorphism">
<span id="id20"></span><h2>10.5.6. Record field selector polymorphism<a class="headerlink" href="#record-field-selector-polymorphism" title="Permalink to this headline">¶</a></h2>
<p>The module <a class="reference external" href="../libraries/base-4.10.1.0/GHC-Records.html">GHC.Records</a> defines the following:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">HasField</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="n">r</span> <span class="n">a</span> <span class="o">|</span> <span class="n">x</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">getField</span> <span class="ow">::</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>A <code class="docutils literal"><span class="pre">HasField</span> <span class="pre">x</span> <span class="pre">r</span> <span class="pre">a</span></code> constraint represents the fact that <code class="docutils literal"><span class="pre">x</span></code> is a
field of type <code class="docutils literal"><span class="pre">a</span></code> belonging to a record type <code class="docutils literal"><span class="pre">r</span></code>.  The
<code class="docutils literal"><span class="pre">getField</span></code> method gives the record selector function.</p>
<p>This allows definitions that are polymorphic over record types with a specified
field.  For example, the following works with any record type that has a field
<code class="docutils literal"><span class="pre">name</span> <span class="pre">::</span> <span class="pre">String</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">HasField</span> <span class="s">&quot;name&quot;</span> <span class="n">r</span> <span class="kt">String</span> <span class="ow">=&gt;</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">foo</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">reverse</span> <span class="p">(</span><span class="n">getField</span> <span class="o">@</span><span class="s">&quot;name&quot;</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">HasField</span></code> is a magic built-in typeclass (similar to <code class="docutils literal"><span class="pre">Coercible</span></code>, for
example).  It is given special treatment by the constraint solver (see
<a class="reference internal" href="#solving-hasfield-constraints"><span>Solving HasField constraints</span></a>).  Users may define their own instances of
<code class="docutils literal"><span class="pre">HasField</span></code> also (see <a class="reference internal" href="#virtual-record-fields"><span>Virtual record fields</span></a>).</p>
<div class="section" id="solving-hasfield-constraints">
<span id="id21"></span><h3>10.5.6.1. Solving HasField constraints<a class="headerlink" href="#solving-hasfield-constraints" title="Permalink to this headline">¶</a></h3>
<p>If the constraint solver encounters a constraint <code class="docutils literal"><span class="pre">HasField</span> <span class="pre">x</span> <span class="pre">r</span> <span class="pre">a</span></code>
where <code class="docutils literal"><span class="pre">r</span></code> is a concrete datatype with a field <code class="docutils literal"><span class="pre">x</span></code> in scope, it
will automatically solve the constraint using the field selector as
the dictionary, unifying <code class="docutils literal"><span class="pre">a</span></code> with the type of the field if
necessary.  This happens irrespective of which extensions are enabled.</p>
<p>For example, if the following datatype is in scope</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">name</span> <span class="ow">::</span> <span class="kt">String</span> <span class="p">}</span>
</pre></div>
</div>
<p>the end result is rather like having an instance</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">HasField</span> <span class="s">&quot;name&quot;</span> <span class="kt">Person</span> <span class="kt">String</span> <span class="kr">where</span>
  <span class="n">getField</span> <span class="ow">=</span> <span class="n">name</span>
</pre></div>
</div>
<p>except that this instance is not actually generated anywhere, rather
the constraint is solved directly by the constraint solver.</p>
<p>A field must be in scope for the corresponding <code class="docutils literal"><span class="pre">HasField</span></code> constraint
to be solved.  This retains the existing representation hiding
mechanism, whereby a module may choose not to export a field,
preventing client modules from accessing or updating it directly.</p>
<p>Solving <code class="docutils literal"><span class="pre">HasField</span></code> constraints depends on the field selector functions that
are generated for each datatype definition:</p>
<ul>
<li><p class="first">If a record field does not have a selector function because its type would allow
an existential variable to escape, the corresponding <code class="docutils literal"><span class="pre">HasField</span></code> constraint
will not be solved.  For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE ExistentialQuantification #-}</span>
<span class="kr">data</span> <span class="kt">Exists</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">x</span> <span class="o">.</span> <span class="kt">MkExists</span> <span class="p">{</span> <span class="n">unExists</span> <span class="ow">::</span> <span class="n">t</span> <span class="n">x</span> <span class="p">}</span>
</pre></div>
</div>
<p>does not give rise to a selector <code class="docutils literal"><span class="pre">unExists</span> <span class="pre">::</span> <span class="pre">Exists</span> <span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">t</span> <span class="pre">x</span></code> and we will not
solve <code class="docutils literal"><span class="pre">HasField</span> <span class="pre">&quot;unExists&quot;</span> <span class="pre">(Exists</span> <span class="pre">t)</span> <span class="pre">a</span></code> automatically.</p>
</li>
<li><p class="first">If a record field has a polymorphic type (and hence the selector function is
higher-rank), the corresponding <code class="docutils literal"><span class="pre">HasField</span></code> constraint will not be solved,
because doing so would violate the functional dependency on <code class="docutils literal"><span class="pre">HasField</span></code> and/or
require impredicativity.  For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE RankNTypes #-}</span>
<span class="kr">data</span> <span class="kt">Higher</span> <span class="ow">=</span> <span class="kt">MkHigher</span> <span class="p">{</span> <span class="n">unHigher</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">t</span> <span class="o">.</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="p">}</span>
</pre></div>
</div>
<p>gives rise to a selector <code class="docutils literal"><span class="pre">unHigher</span> <span class="pre">::</span> <span class="pre">Higher</span> <span class="pre">-&gt;</span> <span class="pre">(forall</span> <span class="pre">t</span> <span class="pre">.</span> <span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">t)</span></code> but does
not lead to solution of the constraint <code class="docutils literal"><span class="pre">HasField</span> <span class="pre">&quot;unHigher&quot;</span> <span class="pre">Higher</span> <span class="pre">a</span></code>.</p>
</li>
<li><p class="first">A record GADT may have a restricted type for a selector function, which may lead
to additional unification when solving <code class="docutils literal"><span class="pre">HasField</span></code> constraints.  For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE GADTs #-}</span>
<span class="kr">data</span> <span class="kt">Gadt</span> <span class="n">t</span> <span class="kr">where</span>
  <span class="kt">MkGadt</span> <span class="ow">::</span> <span class="p">{</span> <span class="n">unGadt</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">v</span> <span class="p">}</span> <span class="ow">-&gt;</span> <span class="kt">Gadt</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
</pre></div>
</div>
<p>gives rise to a selector <code class="docutils literal"><span class="pre">unGadt</span> <span class="pre">::</span> <span class="pre">Gadt</span> <span class="pre">[v]</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">v</span></code>, so the solver will reduce
the constraint <code class="docutils literal"><span class="pre">HasField</span> <span class="pre">&quot;unGadt&quot;</span> <span class="pre">(Gadt</span> <span class="pre">t)</span> <span class="pre">b</span></code> by unifying <code class="docutils literal"><span class="pre">t</span> <span class="pre">~</span> <span class="pre">[v]</span></code> and
<code class="docutils literal"><span class="pre">b</span> <span class="pre">~</span> <span class="pre">Maybe</span> <span class="pre">v</span></code> for some fresh metavariable <code class="docutils literal"><span class="pre">v</span></code>, rather as if we had an instance</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="n">t</span> <span class="o">~</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">b</span> <span class="o">~</span> <span class="kt">Maybe</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">HasField</span> <span class="s">&quot;unGadt&quot;</span> <span class="p">(</span><span class="kt">Gadt</span> <span class="n">t</span><span class="p">)</span> <span class="n">b</span>
</pre></div>
</div>
</li>
<li><p class="first">If a record type has an old-fashioned datatype context, the <code class="docutils literal"><span class="pre">HasField</span></code>
constraint will be reduced to solving the constraints from the context.
For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE DatatypeContexts #-}</span>
<span class="kr">data</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Silly</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkSilly</span> <span class="p">{</span> <span class="n">unSilly</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">}</span>
</pre></div>
</div>
<p>gives rise to a selector <code class="docutils literal"><span class="pre">unSilly</span> <span class="pre">::</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Silly</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, so
the solver will reduce the constraint <code class="docutils literal"><span class="pre">HasField</span> <span class="pre">&quot;unSilly&quot;</span> <span class="pre">(Silly</span> <span class="pre">a)</span> <span class="pre">b</span></code> to
<code class="docutils literal"><span class="pre">Eq</span> <span class="pre">a</span></code> (and unify <code class="docutils literal"><span class="pre">a</span></code> with <code class="docutils literal"><span class="pre">b</span></code>), rather as if we had an instance</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">~</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">HasField</span> <span class="s">&quot;unSilly&quot;</span> <span class="p">(</span><span class="kt">Silly</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="virtual-record-fields">
<span id="id22"></span><h3>10.5.6.2. Virtual record fields<a class="headerlink" href="#virtual-record-fields" title="Permalink to this headline">¶</a></h3>
<p>Users may define their own instances of <code class="docutils literal"><span class="pre">HasField</span></code>, provided they do
not conflict with the built-in constraint solving behaviour.  This
allows &#8220;virtual&#8221; record fields to be defined for datatypes that do not
otherwise have them.</p>
<p>For example, this instance would make the <code class="docutils literal"><span class="pre">name</span></code> field of <code class="docutils literal"><span class="pre">Person</span></code>
accessible using <code class="docutils literal"><span class="pre">#fullname</span></code> as well:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">HasField</span> <span class="s">&quot;fullname&quot;</span> <span class="kt">Person</span> <span class="kt">String</span> <span class="kr">where</span>
  <span class="n">getField</span> <span class="ow">=</span> <span class="n">name</span>
</pre></div>
</div>
<p>More substantially, an anonymous records library could provide
<code class="docutils literal"><span class="pre">HasField</span></code> instances for its anonymous records, and thus be
compatible with the polymorphic record selectors introduced by this
proposal.  For example, something like this makes it possible to use
<code class="docutils literal"><span class="pre">getField</span></code> to access <code class="docutils literal"><span class="pre">Record</span></code> values with the appropriate
string in the type-level list of fields:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data Record (xs :: [(k, Type)]) where
  Nil  :: Record &#39;[]
  Cons :: Proxy x -&gt; a -&gt; Record xs -&gt; Record (&#39;(x, a) &#39;: xs)

instance HasField x (Record (&#39;(x, a) &#39;: xs)) a where
  getField (Cons _ v _) = v
instance HasField x (Record xs) a =&gt; HasField x (Record (&#39;(y, b) &#39;: xs)) a where
  getField (Cons _ _ r) = getField @x r

r :: Record &#39;[ &#39;(&quot;name&quot;, String) ]
r = Cons Proxy &quot;R&quot; Nil)

x = getField @&quot;name&quot; r
</pre></div>
</div>
<p>Since representations such as this can support field labels with kinds other
than <code class="docutils literal"><span class="pre">Symbol</span></code>, the <code class="docutils literal"><span class="pre">HasField</span></code> class is poly-kinded (even though the built-in
constraint solving works only at kind <code class="docutils literal"><span class="pre">Symbol</span></code>).  In particular, this allows
users to declare scoped field labels such as in the following example:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data PersonFields = Name

s :: Record &#39;[ &#39;(Name, String) ]
s = Cons Proxy &quot;S&quot; Nil

y = getField @Name s
</pre></div>
</div>
<p>In order to avoid conflicting with the built-in constraint solving,
the following user-defined <code class="docutils literal"><span class="pre">HasField</span></code> instances are prohibited (in
addition to the usual rules, such as the prohibition on type
families appearing in instance heads):</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HasField</span> <span class="pre">_</span> <span class="pre">r</span> <span class="pre">_</span></code> where <code class="docutils literal"><span class="pre">r</span></code> is a variable;</li>
<li><code class="docutils literal"><span class="pre">HasField</span> <span class="pre">_</span> <span class="pre">(T</span> <span class="pre">...)</span> <span class="pre">_</span></code> if <code class="docutils literal"><span class="pre">T</span></code> is a data family (because it
might have fields introduced later, using data instance declarations);</li>
<li><code class="docutils literal"><span class="pre">HasField</span> <span class="pre">x</span> <span class="pre">(T</span> <span class="pre">...)</span> <span class="pre">_</span></code> if <code class="docutils literal"><span class="pre">x</span></code> is a variable and <code class="docutils literal"><span class="pre">T</span></code> has any
fields at all (but this instance is permitted if <code class="docutils literal"><span class="pre">T</span></code> has no fields);</li>
<li><code class="docutils literal"><span class="pre">HasField</span> <span class="pre">&quot;foo&quot;</span> <span class="pre">(T</span> <span class="pre">...)</span> <span class="pre">_</span></code> if <code class="docutils literal"><span class="pre">T</span></code> has a field <code class="docutils literal"><span class="pre">foo</span></code> (but this
instance is permitted if it does not).</li>
</ul>
<p>If a field has a higher-rank or existential type, the corresponding <code class="docutils literal"><span class="pre">HasField</span></code>
constraint will not be solved automatically (as described above), but in the
interests of simplicity we do not permit users to define their own instances
either.  If a field is not in scope, the corresponding instance is still
prohibited, to avoid conflicts in downstream modules.</p>
</div>
</div>
</div>
<div class="section" id="extensions-to-the-deriving-mechanism">
<span id="deriving"></span><h1>10.6. Extensions to the &#8220;deriving&#8221; mechanism<a class="headerlink" href="#extensions-to-the-deriving-mechanism" title="Permalink to this headline">¶</a></h1>
<div class="section" id="inferred-context-for-deriving-clauses">
<span id="deriving-inferred"></span><h2>10.6.1. Inferred context for deriving clauses<a class="headerlink" href="#inferred-context-for-deriving-clauses" title="Permalink to this headline">¶</a></h2>
<p>The Haskell Report is vague about exactly when a <code class="docutils literal"><span class="pre">deriving</span></code> clause is
legal. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T0</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkT0</span> <span class="n">a</span>         <span class="kr">deriving</span><span class="p">(</span> <span class="kt">Eq</span> <span class="p">)</span>
<span class="kr">data</span> <span class="kt">T1</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkT1</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>     <span class="kr">deriving</span><span class="p">(</span> <span class="kt">Eq</span> <span class="p">)</span>
<span class="kr">data</span> <span class="kt">T2</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkT2</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">))</span> <span class="kr">deriving</span><span class="p">(</span> <span class="kt">Eq</span> <span class="p">)</span>
</pre></div>
</div>
<p>The natural generated <code class="docutils literal"><span class="pre">Eq</span></code> code would result in these instance
declarations:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span>         <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">T0</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>     <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">T1</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">T2</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>The first of these is obviously fine. The second is still fine, although
less obviously. The third is not Haskell 98, and risks losing
termination of instances.</p>
<p>GHC takes a conservative position: it accepts the first two, but not the
third. The rule is this: each constraint in the inferred instance
context must consist only of type variables, with no repetitions.</p>
<p>This rule is applied regardless of flags. If you want a more exotic
context, you can write it yourself, using the <a class="reference external" href="#stand-alone-deriving">standalone deriving
mechanism</a>.</p>
</div>
<div class="section" id="stand-alone-deriving-declarations">
<span id="stand-alone-deriving"></span><h2>10.6.2. Stand-alone deriving declarations<a class="headerlink" href="#stand-alone-deriving-declarations" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XStandaloneDeriving">
<code class="descname">-XStandaloneDeriving</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XStandaloneDeriving" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the use of stand-alone <code class="docutils literal"><span class="pre">deriving</span></code> declarations.</p>
</dd></dl>

<p>GHC allows stand-alone <code class="docutils literal"><span class="pre">deriving</span></code> declarations, enabled by
<a class="reference internal" href="#ghc-flag--XStandaloneDeriving"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XStandaloneDeriving</span></code></a>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Bar</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Baz</span> <span class="kt">String</span>

<span class="kr">deriving</span> <span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Foo</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The syntax is identical to that of an ordinary instance declaration
apart from (a) the keyword <code class="docutils literal"><span class="pre">deriving</span></code>, and (b) the absence of the
<code class="docutils literal"><span class="pre">where</span></code> part.</p>
<p>However, standalone deriving differs from a <code class="docutils literal"><span class="pre">deriving</span></code> clause in a
number of important ways:</p>
<ul>
<li><p class="first">The standalone deriving declaration does not need to be in the same
module as the data type declaration. (But be aware of the dangers of
orphan instances (<a class="reference internal" href="separate_compilation.html#orphan-modules"><span>Orphan modules and instance declarations</span></a>).</p>
</li>
<li><p class="first">You must supply an explicit context (in the example the context is
<code class="docutils literal"><span class="pre">(Eq</span> <span class="pre">a)</span></code>), exactly as you would in an ordinary instance
declaration. (In contrast, in a <code class="docutils literal"><span class="pre">deriving</span></code> clause attached to a
data type declaration, the context is inferred.)</p>
</li>
<li><p class="first">Unlike a <code class="docutils literal"><span class="pre">deriving</span></code> declaration attached to a <code class="docutils literal"><span class="pre">data</span></code> declaration,
the instance can be more specific than the data type (assuming you
also use <a class="reference internal" href="#ghc-flag--XFlexibleInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleInstances</span></code></a>, <a class="reference internal" href="#instance-rules"><span>Relaxed rules for instance contexts</span></a>). Consider
for example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Bar</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Baz</span> <span class="kt">String</span>

<span class="kr">deriving</span> <span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Foo</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>
<span class="kr">deriving</span> <span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Foo</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
<p>This will generate a derived instance for <code class="docutils literal"><span class="pre">(Foo</span> <span class="pre">[a])</span></code> and
<code class="docutils literal"><span class="pre">(Foo</span> <span class="pre">(Maybe</span> <span class="pre">a))</span></code>, but other types such as <code class="docutils literal"><span class="pre">(Foo</span> <span class="pre">(Int,Bool))</span></code>
will not be an instance of <code class="docutils literal"><span class="pre">Eq</span></code>.</p>
</li>
<li><p class="first">Unlike a <code class="docutils literal"><span class="pre">deriving</span></code> declaration attached to a <code class="docutils literal"><span class="pre">data</span></code> declaration,
GHC does not restrict the form of the data type. Instead, GHC simply
generates the appropriate boilerplate code for the specified class,
and typechecks it. If there is a type error, it is your problem. (GHC
will show you the offending code if it has a type error.)</p>
<p>The merit of this is that you can derive instances for GADTs and
other exotic data types, providing only that the boilerplate code
does indeed typecheck. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="kr">where</span>
   <span class="kt">T1</span> <span class="ow">::</span> <span class="kt">T</span> <span class="kt">Int</span>
   <span class="kt">T2</span> <span class="ow">::</span> <span class="kt">T</span> <span class="kt">Bool</span>

<span class="kr">deriving</span> <span class="kr">instance</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, you cannot say <code class="docutils literal"><span class="pre">...</span> <span class="pre">deriving(</span> <span class="pre">Show</span> <span class="pre">)</span></code> on the data
type declaration for <code class="docutils literal"><span class="pre">T</span></code>, because <code class="docutils literal"><span class="pre">T</span></code> is a GADT, but you <em>can</em>
generate the instance declaration using stand-alone deriving.</p>
<p>The down-side is that, if the boilerplate code fails to typecheck,
you will get an error message about that code, which you did not
write. Whereas, with a <code class="docutils literal"><span class="pre">deriving</span></code> clause the side-conditions are
necessarily more conservative, but any error message may be more
comprehensible.</p>
</li>
<li><p class="first">Under most circumstances, you cannot use standalone deriving to create an
instance for a data type whose constructors are not all in scope. This is
because the derived instance would generate code that uses the constructors
behind the scenes, which would break abstraction.</p>
<p>The one exception to this rule is <a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a>, since
deriving an instance via <a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a> simply generates
an empty instance declaration, which does not require the use of any
constructors. See the <a class="reference external" href="#derive-any-class">deriving any class</a> section
for more details.</p>
</li>
</ul>
<p>In other ways, however, a standalone deriving obeys the same rules as
ordinary deriving:</p>
<ul>
<li><p class="first">A <code class="docutils literal"><span class="pre">deriving</span> <span class="pre">instance</span></code> declaration must obey the same rules
concerning form and termination as ordinary instance declarations,
controlled by the same flags; see <a class="reference internal" href="#instance-decls"><span>Instance declarations</span></a>.</p>
</li>
<li><p class="first">The stand-alone syntax is generalised for newtypes in exactly the
same way that ordinary <code class="docutils literal"><span class="pre">deriving</span></code> clauses are generalised
(<a class="reference internal" href="#newtype-deriving"><span>Generalised derived instances for newtypes</span></a>). For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkFoo</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">Int</span> <span class="n">a</span><span class="p">)</span>

<span class="kr">deriving</span> <span class="kr">instance</span> <span class="kt">MonadState</span> <span class="kt">Int</span> <span class="kt">Foo</span>
</pre></div>
</div>
<p>GHC always treats the <em>last</em> parameter of the instance (<code class="docutils literal"><span class="pre">Foo</span></code> in
this example) as the type whose instance is being derived.</p>
</li>
</ul>
</div>
<div class="section" id="deriving-instances-of-extra-classes-data-etc">
<span id="deriving-extra"></span><h2>10.6.3. Deriving instances of extra classes (<code class="docutils literal"><span class="pre">Data</span></code>, etc.)<a class="headerlink" href="#deriving-instances-of-extra-classes-data-etc" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XDeriveGeneric">
<code class="descname">-XDeriveGeneric</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDeriveGeneric" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.2</td>
</tr>
</tbody>
</table>
<p>Allow automatic deriving of instances for the <code class="docutils literal"><span class="pre">Generic</span></code> typeclass.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--XDeriveFunctor">
<code class="descname">-XDeriveFunctor</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDeriveFunctor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">6.12</td>
</tr>
</tbody>
</table>
<p>Allow automatic deriving of instances for the <code class="docutils literal"><span class="pre">Functor</span></code> typeclass.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--XDeriveFoldable">
<code class="descname">-XDeriveFoldable</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDeriveFoldable" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">6.12</td>
</tr>
</tbody>
</table>
<p>Allow automatic deriving of instances for the <code class="docutils literal"><span class="pre">Foldable</span></code> typeclass.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--XDeriveTraversable">
<code class="descname">-XDeriveTraversable</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDeriveTraversable" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">6.12</td>
</tr>
<tr class="field-even field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XDeriveFoldable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFoldable</span></code></a>, <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a></td>
</tr>
</tbody>
</table>
<p>Allow automatic deriving of instances for the <code class="docutils literal"><span class="pre">Traversable</span></code> typeclass.</p>
</dd></dl>

<p>Haskell 98 allows the programmer to add &#8220;<code class="docutils literal"><span class="pre">deriving(</span> <span class="pre">Eq,</span> <span class="pre">Ord</span> <span class="pre">)</span></code>&#8221; to a
data type declaration, to generate a standard instance declaration for
classes specified in the <code class="docutils literal"><span class="pre">deriving</span></code> clause. In Haskell 98, the only
classes that may appear in the <code class="docutils literal"><span class="pre">deriving</span></code> clause are the standard
classes <code class="docutils literal"><span class="pre">Eq</span></code>, <code class="docutils literal"><span class="pre">Ord</span></code>, <code class="docutils literal"><span class="pre">Enum</span></code>, <code class="docutils literal"><span class="pre">Ix</span></code>, <code class="docutils literal"><span class="pre">Bounded</span></code>, <code class="docutils literal"><span class="pre">Read</span></code>, and
<code class="docutils literal"><span class="pre">Show</span></code>.</p>
<p>GHC extends this list with several more classes that may be
automatically derived:</p>
<ul class="simple">
<li>With <a class="reference internal" href="#ghc-flag--XDeriveGeneric"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveGeneric</span></code></a>, you can derive instances of the classes
<code class="docutils literal"><span class="pre">Generic</span></code> and <code class="docutils literal"><span class="pre">Generic1</span></code>, defined in <code class="docutils literal"><span class="pre">GHC.Generics</span></code>. You can
use these to define generic functions, as described in
<a class="reference internal" href="#generic-programming"><span>Generic programming</span></a>.</li>
<li>With <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a>, you can derive instances of the class
<code class="docutils literal"><span class="pre">Functor</span></code>, defined in <code class="docutils literal"><span class="pre">GHC.Base</span></code>. See <a class="reference internal" href="#deriving-functor"><span>Deriving Functor instances</span></a>.</li>
<li>With <a class="reference internal" href="#ghc-flag--XDeriveDataTypeable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveDataTypeable</span></code></a>, you can derive instances of the class
<code class="docutils literal"><span class="pre">Data</span></code>, defined in <code class="docutils literal"><span class="pre">Data.Data</span></code>. See <a class="reference internal" href="#deriving-data"><span>Deriving Data instances</span></a>.</li>
<li>With <a class="reference internal" href="#ghc-flag--XDeriveFoldable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFoldable</span></code></a>, you can derive instances of the class
<code class="docutils literal"><span class="pre">Foldable</span></code>, defined in <code class="docutils literal"><span class="pre">Data.Foldable</span></code>. See
<a class="reference internal" href="#deriving-foldable"><span>Deriving Foldable instances</span></a>.</li>
<li>With <a class="reference internal" href="#ghc-flag--XDeriveTraversable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveTraversable</span></code></a>, you can derive instances of the class
<code class="docutils literal"><span class="pre">Traversable</span></code>, defined in <code class="docutils literal"><span class="pre">Data.Traversable</span></code>. Since the
<code class="docutils literal"><span class="pre">Traversable</span></code> instance dictates the instances of <code class="docutils literal"><span class="pre">Functor</span></code> and
<code class="docutils literal"><span class="pre">Foldable</span></code>, you&#8217;ll probably want to derive them too, so
<a class="reference internal" href="#ghc-flag--XDeriveTraversable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveTraversable</span></code></a> implies <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> and
<a class="reference internal" href="#ghc-flag--XDeriveFoldable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFoldable</span></code></a>. See <a class="reference internal" href="#deriving-traversable"><span>Deriving Traversable instances</span></a>.</li>
<li>With <a class="reference internal" href="#ghc-flag--XDeriveLift"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveLift</span></code></a>, you can derive instances of the class <code class="docutils literal"><span class="pre">Lift</span></code>,
defined in the <code class="docutils literal"><span class="pre">Language.Haskell.TH.Syntax</span></code> module of the
<code class="docutils literal"><span class="pre">template-haskell</span></code> package. See <a class="reference internal" href="#deriving-lift"><span>Deriving Lift instances</span></a>.</li>
</ul>
<p>You can also use a standalone deriving declaration instead (see
<a class="reference internal" href="#stand-alone-deriving"><span>Stand-alone deriving declarations</span></a>).</p>
<p>In each case the appropriate class must be in scope before it can be
mentioned in the <code class="docutils literal"><span class="pre">deriving</span></code> clause.</p>
</div>
<div class="section" id="deriving-functor-instances">
<span id="deriving-functor"></span><h2>10.6.4. Deriving <code class="docutils literal"><span class="pre">Functor</span></code> instances<a class="headerlink" href="#deriving-functor-instances" title="Permalink to this headline">¶</a></h2>
<p>With <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a>, one can derive <code class="docutils literal"><span class="pre">Functor</span></code> instances for data types
of kind <code class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. For example, this declaration:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Example</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Ex</span> <span class="n">a</span> <span class="kt">Char</span> <span class="p">(</span><span class="kt">Example</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Example</span> <span class="kt">Char</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="kt">Functor</span>
</pre></div>
</div>
<p>would generate the following instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Example</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Ex</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">a3</span> <span class="n">a4</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Ex</span> <span class="p">(</span><span class="n">f</span> <span class="n">a1</span><span class="p">)</span> <span class="n">a2</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">a3</span><span class="p">)</span> <span class="n">a4</span>
</pre></div>
</div>
<p>The basic algorithm for <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> walks the arguments of each
constructor of a data type, applying a mapping function depending on the type
of each argument. If a plain type variable is found that is syntactically
equivalent to the last type parameter of the data type (<code class="docutils literal"><span class="pre">a</span></code> in the above
example), then we apply the function <code class="docutils literal"><span class="pre">f</span></code> directly to it. If a type is
encountered that is not syntactically equivalent to the last type parameter
<em>but does mention</em> the last type parameter somewhere in it, then a recursive
call to <code class="docutils literal"><span class="pre">fmap</span></code> is made. If a type is found which doesn&#8217;t mention the last
type parameter at all, then it is left alone.</p>
<p>The second of those cases, in which a type is unequal to the type parameter but
does contain the type parameter, can be surprisingly tricky. For example, the
following example compiles:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Right</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="kt">Either</span> <span class="kt">Int</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="kt">Functor</span>
</pre></div>
</div>
<p>Modifying the code slightly, however, produces code which will not compile:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Wrong</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Wrong</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">deriving</span> <span class="kt">Functor</span>
</pre></div>
</div>
<p>The difference involves the placement of the last type parameter, <code class="docutils literal"><span class="pre">a</span></code>. In the
<code class="docutils literal"><span class="pre">Right</span></code> case, <code class="docutils literal"><span class="pre">a</span></code> occurs within the type <code class="docutils literal"><span class="pre">Either</span> <span class="pre">Int</span> <span class="pre">a</span></code>, and moreover, it
appears as the last type argument of <code class="docutils literal"><span class="pre">Either</span></code>. In the <code class="docutils literal"><span class="pre">Wrong</span></code> case,
however, <code class="docutils literal"><span class="pre">a</span></code> is not the last type argument to <code class="docutils literal"><span class="pre">Either</span></code>; rather, <code class="docutils literal"><span class="pre">Int</span></code> is.</p>
<p>This distinction is important because of the way <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> works. The
derived <code class="docutils literal"><span class="pre">Functor</span> <span class="pre">Right</span></code> instance would be:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Right</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Given a value of type <code class="docutils literal"><span class="pre">Right</span> <span class="pre">a</span></code>, GHC must produce a value of type
<code class="docutils literal"><span class="pre">Right</span> <span class="pre">b</span></code>. Since the argument to the <code class="docutils literal"><span class="pre">Right</span></code> constructor has type
<code class="docutils literal"><span class="pre">Either</span> <span class="pre">Int</span> <span class="pre">a</span></code>, the code recursively calls <code class="docutils literal"><span class="pre">fmap</span></code> on it to produce a value
of type <code class="docutils literal"><span class="pre">Either</span> <span class="pre">Int</span> <span class="pre">b</span></code>, which is used in turn to construct a final value of
type <code class="docutils literal"><span class="pre">Right</span> <span class="pre">b</span></code>.</p>
<p>The generated code for the <code class="docutils literal"><span class="pre">Functor</span> <span class="pre">Wrong</span></code> instance would look exactly the
same, except with <code class="docutils literal"><span class="pre">Wrong</span></code> replacing every occurrence of <code class="docutils literal"><span class="pre">Right</span></code>. The
problem is now that <code class="docutils literal"><span class="pre">fmap</span></code> is being applied recursively to a value of type
<code class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">Int</span></code>. This cannot possibly produce a value of type
<code class="docutils literal"><span class="pre">Either</span> <span class="pre">b</span> <span class="pre">Int</span></code>, as <code class="docutils literal"><span class="pre">fmap</span></code> can only change the last type parameter! This
causes the generated code to be ill-typed.</p>
<p>As a general rule, if a data type has a derived <code class="docutils literal"><span class="pre">Functor</span></code> instance and its
last type parameter occurs on the right-hand side of the data declaration, then
either it must (1) occur bare (e.g., <code class="docutils literal"><span class="pre">newtype</span> <span class="pre">Id</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span></code>), or (2) occur as the
last argument of a type constructor (as in <code class="docutils literal"><span class="pre">Right</span></code> above).</p>
<p>There are two exceptions to this rule:</p>
<ol class="arabic">
<li><p class="first">Tuple types. When a non-unit tuple is used on the right-hand side of a data
declaration, <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> treats it as a product of distinct types.
In other words, the following code:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Triple</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Triple</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="kr">deriving</span> <span class="kt">Functor</span>
</pre></div>
</div>
<p>Would result in a generated <code class="docutils literal"><span class="pre">Functor</span></code> instance like so:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Triple</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Triple</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kt">Triple</span> <span class="p">(</span><span class="kr">case</span> <span class="n">a</span> <span class="kr">of</span>
                 <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">a3</span><span class="p">))</span>
</pre></div>
</div>
<p>That is, <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> pattern-matches its way into tuples and maps
over each type that constitutes the tuple. The generated code is
reminiscient of what would be generated from
<code class="docutils literal"><span class="pre">data</span> <span class="pre">Triple</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Triple</span> <span class="pre">a</span> <span class="pre">Int</span> <span class="pre">[a]</span></code>, except with extra machinery to handle
the tuple.</p>
</li>
<li><p class="first">Function types. The last type parameter can appear anywhere in a function
type as long as it occurs in a <em>covariant</em> position. To illustrate what this
means, consider the following three examples:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">CovFun1</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">CovFun1</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="kt">Functor</span>
<span class="kr">newtype</span> <span class="kt">CovFun2</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">CovFun2</span> <span class="p">((</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="kt">Functor</span>
<span class="kr">newtype</span> <span class="kt">CovFun3</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">CovFun3</span> <span class="p">(((</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="kt">Functor</span>
</pre></div>
</div>
<p>All three of these examples would compile without issue. On the other hand:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">ContraFun1</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ContraFun1</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">deriving</span> <span class="kt">Functor</span>
<span class="kr">newtype</span> <span class="kt">ContraFun2</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ContraFun2</span> <span class="p">((</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">deriving</span> <span class="kt">Functor</span>
<span class="kr">newtype</span> <span class="kt">ContraFun3</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ContraFun3</span> <span class="p">(((</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">deriving</span> <span class="kt">Functor</span>
</pre></div>
</div>
<p>While these examples look similar, none of them would successfully compile.
This is because all occurrences of the last type parameter <code class="docutils literal"><span class="pre">a</span></code> occur in <em>contravariant</em> positions, not covariant ones.</p>
<p>Intuitively, a covariant type is <em>produced</em>, and a contravariant type is
<em>consumed</em>. Most types in Haskell are covariant, but the function type is
special in that the lefthand side of a function arrow reverses variance. If
a function type <code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> appears in a covariant position (e.g.,
<code class="docutils literal"><span class="pre">CovFun1</span></code> above), then <code class="docutils literal"><span class="pre">a</span></code> is in a contravariant position and <code class="docutils literal"><span class="pre">b</span></code> is
in a covariant position. Similarly, if <code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> appears in a contravariant
position (e.g., <code class="docutils literal"><span class="pre">CovFun2</span></code> above), then <code class="docutils literal"><span class="pre">a</span></code> is in <code class="docutils literal"><span class="pre">a</span></code> covariant
position and <code class="docutils literal"><span class="pre">b</span></code> is in a contravariant position.</p>
<p>To see why a data type with a contravariant occurrence of its last type
parameter cannot have a derived <code class="docutils literal"><span class="pre">Functor</span></code> instance, let&#8217;s suppose that a
<code class="docutils literal"><span class="pre">Functor</span> <span class="pre">ContraFun1</span></code> instance exists. The implementation would look
something like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">ContraFun1</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">ContraFun</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">ContraFun</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">_</span><span class="p">)</span>
</pre></div>
</div>
<p>We have <code class="docutils literal"><span class="pre">f</span> <span class="pre">::</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">g</span> <span class="pre">::</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>, and <code class="docutils literal"><span class="pre">x</span> <span class="pre">::</span> <span class="pre">b</span></code>. Using these, we
must somehow fill in the hole (denoted with an underscore) with a value of
type <code class="docutils literal"><span class="pre">Int</span></code>. What are our options?</p>
<p>We could try applying <code class="docutils literal"><span class="pre">g</span></code> to <code class="docutils literal"><span class="pre">x</span></code>. This won&#8217;t work though, as <code class="docutils literal"><span class="pre">g</span></code>
expects an argument of type <code class="docutils literal"><span class="pre">a</span></code>, and <code class="docutils literal"><span class="pre">x</span> <span class="pre">::</span> <span class="pre">b</span></code>. Even worse, we can&#8217;t turn
<code class="docutils literal"><span class="pre">x</span></code> into something of type <code class="docutils literal"><span class="pre">a</span></code>, since <code class="docutils literal"><span class="pre">f</span></code> also needs an argument of
type <code class="docutils literal"><span class="pre">a</span></code>! In short, there&#8217;s no good way to make this work.</p>
<p>On the other hand, a derived <code class="docutils literal"><span class="pre">Functor</span></code> instances for the <code class="docutils literal"><span class="pre">CovFun</span></code>s are
within the realm of possibility:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">CovFun1</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">CovFun1</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">CovFun1</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">CovFun2</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">CovFun2</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">CovFun2</span> <span class="p">(</span><span class="nf">\</span><span class="n">h</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">h</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">))))</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">CovFun3</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">CovFun3</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">CovFun3</span> <span class="p">(</span><span class="nf">\</span><span class="n">h</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="p">(</span><span class="nf">\</span><span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">h</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">k</span> <span class="n">x</span><span class="p">)))))</span>
</pre></div>
</div>
</li>
</ol>
<p>There are some other scenarios in which a derived <code class="docutils literal"><span class="pre">Functor</span></code> instance will
fail to compile:</p>
<ol class="arabic">
<li><p class="first">A data type has no type parameters (e.g., <code class="docutils literal"><span class="pre">data</span> <span class="pre">Nothing</span> <span class="pre">=</span> <span class="pre">Nothing</span></code>).</p>
</li>
<li><p class="first">A data type&#8217;s last type variable is used in a <a class="reference internal" href="#ghc-flag--XDatatypeContexts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDatatypeContexts</span></code></a>
constraint (e.g., <code class="docutils literal"><span class="pre">data</span> <span class="pre">Ord</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">O</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">O</span> <span class="pre">a</span></code>).</p>
</li>
<li><p class="first">A data type&#8217;s last type variable is used in an
<a class="reference internal" href="#ghc-flag--XExistentialQuantification"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExistentialQuantification</span></code></a> constraint, or is refined in a GADT. For
example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
    <span class="kt">T4</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">a</span> <span class="n">b</span>
    <span class="kt">T5</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">b</span> <span class="n">b</span>
    <span class="kt">T6</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">a</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

<span class="kr">deriving</span> <span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>would not compile successfully due to the way in which <code class="docutils literal"><span class="pre">b</span></code> is constrained.</p>
</li>
</ol>
</div>
<div class="section" id="deriving-foldable-instances">
<span id="deriving-foldable"></span><h2>10.6.5. Deriving <code class="docutils literal"><span class="pre">Foldable</span></code> instances<a class="headerlink" href="#deriving-foldable-instances" title="Permalink to this headline">¶</a></h2>
<p>With <a class="reference internal" href="#ghc-flag--XDeriveFoldable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFoldable</span></code></a>, one can derive <code class="docutils literal"><span class="pre">Foldable</span></code> instances for data types
of kind <code class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. For example, this declaration:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Example</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Ex</span> <span class="n">a</span> <span class="kt">Char</span> <span class="p">(</span><span class="kt">Example</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Example</span> <span class="kt">Char</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="kt">Foldable</span>
</pre></div>
</div>
<p>would generate the following instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">Example</span> <span class="kr">where</span>
  <span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Ex</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">a3</span> <span class="n">a4</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a1</span> <span class="p">(</span><span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="n">a3</span><span class="p">)</span>
  <span class="n">foldMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Ex</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">a3</span> <span class="n">a4</span><span class="p">)</span> <span class="ow">=</span> <span class="n">mappend</span> <span class="p">(</span><span class="n">f</span> <span class="n">a1</span><span class="p">)</span> <span class="p">(</span><span class="n">foldMap</span> <span class="n">f</span> <span class="n">a3</span><span class="p">)</span>
</pre></div>
</div>
<p>The algorithm for <a class="reference internal" href="#ghc-flag--XDeriveFoldable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFoldable</span></code></a> is adapted from the <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a>
algorithm, but it generates definitions for <code class="docutils literal"><span class="pre">foldMap</span></code> and <code class="docutils literal"><span class="pre">foldr</span></code> instead
of <code class="docutils literal"><span class="pre">fmap</span></code>. In addition, <a class="reference internal" href="#ghc-flag--XDeriveFoldable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFoldable</span></code></a> filters out all
constructor arguments on the RHS expression whose types do not mention the last
type parameter, since those arguments do not need to be folded over.</p>
<p>Here are the differences between the generated code in each extension:</p>
<ol class="arabic simple">
<li>When a bare type variable <code class="docutils literal"><span class="pre">a</span></code> is encountered, <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> would
generate <code class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></code> for an <code class="docutils literal"><span class="pre">fmap</span></code> definition. <a class="reference internal" href="#ghc-flag--XDeriveFoldable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFoldable</span></code></a> would
generate <code class="docutils literal"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">z</span></code> for <code class="docutils literal"><span class="pre">foldr</span></code>, and <code class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></code> for <code class="docutils literal"><span class="pre">foldMap</span></code>.</li>
<li>When a type that is not syntactically equivalent to <code class="docutils literal"><span class="pre">a</span></code>, but which does
contain <code class="docutils literal"><span class="pre">a</span></code>, is encountered, <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> recursively calls
<code class="docutils literal"><span class="pre">fmap</span></code> on it. Similarly, <a class="reference internal" href="#ghc-flag--XDeriveFoldable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFoldable</span></code></a> would recursively call
<code class="docutils literal"><span class="pre">foldr</span></code> and <code class="docutils literal"><span class="pre">foldMap</span></code>.</li>
<li><a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> puts everything back together again at the end by
invoking the constructor. <a class="reference internal" href="#ghc-flag--XDeriveFoldable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFoldable</span></code></a>, however, builds up a value
of some type. For <code class="docutils literal"><span class="pre">foldr</span></code>, this is accomplished by chaining applications
of <code class="docutils literal"><span class="pre">f</span></code> and recursive <code class="docutils literal"><span class="pre">foldr</span></code> calls on the state value <code class="docutils literal"><span class="pre">z</span></code>. For
<code class="docutils literal"><span class="pre">foldMap</span></code>, this happens by combining all values with <code class="docutils literal"><span class="pre">mappend</span></code>.</li>
</ol>
<p>There are some other differences regarding what data types can have derived
<code class="docutils literal"><span class="pre">Foldable</span></code> instances:</p>
<ol class="arabic">
<li><p class="first">Data types containing function types on the right-hand side cannot have
derived <code class="docutils literal"><span class="pre">Foldable</span></code> instances.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Foldable</span></code> instances can be derived for data types in which the last type
parameter is existentially constrained or refined in a GADT. For example,
this data type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">E</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="kt">E1</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">~</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span>   <span class="ow">-&gt;</span> <span class="kt">E</span> <span class="n">a</span>
    <span class="kt">E2</span> <span class="ow">::</span>              <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">E</span> <span class="kt">Int</span>
    <span class="kt">E3</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">~</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span>   <span class="ow">-&gt;</span> <span class="kt">E</span> <span class="kt">Int</span>
    <span class="kt">E4</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">~</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">E</span> <span class="n">a</span>

<span class="kr">deriving</span> <span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">E</span>
</pre></div>
</div>
<p>would have the following generated <code class="docutils literal"><span class="pre">Foldable</span></code> instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">E</span> <span class="kr">where</span>
    <span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">E1</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">e</span> <span class="n">z</span>
    <span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">E2</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">z</span>
    <span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">E3</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">z</span>
    <span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">E4</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">z</span>

    <span class="n">foldMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">E1</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">e</span>
    <span class="n">foldMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">E2</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">mempty</span>
    <span class="n">foldMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">E3</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">mempty</span>
    <span class="n">foldMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">E4</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">mempty</span>
</pre></div>
</div>
<p>Notice how every constructor of <code class="docutils literal"><span class="pre">E</span></code> utilizes some sort of existential
quantification, but only the argument of <code class="docutils literal"><span class="pre">E1</span></code> is actually &#8220;folded over&#8221;.
This is because we make a deliberate choice to only fold over universally
polymorphic types that are syntactically equivalent to the last type
parameter. In particular:</p>
</li>
</ol>
<blockquote>
<div><ul class="simple">
<li>We don&#8217;t fold over the arguments of <code class="docutils literal"><span class="pre">E1</span></code> or <code class="docutils literal"><span class="pre">E4</span></code> beacause even though
<code class="docutils literal"><span class="pre">(a</span> <span class="pre">~</span> <span class="pre">Int)</span></code>, <code class="docutils literal"><span class="pre">Int</span></code> is not syntactically equivalent to <code class="docutils literal"><span class="pre">a</span></code>.</li>
<li>We don&#8217;t fold over the argument of <code class="docutils literal"><span class="pre">E3</span></code> because <code class="docutils literal"><span class="pre">a</span></code> is not universally
polymorphic. The <code class="docutils literal"><span class="pre">a</span></code> in <code class="docutils literal"><span class="pre">E3</span></code> is (implicitly) existentially quantified,
so it is not the same as the last type parameter of <code class="docutils literal"><span class="pre">E</span></code>.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="deriving-traversable-instances">
<span id="deriving-traversable"></span><h2>10.6.6. Deriving <code class="docutils literal"><span class="pre">Traversable</span></code> instances<a class="headerlink" href="#deriving-traversable-instances" title="Permalink to this headline">¶</a></h2>
<p>With <a class="reference internal" href="#ghc-flag--XDeriveTraversable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveTraversable</span></code></a>, one can derive <code class="docutils literal"><span class="pre">Traversable</span></code> instances for data
types of kind <code class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. For example, this declaration:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Example</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Ex</span> <span class="n">a</span> <span class="kt">Char</span> <span class="p">(</span><span class="kt">Example</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Example</span> <span class="kt">Char</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">,</span> <span class="kt">Foldable</span><span class="p">,</span> <span class="kt">Traversable</span><span class="p">)</span>
</pre></div>
</div>
<p>would generate the following <code class="docutils literal"><span class="pre">Traversable</span></code> instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Traversable</span> <span class="kt">Example</span> <span class="kr">where</span>
  <span class="n">traverse</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Ex</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">a3</span> <span class="n">a4</span><span class="p">)</span>
    <span class="ow">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="n">b1</span> <span class="n">b3</span> <span class="ow">-&gt;</span> <span class="kt">Ex</span> <span class="n">b1</span> <span class="n">a2</span> <span class="n">b3</span> <span class="n">a4</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">a1</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">traverse</span> <span class="n">f</span> <span class="n">a3</span>
</pre></div>
</div>
<p>The algorithm for <a class="reference internal" href="#ghc-flag--XDeriveTraversable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveTraversable</span></code></a> is adapted from the
<a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> algorithm, but it generates a definition for <code class="docutils literal"><span class="pre">traverse</span></code>
instead of <code class="docutils literal"><span class="pre">fmap</span></code>. In addition, <a class="reference internal" href="#ghc-flag--XDeriveTraversable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveTraversable</span></code></a> filters out
all constructor arguments on the RHS expression whose types do not mention the
last type parameter, since those arguments do not produce any effects in a
traversal. Here are the differences between the generated code in each
extension:</p>
<ol class="arabic simple">
<li>When a bare type variable <code class="docutils literal"><span class="pre">a</span></code> is encountered, both <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> and
<a class="reference internal" href="#ghc-flag--XDeriveTraversable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveTraversable</span></code></a> would generate <code class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></code> for an <code class="docutils literal"><span class="pre">fmap</span></code> and
<code class="docutils literal"><span class="pre">traverse</span></code> definition, respectively.</li>
<li>When a type that is not syntactically equivalent to <code class="docutils literal"><span class="pre">a</span></code>, but which does
contain <code class="docutils literal"><span class="pre">a</span></code>, is encountered, <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> recursively calls
<code class="docutils literal"><span class="pre">fmap</span></code> on it. Similarly, <a class="reference internal" href="#ghc-flag--XDeriveTraversable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveTraversable</span></code></a> would recursively call
<code class="docutils literal"><span class="pre">traverse</span></code>.</li>
<li><a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a> puts everything back together again at the end by
invoking the constructor. <a class="reference internal" href="#ghc-flag--XDeriveTraversable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveTraversable</span></code></a> does something similar,
but it works in an <code class="docutils literal"><span class="pre">Applicative</span></code> context by chaining everything together
with <code class="docutils literal"><span class="pre">(&lt;*&gt;)</span></code>.</li>
</ol>
<p>Unlike <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a>, <a class="reference internal" href="#ghc-flag--XDeriveTraversable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveTraversable</span></code></a> cannot be used on data
types containing a function type on the right-hand side.</p>
<p>For a full specification of the algorithms used in <a class="reference internal" href="#ghc-flag--XDeriveFunctor"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFunctor</span></code></a>,
<a class="reference internal" href="#ghc-flag--XDeriveFoldable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveFoldable</span></code></a>, and <a class="reference internal" href="#ghc-flag--XDeriveTraversable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveTraversable</span></code></a>, see
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DeriveFunctor">this wiki page</a>.</p>
</div>
<div class="section" id="deriving-data-instances">
<span id="deriving-data"></span><h2>10.6.7. Deriving <code class="docutils literal"><span class="pre">Data</span></code> instances<a class="headerlink" href="#deriving-data-instances" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XDeriveDataTypeable">
<code class="descname">-XDeriveDataTypeable</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDeriveDataTypeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable automatic deriving of instances for the <code class="docutils literal"><span class="pre">Data</span></code> typeclass</p>
</dd></dl>

</div>
<div class="section" id="deriving-typeable-instances">
<span id="deriving-typeable"></span><h2>10.6.8. Deriving <code class="docutils literal"><span class="pre">Typeable</span></code> instances<a class="headerlink" href="#deriving-typeable-instances" title="Permalink to this headline">¶</a></h2>
<p>The class <code class="docutils literal"><span class="pre">Typeable</span></code> is very special:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">Typeable</span></code> is kind-polymorphic (see <a class="reference internal" href="#kind-polymorphism"><span>Kind polymorphism and Type-in-Type</span></a>).</p>
</li>
<li><p class="first">GHC has a custom solver for discharging constraints that involve
class <code class="docutils literal"><span class="pre">Typeable</span></code>, and handwritten instances are forbidden. This
ensures that the programmer cannot subvert the type system by writing
bogus instances.</p>
</li>
<li><p class="first">Derived instances of <code class="docutils literal"><span class="pre">Typeable</span></code> may be declared if the
<a class="reference internal" href="#ghc-flag--XDeriveDataTypeable"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveDataTypeable</span></code></a> extension is enabled, but they are ignored,
and they may be reported as an error in a later version of the compiler.</p>
</li>
<li><p class="first">The rules for solving `Typeable` constraints are as follows:</p>
<ul>
<li><p class="first">A concrete type constructor applied to some types.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Typeable</span> <span class="n">t1</span><span class="p">,</span> <span class="o">..</span><span class="p">,</span> <span class="kt">Typeable</span> <span class="n">t_n</span><span class="p">)</span> <span class="ow">=&gt;</span>
  <span class="kt">Typeable</span> <span class="p">(</span><span class="kt">T</span> <span class="n">t1</span> <span class="o">..</span> <span class="n">t_n</span><span class="p">)</span>
</pre></div>
</div>
<p>This rule works for any concrete type constructor, including type
constructors with polymorphic kinds. The only restriction is that
if the type constructor has a polymorphic kind, then it has to be
applied to all of its kinds parameters, and these kinds need to be
concrete (i.e., they cannot mention kind variables).</p>
</li>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kt">A</span> <span class="kr">type</span> <span class="n">variable</span> <span class="n">applied</span> <span class="n">to</span> <span class="n">some</span> <span class="n">types</span><span class="o">.</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Typeable</span> <span class="n">f</span><span class="p">,</span> <span class="kt">Typeable</span> <span class="n">t1</span><span class="p">,</span> <span class="o">..</span><span class="p">,</span> <span class="kt">Typeable</span> <span class="n">t_n</span><span class="p">)</span> <span class="ow">=&gt;</span>
  <span class="kt">Typeable</span> <span class="p">(</span><span class="n">f</span> <span class="n">t1</span> <span class="o">..</span> <span class="n">t_n</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kt">A</span> <span class="n">concrete</span> <span class="kr">type</span> <span class="n">literal</span><span class="o">.</span>
<span class="kr">instance</span> <span class="kt">Typeable</span> <span class="mi">0</span>       <span class="c1">-- Type natural literals</span>
<span class="kr">instance</span> <span class="kt">Typeable</span> <span class="s">&quot;Hello&quot;</span> <span class="c1">-- Type-level symbols</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="deriving-lift-instances">
<span id="deriving-lift"></span><h2>10.6.9. Deriving <code class="docutils literal"><span class="pre">Lift</span></code> instances<a class="headerlink" href="#deriving-lift-instances" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XDeriveLift">
<code class="descname">-XDeriveLift</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDeriveLift" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Enable automatic deriving of instances for the <code class="docutils literal"><span class="pre">Lift</span></code> typeclass for
Template Haskell.</p>
</dd></dl>

<p>The class <code class="docutils literal"><span class="pre">Lift</span></code>, unlike other derivable classes, lives in
<code class="docutils literal"><span class="pre">template-haskell</span></code> instead of <code class="docutils literal"><span class="pre">base</span></code>. Having a data type be an instance of
<code class="docutils literal"><span class="pre">Lift</span></code> permits its values to be promoted to Template Haskell expressions (of
type <code class="docutils literal"><span class="pre">ExpQ</span></code>), which can then be spliced into Haskell source code.</p>
<p>Here is an example of how one can derive <code class="docutils literal"><span class="pre">Lift</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE DeriveLift #-}</span>
<span class="kr">module</span> <span class="nn">Bar</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Language.Haskell.TH.Syntax</span>

<span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="o">|</span> <span class="n">a</span> <span class="kt">:^:</span> <span class="n">a</span> <span class="kr">deriving</span> <span class="kt">Lift</span>

<span class="cm">{-</span>
<span class="cm">instance (Lift a) =&gt; Lift (Foo a) where</span>
<span class="cm">    lift (Foo a)</span>
<span class="cm">    = appE</span>
<span class="cm">        (conE</span>
<span class="cm">            (mkNameG_d &quot;package-name&quot; &quot;Bar&quot; &quot;Foo&quot;))</span>
<span class="cm">        (lift a)</span>
<span class="cm">    lift (u :^: v)</span>
<span class="cm">    = infixApp</span>
<span class="cm">        (lift u)</span>
<span class="cm">        (conE</span>
<span class="cm">            (mkNameG_d &quot;package-name&quot; &quot;Bar&quot; &quot;:^:&quot;))</span>
<span class="cm">        (lift v)</span>
<span class="cm">-}</span>

<span class="c1">-----</span>
<span class="cm">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="kr">module</span> <span class="nn">Baz</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Bar</span>
<span class="kr">import</span> <span class="nn">Language.Haskell.TH.Lift</span>

<span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Foo</span> <span class="kt">String</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="o">$</span><span class="p">(</span><span class="n">lift</span> <span class="o">$</span> <span class="kt">Foo</span> <span class="s">&quot;foo&quot;</span><span class="p">)</span>

<span class="nf">fooExp</span> <span class="ow">::</span> <span class="kt">Lift</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="kt">Exp</span>
<span class="nf">fooExp</span> <span class="n">f</span> <span class="ow">=</span> <span class="p">[</span><span class="o">|</span> <span class="n">f</span> <span class="o">|</span><span class="p">]</span>
</pre></div>
</div>
<p><a class="reference internal" href="#ghc-flag--XDeriveLift"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveLift</span></code></a> also works for certain unboxed types (<code class="docutils literal"><span class="pre">Addr#</span></code>, <code class="docutils literal"><span class="pre">Char#</span></code>,
<code class="docutils literal"><span class="pre">Double#</span></code>, <code class="docutils literal"><span class="pre">Float#</span></code>, <code class="docutils literal"><span class="pre">Int#</span></code>, and <code class="docutils literal"><span class="pre">Word#</span></code>):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE DeriveLift, MagicHash #-}</span>
<span class="kr">module</span> <span class="nn">Unboxed</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">GHC.Exts</span>
<span class="kr">import</span> <span class="nn">Language.Haskell.TH.Syntax</span>

<span class="kr">data</span> <span class="kt">IntHash</span> <span class="ow">=</span> <span class="kt">IntHash</span> <span class="kt">Int</span><span class="o">#</span> <span class="kr">deriving</span> <span class="kt">Lift</span>

<span class="cm">{-</span>
<span class="cm">instance Lift IntHash where</span>
<span class="cm">    lift (IntHash i)</span>
<span class="cm">    = appE</span>
<span class="cm">        (conE</span>
<span class="cm">            (mkNameG_d &quot;package-name&quot; &quot;Unboxed&quot; &quot;IntHash&quot;))</span>
<span class="cm">        (litE</span>
<span class="cm">            (intPrimL (toInteger (I# i))))</span>
<span class="cm">-}</span>
</pre></div>
</div>
</div>
<div class="section" id="generalised-derived-instances-for-newtypes">
<span id="newtype-deriving"></span><h2>10.6.10. Generalised derived instances for newtypes<a class="headerlink" href="#generalised-derived-instances-for-newtypes" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XGeneralisedNewtypeDeriving">
<code class="descname">-XGeneralisedNewtypeDeriving</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XGeneralisedNewtypeDeriving" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--XGeneralizedNewtypeDeriving">
<code class="descname">-XGeneralizedNewtypeDeriving</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XGeneralizedNewtypeDeriving" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable GHC&#8217;s cunning generalised deriving mechanism for <code class="docutils literal"><span class="pre">newtype</span></code>s</p>
</dd></dl>

<p>When you define an abstract type using <code class="docutils literal"><span class="pre">newtype</span></code>, you may want the new
type to inherit some instances from its representation. In Haskell 98,
you can inherit instances of <code class="docutils literal"><span class="pre">Eq</span></code>, <code class="docutils literal"><span class="pre">Ord</span></code>, <code class="docutils literal"><span class="pre">Enum</span></code> and <code class="docutils literal"><span class="pre">Bounded</span></code>
by deriving them, but for any other classes you have to write an
explicit instance declaration. For example, if you define</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Dollars</span> <span class="ow">=</span> <span class="kt">Dollars</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>and you want to use arithmetic on <code class="docutils literal"><span class="pre">Dollars</span></code>, you have to explicitly
define an instance of <code class="docutils literal"><span class="pre">Num</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Num</span> <span class="kt">Dollars</span> <span class="kr">where</span>
  <span class="kt">Dollars</span> <span class="n">a</span> <span class="o">+</span> <span class="kt">Dollars</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Dollars</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>All the instance does is apply and remove the <code class="docutils literal"><span class="pre">newtype</span></code> constructor.
It is particularly galling that, since the constructor doesn&#8217;t appear at
run-time, this instance declaration defines a dictionary which is
<em>wholly equivalent</em> to the <code class="docutils literal"><span class="pre">Int</span></code> dictionary, only slower!</p>
<div class="section" id="generalising-the-deriving-clause">
<span id="generalized-newtype-deriving"></span><h3>10.6.10.1. Generalising the deriving clause<a class="headerlink" href="#generalising-the-deriving-clause" title="Permalink to this headline">¶</a></h3>
<p>GHC now permits such instances to be derived instead, using the flag
<a class="reference internal" href="#ghc-flag--XGeneralizedNewtypeDeriving"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGeneralizedNewtypeDeriving</span></code></a>, so one can write</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Dollars</span> <span class="ow">=</span> <span class="kt">Dollars</span> <span class="p">{</span> <span class="n">getDollars</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="kt">Show</span><span class="p">,</span><span class="kt">Num</span><span class="p">)</span>
</pre></div>
</div>
<p>and the implementation uses the <em>same</em> <code class="docutils literal"><span class="pre">Num</span></code> dictionary for
<code class="docutils literal"><span class="pre">Dollars</span></code> as for <code class="docutils literal"><span class="pre">Int</span></code>. In other words, GHC will generate something that
resembles the following code</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Num</span> <span class="kt">Int</span> <span class="ow">=&gt;</span> <span class="kt">Num</span> <span class="kt">Dollars</span>
</pre></div>
</div>
<p>and then attempt to simplify the <code class="docutils literal"><span class="pre">Num</span> <span class="pre">Int</span></code> context as much as possible.
GHC knows that there is a <code class="docutils literal"><span class="pre">Num</span> <span class="pre">Int</span></code> instance in scope, so it is able to
discharge the <code class="docutils literal"><span class="pre">Num</span> <span class="pre">Int</span></code> constraint, leaving the code that GHC actually
generates</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Num</span> <span class="kt">Dollars</span>
</pre></div>
</div>
<p>One can think of this instance being implemented with the same code as the
<code class="docutils literal"><span class="pre">Num</span> <span class="pre">Int</span></code> instance, but with <code class="docutils literal"><span class="pre">Dollars</span></code> and <code class="docutils literal"><span class="pre">getDollars</span></code> added wherever
necessary in order to make it typecheck. (In practice, GHC uses a somewhat
different approach to code generation. See the <a class="reference internal" href="#precise-gnd-specification"><span>A more precise specification</span></a>
section below for more details.)</p>
<p>We can also derive instances of constructor classes in a similar way.
For example, suppose we have implemented state and failure monad
transformers, such that</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Failure</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>In Haskell 98, we can define a parsing monad by</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Parser</span> <span class="n">tok</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="p">(</span><span class="kt">Failure</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span>
</pre></div>
</div>
<p>which is automatically a monad thanks to the instance declarations
above. With the extension, we can make the parser type abstract, without
needing to write an instance of class <code class="docutils literal"><span class="pre">Monad</span></code>, via</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Parser</span> <span class="n">tok</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">State</span> <span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="p">(</span><span class="kt">Failure</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
                       <span class="kr">deriving</span> <span class="kt">Monad</span>
</pre></div>
</div>
<p>In this case the derived instance declaration is of the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">State</span> <span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="p">(</span><span class="kt">Failure</span> <span class="n">m</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">tok</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that, since <code class="docutils literal"><span class="pre">Monad</span></code> is a constructor class, the instance is a
<em>partial application</em> of the new type, not the entire left hand side. We
can imagine that the type declaration is &#8220;eta-converted&#8221; to generate the
context of the instance declaration.</p>
<p>We can even derive instances of multi-parameter classes, provided the
newtype is the last class parameter. In this case, a &#8220;partial
application&#8221; of the class appears in the <code class="docutils literal"><span class="pre">deriving</span></code> clause. For
example, given the class</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">StateMonad</span> <span class="n">s</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">StateMonad</span> <span class="n">s</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>then we can derive an instance of <code class="docutils literal"><span class="pre">StateMonad</span></code> for <code class="docutils literal"><span class="pre">Parser</span></code> by</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Parser</span> <span class="n">tok</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">State</span> <span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="p">(</span><span class="kt">Failure</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
                       <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Monad</span><span class="p">,</span> <span class="kt">StateMonad</span> <span class="p">[</span><span class="n">tok</span><span class="p">])</span>
</pre></div>
</div>
<p>The derived instance is obtained by completing the application of the
class to the new type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">StateMonad</span> <span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="p">(</span><span class="kt">State</span> <span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="p">(</span><span class="kt">Failure</span> <span class="n">m</span><span class="p">))</span> <span class="ow">=&gt;</span>
         <span class="kt">StateMonad</span> <span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">tok</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>As a result of this extension, all derived instances in newtype
declarations are treated uniformly (and implemented just by reusing the
dictionary for the representation type), <em>except</em> <code class="docutils literal"><span class="pre">Show</span></code> and <code class="docutils literal"><span class="pre">Read</span></code>,
which really behave differently for the newtype and its representation.</p>
</div>
<div class="section" id="a-more-precise-specification">
<span id="precise-gnd-specification"></span><h3>10.6.10.2. A more precise specification<a class="headerlink" href="#a-more-precise-specification" title="Permalink to this headline">¶</a></h3>
<p>A derived instance is derived only for declarations of these forms
(after expansion of any type synonyms)</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">T</span> <span class="n">v1</span><span class="o">..</span><span class="n">vn</span>                   <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">(</span><span class="n">t</span> <span class="n">vk</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="n">vn</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">C</span> <span class="n">t1</span><span class="o">..</span><span class="n">tj</span><span class="p">)</span>
<span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">T</span> <span class="n">s1</span><span class="o">..</span><span class="n">sk</span> <span class="n">vk</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="n">vn</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">(</span><span class="n">t</span> <span class="n">vk</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="n">vn</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">C</span> <span class="n">t1</span><span class="o">..</span><span class="n">tj</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v1..vn</span></code> are type variables, and <code class="docutils literal"><span class="pre">t</span></code>, <code class="docutils literal"><span class="pre">s1..sk</span></code>, <code class="docutils literal"><span class="pre">t1..tj</span></code> are
types.</li>
<li>The <code class="docutils literal"><span class="pre">(C</span> <span class="pre">t1..tj)</span></code> is a partial applications of the class <code class="docutils literal"><span class="pre">C</span></code>,
where the arity of <code class="docutils literal"><span class="pre">C</span></code> is exactly <code class="docutils literal"><span class="pre">j+1</span></code>. That is, <code class="docutils literal"><span class="pre">C</span></code> lacks
exactly one type argument.</li>
<li><code class="docutils literal"><span class="pre">k</span></code> is chosen so that <code class="docutils literal"><span class="pre">C</span> <span class="pre">t1..tj</span> <span class="pre">(T</span> <span class="pre">v1...vk)</span></code> is well-kinded. (Or,
in the case of a <code class="docutils literal"><span class="pre">data</span> <span class="pre">instance</span></code>, so that <code class="docutils literal"><span class="pre">C</span> <span class="pre">t1..tj</span> <span class="pre">(T</span> <span class="pre">s1..sk)</span></code>
is well kinded.)</li>
<li>The type <code class="docutils literal"><span class="pre">t</span></code> is an arbitrary type.</li>
<li>The type variables <code class="docutils literal"><span class="pre">vk+1...vn</span></code> do not occur in the types <code class="docutils literal"><span class="pre">t</span></code>,
<code class="docutils literal"><span class="pre">s1..sk</span></code>, or <code class="docutils literal"><span class="pre">t1..tj</span></code>.</li>
<li><code class="docutils literal"><span class="pre">C</span></code> is not <code class="docutils literal"><span class="pre">Read</span></code>, <code class="docutils literal"><span class="pre">Show</span></code>, <code class="docutils literal"><span class="pre">Typeable</span></code>, or <code class="docutils literal"><span class="pre">Data</span></code>. These
classes should not &#8220;look through&#8221; the type or its constructor. You
can still derive these classes for a newtype, but it happens in the
usual way, not via this new mechanism.</li>
<li>It is safe to coerce each of the methods of <code class="docutils literal"><span class="pre">C</span></code>. That is, the
missing last argument to <code class="docutils literal"><span class="pre">C</span></code> is not used at a nominal role in any
of the <code class="docutils literal"><span class="pre">C</span></code>&#8216;s methods. (See <a class="reference internal" href="#roles"><span>Roles</span></a>.)</li>
<li><code class="docutils literal"><span class="pre">C</span></code> is allowed to have associated type families, provided they meet the
requirements laid out in the section on <a class="reference internal" href="#gnd-and-associated-types"><span>GND and associated types</span></a>.</li>
</ul>
<p>Then the derived instance declaration is of the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="n">t1</span><span class="o">..</span><span class="n">tj</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">t1</span><span class="o">..</span><span class="n">tj</span> <span class="p">(</span><span class="kt">T</span> <span class="n">v1</span><span class="o">...</span><span class="n">vk</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that if <code class="docutils literal"><span class="pre">C</span></code> does not contain any class methods, the instance context
is wholly unnecessary, and as such GHC will instead generate:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="n">t1</span><span class="o">..</span><span class="n">tj</span> <span class="p">(</span><span class="kt">T</span> <span class="n">v1</span><span class="o">..</span><span class="n">vk</span><span class="p">)</span>
</pre></div>
</div>
<p>As an example which does <em>not</em> work, consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">NonMonad</span> <span class="n">m</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">NonMonad</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span> <span class="n">m</span> <span class="n">s</span><span class="p">)</span> <span class="kr">deriving</span> <span class="kt">Monad</span>
</pre></div>
</div>
<p>Here we cannot derive the instance</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">NonMonad</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>because the type variable <code class="docutils literal"><span class="pre">s</span></code> occurs in <code class="docutils literal"><span class="pre">State</span> <span class="pre">s</span> <span class="pre">m</span></code>, and so cannot
be &#8220;eta-converted&#8221; away. It is a good thing that this <code class="docutils literal"><span class="pre">deriving</span></code>
clause is rejected, because <code class="docutils literal"><span class="pre">NonMonad</span> <span class="pre">m</span></code> is not, in fact, a monad &#8212;
for the same reason. Try defining <code class="docutils literal"><span class="pre">&gt;&gt;=</span></code> with the correct type: you
won&#8217;t be able to.</p>
<p>Notice also that the <em>order</em> of class parameters becomes important,
since we can only derive instances for the last one. If the
<code class="docutils literal"><span class="pre">StateMonad</span></code> class above were instead defined as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">StateMonad</span> <span class="n">m</span> <span class="n">s</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>then we would not have been able to derive an instance for the
<code class="docutils literal"><span class="pre">Parser</span></code> type above. We hypothesise that multi-parameter classes
usually have one &#8220;main&#8221; parameter for which deriving new instances is
most interesting.</p>
<p>Lastly, all of this applies only for classes other than <code class="docutils literal"><span class="pre">Read</span></code>,
<code class="docutils literal"><span class="pre">Show</span></code>, <code class="docutils literal"><span class="pre">Typeable</span></code>, and <code class="docutils literal"><span class="pre">Data</span></code>, for which the stock derivation
applies (section 4.3.3. of the Haskell Report). (For the standard
classes <code class="docutils literal"><span class="pre">Eq</span></code>, <code class="docutils literal"><span class="pre">Ord</span></code>, <code class="docutils literal"><span class="pre">Ix</span></code>, and <code class="docutils literal"><span class="pre">Bounded</span></code> it is immaterial
whether the stock method is used or the one described here.)</p>
</div>
<div class="section" id="associated-type-families">
<span id="gnd-and-associated-types"></span><h3>10.6.10.3. Associated type families<a class="headerlink" href="#associated-type-families" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#ghc-flag--XGeneralizedNewtypeDeriving"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGeneralizedNewtypeDeriving</span></code></a> also works for some type classes with
associated type families. Here is an example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">HasRing</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Ring</span> <span class="n">a</span>

<span class="kr">newtype</span> <span class="kt">L1Norm</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">L1Norm</span> <span class="n">a</span>
  <span class="kr">deriving</span> <span class="kt">HasRing</span>
</pre></div>
</div>
<p>The derived <code class="docutils literal"><span class="pre">HasRing</span></code> instance would look like</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">HasRing</span> <span class="p">(</span><span class="kt">L1Norm</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Ring</span> <span class="p">(</span><span class="kt">L1Norm</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Ring</span> <span class="n">a</span>
</pre></div>
</div>
<p>To be precise, if the class being derived is of the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">c_1</span> <span class="n">c_2</span> <span class="o">...</span> <span class="n">c_m</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">T1</span> <span class="n">t1_1</span> <span class="n">t1_2</span> <span class="o">...</span> <span class="n">t1_n</span>
  <span class="o">...</span>
  <span class="kr">type</span> <span class="kt">Tk</span> <span class="n">tk_1</span> <span class="n">tk_2</span> <span class="o">...</span> <span class="n">tk_p</span>
</pre></div>
</div>
<p>and the newtype is of the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">N</span> <span class="n">n_1</span> <span class="n">n_2</span> <span class="o">...</span> <span class="n">n_q</span> <span class="ow">=</span> <span class="kt">MkN</span> <span class="o">&lt;</span><span class="n">rep</span><span class="o">-</span><span class="kr">type</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>then you can derive a <code class="docutils literal"><span class="pre">C</span> <span class="pre">c_1</span> <span class="pre">c_2</span> <span class="pre">...</span> <span class="pre">c_(m-1)</span></code> instance for
<code class="docutils literal"><span class="pre">N</span> <span class="pre">n_1</span> <span class="pre">n_2</span> <span class="pre">...</span> <span class="pre">n_q</span></code>, provided that:</p>
<ul>
<li><p class="first">The type parameter <code class="docutils literal"><span class="pre">c_m</span></code> occurs once in each of the type variables of
<code class="docutils literal"><span class="pre">T1</span></code> through <code class="docutils literal"><span class="pre">Tk</span></code>. Imagine a class where this condition didn&#8217;t hold.
For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Bad</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">B</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">Bad</span> <span class="kt">Int</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">B</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Char</span>

<span class="kr">newtype</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Foo</span> <span class="n">a</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Bad</span> <span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
<p>For the derived <code class="docutils literal"><span class="pre">Bad</span> <span class="pre">Int</span></code> instance, GHC would need to generate something
like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Bad</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">Foo</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">B</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">B</span> <span class="o">???</span>
</pre></div>
</div>
<p>Now we&#8217;re stuck, since we have no way to refer to <code class="docutils literal"><span class="pre">a</span></code> on the right-hand
side of the <code class="docutils literal"><span class="pre">B</span></code> family instance, so this instance doesn&#8217;t really make sense
in a <a class="reference internal" href="#ghc-flag--XGeneralizedNewtypeDeriving"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGeneralizedNewtypeDeriving</span></code></a> setting.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">C</span></code> does not have any associated data families (only type families). To
see why data families are forbidden, imagine the following scenario:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Ex</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">D</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">Ex</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">D</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">DInt</span> <span class="kt">Bool</span>

<span class="kr">newtype</span> <span class="kt">Age</span> <span class="ow">=</span> <span class="kt">MkAge</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="kt">Ex</span>
</pre></div>
</div>
<p>For the derived <code class="docutils literal"><span class="pre">Ex</span></code> instance, GHC would need to generate something like
this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Ex</span> <span class="kt">Age</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">D</span> <span class="kt">Age</span> <span class="ow">=</span> <span class="o">???</span>
</pre></div>
</div>
<p>But it is not clear what GHC would fill in for <code class="docutils literal"><span class="pre">???</span></code>, as each data family
instance must generate fresh data constructors.</p>
</li>
</ul>
<p>If both of these conditions are met, GHC will generate this instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="n">c_1</span> <span class="n">c_2</span> <span class="o">...</span> <span class="n">c_</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span><span class="n">rep</span><span class="o">-</span><span class="kr">type</span><span class="o">&gt;</span> <span class="ow">=&gt;</span>
         <span class="kt">C</span> <span class="n">c_1</span> <span class="n">c_2</span> <span class="o">...</span> <span class="n">c_</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">N</span> <span class="n">n_1</span> <span class="n">n_2</span> <span class="o">...</span> <span class="n">n_q</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">T1</span> <span class="n">t1_1</span> <span class="n">t1_2</span> <span class="o">...</span> <span class="p">(</span><span class="kt">N</span> <span class="n">n_1</span> <span class="n">n_2</span> <span class="o">...</span> <span class="n">n_q</span><span class="p">)</span> <span class="o">...</span> <span class="n">t1_n</span>
     <span class="ow">=</span> <span class="kt">T1</span> <span class="n">t1_1</span> <span class="n">t1_2</span> <span class="o">...</span> <span class="o">&lt;</span><span class="n">rep</span><span class="o">-</span><span class="kr">type</span><span class="o">&gt;</span>          <span class="o">...</span> <span class="n">t1_n</span>
  <span class="o">...</span>
  <span class="kr">type</span> <span class="kt">Tk</span> <span class="n">tk_1</span> <span class="n">tk_2</span> <span class="o">...</span> <span class="p">(</span><span class="kt">N</span> <span class="n">n_1</span> <span class="n">n_2</span> <span class="o">...</span> <span class="n">n_q</span><span class="p">)</span> <span class="o">...</span> <span class="n">tk_p</span>
     <span class="ow">=</span> <span class="kt">Tk</span> <span class="n">tk_1</span> <span class="n">tk_2</span> <span class="o">...</span> <span class="o">&lt;</span><span class="n">rep</span><span class="o">-</span><span class="kr">type</span><span class="o">&gt;</span>          <span class="o">...</span> <span class="n">tk_p</span>
</pre></div>
</div>
<p>Again, if <code class="docutils literal"><span class="pre">C</span></code> contains no class methods, the instance context will be
redundant, so GHC will instead generate
<code class="docutils literal"><span class="pre">instance</span> <span class="pre">C</span> <span class="pre">c_1</span> <span class="pre">c_2</span> <span class="pre">...</span> <span class="pre">c_(m-1)</span> <span class="pre">(N</span> <span class="pre">n_1</span> <span class="pre">n_2</span> <span class="pre">...</span> <span class="pre">n_q)</span></code>.</p>
<p>Beware that in some cases, you may need to enable the
<a class="reference internal" href="#ghc-flag--XUndecidableInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUndecidableInstances</span></code></a> extension in order to use this feature.
Here&#8217;s a pathological case that illustrates why this might happen:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">T</span> <span class="n">a</span>

<span class="kr">newtype</span> <span class="kt">Loop</span> <span class="ow">=</span> <span class="kt">MkLoop</span> <span class="kt">Loop</span>
  <span class="kr">deriving</span> <span class="kt">C</span>
</pre></div>
</div>
<p>This will generate the derived instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="kt">Loop</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">T</span> <span class="kt">Loop</span> <span class="ow">=</span> <span class="kt">T</span> <span class="kt">Loop</span>
</pre></div>
</div>
<p>Here, it is evident that attempting to use the type <code class="docutils literal"><span class="pre">T</span> <span class="pre">Loop</span></code> will throw the
typechecker into an infinite loop, as its definition recurses endlessly. In
other cases, you might need to enable <a class="reference internal" href="#ghc-flag--XUndecidableInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUndecidableInstances</span></code></a> even
if the generated code won&#8217;t put the typechecker into a loop. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">C</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Int</span>

<span class="kr">newtype</span> <span class="kt">MyInt</span> <span class="ow">=</span> <span class="kt">MyInt</span> <span class="kt">Int</span>
  <span class="kr">deriving</span> <span class="kt">C</span>
</pre></div>
</div>
<p>This will generate the derived instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="kt">MyInt</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">T</span> <span class="kt">MyInt</span> <span class="ow">=</span> <span class="kt">T</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>Although typechecking <code class="docutils literal"><span class="pre">T</span> <span class="pre">MyInt</span></code> will terminate, GHC&#8217;s termination checker
isn&#8217;t sophisticated enough to determine this, so you&#8217;ll need to enable
<a class="reference internal" href="#ghc-flag--XUndecidableInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUndecidableInstances</span></code></a> in order to use this derived instance. If
you do go down this route, make sure you can convince yourself that all of
the type family instances you&#8217;re deriving will eventually terminate if used!</p>
</div>
</div>
<div class="section" id="deriving-any-other-class">
<span id="derive-any-class"></span><h2>10.6.11. Deriving any other class<a class="headerlink" href="#deriving-any-other-class" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XDeriveAnyClass">
<code class="descname">-XDeriveAnyClass</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDeriveAnyClass" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.10.1</td>
</tr>
</tbody>
</table>
<p>Allow use of any typeclass in <code class="docutils literal"><span class="pre">deriving</span></code> clauses.</p>
</dd></dl>

<p>With <a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a> you can derive any other class. The compiler
will simply generate an instance declaration with no explicitly-defined
methods.
This is
mostly useful in classes whose <a class="reference external" href="#minimal-pragma">minimal set</a> is
empty, and especially when writing
<a class="reference external" href="#generic-programming">generic functions</a>.</p>
<p>As an example, consider a simple pretty-printer class <code class="docutils literal"><span class="pre">SPretty</span></code>, which outputs
pretty strings:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE DefaultSignatures, DeriveAnyClass #-}</span>

<span class="kr">class</span> <span class="kt">SPretty</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">sPpr</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
  <span class="kr">default</span> <span class="n">sPpr</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
  <span class="n">sPpr</span> <span class="ow">=</span> <span class="n">show</span>
</pre></div>
</div>
<p>If a user does not provide a manual implementation for <code class="docutils literal"><span class="pre">sPpr</span></code>, then it will
default to <code class="docutils literal"><span class="pre">show</span></code>. Now we can leverage the <a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a> extension to
easily implement a <code class="docutils literal"><span class="pre">SPretty</span></code> instance for a new data type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="kt">Foo</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">SPretty</span><span class="p">)</span>
</pre></div>
</div>
<p>The above code is equivalent to:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="kt">Foo</span> <span class="kr">deriving</span> <span class="kt">Show</span>
<span class="kr">instance</span> <span class="kt">SPretty</span> <span class="kt">Foo</span>
</pre></div>
</div>
<p>That is, an <code class="docutils literal"><span class="pre">SPretty</span> <span class="pre">Foo</span></code> instance will be created with empty implementations
for all methods. Since we are using <a class="reference internal" href="#ghc-flag--XDefaultSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDefaultSignatures</span></code></a> in this example, a
default implementation of <code class="docutils literal"><span class="pre">sPpr</span></code> is filled in automatically.</p>
<p>Note the following details</p>
<ul>
<li><p class="first">In case you try to derive some
class on a newtype, and <a class="reference internal" href="#ghc-flag--XGeneralizedNewtypeDeriving"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGeneralizedNewtypeDeriving</span></code></a> is also on,
<a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a> takes precedence.</p>
</li>
<li><p class="first">The instance context is determined by the type signatures of the derived
class&#8217;s methods. For instance, if the class is:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">bar</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
  <span class="kr">default</span> <span class="n">bar</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
  <span class="n">bar</span> <span class="ow">=</span> <span class="n">show</span>

  <span class="n">baz</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
  <span class="kr">default</span> <span class="n">baz</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
  <span class="n">baz</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">==</span> <span class="kt">EQ</span>
</pre></div>
</div>
<p>And you attempt to derive it using <a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Eq</span>   <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span>   <span class="p">(</span><span class="kt">Option</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Ord</span>  <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Ord</span>  <span class="p">(</span><span class="kt">Option</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Option</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>

<span class="kr">data</span> <span class="kt">Option</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">None</span> <span class="o">|</span> <span class="kt">Some</span> <span class="n">a</span> <span class="kr">deriving</span> <span class="kt">Foo</span>
</pre></div>
</div>
<p>Then the derived <code class="docutils literal"><span class="pre">Foo</span></code> instance will be:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Foo</span> <span class="p">(</span><span class="kt">Option</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the default type signatures for <code class="docutils literal"><span class="pre">bar</span></code> and <code class="docutils literal"><span class="pre">baz</span></code> require <code class="docutils literal"><span class="pre">Show</span> <span class="pre">a</span></code>
and <code class="docutils literal"><span class="pre">Ord</span> <span class="pre">a</span></code> constraints, respectively.</p>
<p>Constraints on the non-default type signatures can play a role in inferring
the instance context as well. For example, if you have this class:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">HigherEq</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">==#</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
  <span class="kr">default</span> <span class="p">(</span><span class="o">==#</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
  <span class="n">x</span> <span class="o">==#</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>And you tried to derive an instance for it:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Option</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">data</span> <span class="kt">Option</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">None</span> <span class="o">|</span> <span class="kt">Some</span> <span class="n">a</span> <span class="kr">deriving</span> <span class="kt">HigherEq</span>
</pre></div>
</div>
<p>Then it will fail with an error to the effect of:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">arising</span> <span class="n">from</span> <span class="n">the</span> <span class="n">&#39;deriving&#39;</span> <span class="n">clause</span> <span class="kr">of</span> <span class="n">a</span> <span class="kr">data</span> <span class="kr">type</span> <span class="n">declaration</span>
</pre></div>
</div>
<p>That is because we require an <code class="docutils literal"><span class="pre">Eq</span> <span class="pre">(Option</span> <span class="pre">a)</span></code> instance from the default
type signature for <code class="docutils literal"><span class="pre">(==#)</span></code>, which in turn requires an <code class="docutils literal"><span class="pre">Eq</span> <span class="pre">a</span></code> instance,
which we don&#8217;t have in scope. But if you tweak the definition of
<code class="docutils literal"><span class="pre">HigherEq</span></code> slightly:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">HigherEq</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">==#</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
  <span class="kr">default</span> <span class="p">(</span><span class="o">==#</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
  <span class="n">x</span> <span class="o">==#</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Then it becomes possible to derive a <code class="docutils literal"><span class="pre">HigherEq</span> <span class="pre">Option</span></code> instance. Note that
the only difference is that now the non-default type signature for <code class="docutils literal"><span class="pre">(==#)</span></code>
brings in an <code class="docutils literal"><span class="pre">Eq</span> <span class="pre">a</span></code> constraint. Constraints from non-default type
signatures never appear in the derived instance context itself, but they can
be used to discharge obligations that are demanded by the default type
signatures. In the example above, the default type signature demanded an
<code class="docutils literal"><span class="pre">Eq</span> <span class="pre">a</span></code> instance, and the non-default signature was able to satisfy that
request, so the derived instance is simply:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">HigherEq</span> <span class="kt">Option</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a> can be used with partially applied classes,
such as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MKT</span> <span class="n">a</span> <span class="kr">deriving</span><span class="p">(</span> <span class="kt">D</span> <span class="kt">Int</span> <span class="p">)</span>
</pre></div>
</div>
<p>which generates</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">D</span> <span class="kt">Int</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">D</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="p">{}</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a> can be used to fill in default instances for
associated type families:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE DeriveAnyClass, TypeFamilies #-}</span>

<span class="kr">class</span> <span class="kt">Sizable</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Size</span> <span class="n">a</span>
  <span class="kr">type</span> <span class="kt">Size</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Int</span>

<span class="kr">data</span> <span class="kt">Bar</span> <span class="ow">=</span> <span class="kt">Bar</span> <span class="kr">deriving</span> <span class="kt">Sizable</span>

<span class="nf">doubleBarSize</span> <span class="ow">::</span> <span class="kt">Size</span> <span class="kt">Bar</span> <span class="ow">-&gt;</span> <span class="kt">Size</span> <span class="kt">Bar</span>
<span class="nf">doubleBarSize</span> <span class="n">s</span> <span class="ow">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">deriving(</span> <span class="pre">Sizable</span> <span class="pre">)</span></code> is equivalent to saying</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Sizeable</span> <span class="kt">Bar</span> <span class="kr">where</span> <span class="p">{}</span>
</pre></div>
</div>
<p>and then the normal rules for filling in associated types from the
default will apply, making <code class="docutils literal"><span class="pre">Size</span> <span class="pre">Bar</span></code> equal to <code class="docutils literal"><span class="pre">Int</span></code>.</p>
</li>
</ul>
</div>
<div class="section" id="deriving-strategies">
<span id="id23"></span><h2>10.6.12. Deriving strategies<a class="headerlink" href="#deriving-strategies" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XDerivingStrategies">
<code class="descname">-XDerivingStrategies</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDerivingStrategies" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow multiple <code class="docutils literal"><span class="pre">deriving</span></code>, each optionally qualified with a <em>strategy</em>.</p>
</dd></dl>

<p>In most scenarios, every <code class="docutils literal"><span class="pre">deriving</span></code> statement generates a typeclass instance
in an unambiguous fashion. There is a corner case, however, where
simultaneously enabling both the <a class="reference internal" href="#ghc-flag--XGeneralizedNewtypeDeriving"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGeneralizedNewtypeDeriving</span></code></a> and
<a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a> extensions can make deriving become ambiguous.
Consider the following example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE DeriveAnyClass, GeneralizedNewtypeDeriving #-}</span>
<span class="kr">newtype</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="kt">MkFoo</span> <span class="kt">Bar</span> <span class="kr">deriving</span> <span class="kt">C</span>
</pre></div>
</div>
<p>One could either pick the <code class="docutils literal"><span class="pre">DeriveAnyClass</span></code> approach to deriving <code class="docutils literal"><span class="pre">C</span></code> or the
<code class="docutils literal"><span class="pre">GeneralizedNewtypeDeriving</span></code> approach to deriving <code class="docutils literal"><span class="pre">C</span></code>, both of which would
be equally as valid. GHC defaults to favoring <code class="docutils literal"><span class="pre">DeriveAnyClass</span></code> in such a
dispute, but this is not a satisfying solution, since that leaves users unable
to use both language extensions in a single module.</p>
<p>To make this more robust, GHC has a notion of deriving strategies, which allow
the user to explicitly request which approach to use when deriving an instance.
To enable this feature, one must enable the <a class="reference internal" href="#ghc-flag--XDerivingStrategies"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDerivingStrategies</span></code></a>
language extension. A deriving strategy can be specified in a deriving
clause</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="kt">MkFoo</span> <span class="kt">Bar</span>
  <span class="kr">deriving</span> <span class="kr">newtype</span> <span class="kt">C</span>
</pre></div>
</div>
<p>Or in a standalone deriving declaration</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">deriving</span> <span class="n">anyclass</span> <span class="kr">instance</span> <span class="kt">C</span> <span class="kt">Foo</span>
</pre></div>
</div>
<p><a class="reference internal" href="#ghc-flag--XDerivingStrategies"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDerivingStrategies</span></code></a> also allows the use of multiple deriving
clauses per data declaration so that a user can derive some instance with
one deriving strategy and other instances with another deriving strategy.
For example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Baz</span> <span class="ow">=</span> <span class="kt">Baz</span> <span class="kt">Quux</span>
  <span class="kr">deriving</span>          <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="n">stock</span>    <span class="p">(</span><span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="kr">newtype</span>  <span class="p">(</span><span class="kt">Num</span><span class="p">,</span> <span class="kt">Floating</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="kt">C</span>
</pre></div>
</div>
<p>Currently, the deriving strategies are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">stock</span></code>: Have GHC implement a &#8220;standard&#8221; instance for a data type,
if possible (e.g., <code class="docutils literal"><span class="pre">Eq</span></code>, <code class="docutils literal"><span class="pre">Ord</span></code>, <code class="docutils literal"><span class="pre">Generic</span></code>, <code class="docutils literal"><span class="pre">Data</span></code>, <code class="docutils literal"><span class="pre">Functor</span></code>, etc.)</li>
<li><code class="docutils literal"><span class="pre">anyclass</span></code>: Use <a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a></li>
<li><code class="docutils literal"><span class="pre">newtype</span></code>: Use <a class="reference internal" href="#ghc-flag--XGeneralizedNewtypeDeriving"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGeneralizedNewtypeDeriving</span></code></a></li>
</ul>
<p>If an explicit deriving strategy is not given, GHC has an algorithm for
determining how it will actually derive an instance. For brevity, the algorithm
is omitted here. You can read the full algorithm on the
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DerivingStrategies">GHC Wiki</a>.</p>
</div>
</div>
<div class="section" id="pattern-synonyms">
<span id="id24"></span><h1>10.7. Pattern synonyms<a class="headerlink" href="#pattern-synonyms" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XPatternSynonyms">
<code class="descname">-XPatternSynonyms</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XPatternSynonyms" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.8.1</td>
</tr>
</tbody>
</table>
<p>Allow the definition of pattern synonyms.</p>
</dd></dl>

<p>Pattern synonyms are enabled by the flag <a class="reference internal" href="#ghc-flag--XPatternSynonyms"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPatternSynonyms</span></code></a>, which is
required for defining them, but <em>not</em> for using them. More information and
examples of view patterns can be found on the <cite>Wiki page &lt;PatternSynonyms&gt;</cite>.</p>
<p>Pattern synonyms enable giving names to parametrized pattern schemes.
They can also be thought of as abstract constructors that don&#8217;t have a
bearing on data representation. For example, in a programming language
implementation, we might represent types of the language as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">App</span> <span class="kt">String</span> <span class="p">[</span><span class="kt">Type</span><span class="p">]</span>
</pre></div>
</div>
<p>Here are some examples of using said representation. Consider a few
types of the <code class="docutils literal"><span class="pre">Type</span></code> universe encoded like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">App</span> <span class="s">&quot;-&gt;&quot;</span> <span class="p">[</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">]</span>          <span class="c1">-- t1 -&gt; t2</span>
<span class="kt">App</span> <span class="s">&quot;Int&quot;</span> <span class="kt">[]</span>               <span class="c1">-- Int</span>
<span class="kt">App</span> <span class="s">&quot;Maybe&quot;</span> <span class="p">[</span><span class="kt">App</span> <span class="s">&quot;Int&quot;</span> <span class="kt">[]</span><span class="p">]</span> <span class="c1">-- Maybe Int</span>
</pre></div>
</div>
<p>This representation is very generic in that no types are given special
treatment. However, some functions might need to handle some known types
specially, for example the following two functions collect all argument
types of (nested) arrow types, and recognize the <code class="docutils literal"><span class="pre">Int</span></code> type,
respectively:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">collectArgs</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Type</span><span class="p">]</span>
<span class="nf">collectArgs</span> <span class="p">(</span><span class="kt">App</span> <span class="s">&quot;-&gt;&quot;</span> <span class="p">[</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">])</span> <span class="ow">=</span> <span class="n">t1</span> <span class="kt">:</span> <span class="n">collectArgs</span> <span class="n">t2</span>
<span class="nf">collectArgs</span> <span class="kr">_</span>                   <span class="ow">=</span> <span class="kt">[]</span>

<span class="nf">isInt</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isInt</span> <span class="p">(</span><span class="kt">App</span> <span class="s">&quot;Int&quot;</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isInt</span> <span class="kr">_</span>              <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Matching on <code class="docutils literal"><span class="pre">App</span></code> directly is both hard to read and error prone to
write. And the situation is even worse when the matching is nested:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">isIntEndo</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isIntEndo</span> <span class="p">(</span><span class="kt">App</span> <span class="s">&quot;-&gt;&quot;</span> <span class="p">[</span><span class="kt">App</span> <span class="s">&quot;Int&quot;</span> <span class="kt">[]</span><span class="p">,</span> <span class="kt">App</span> <span class="s">&quot;Int&quot;</span> <span class="kt">[]</span><span class="p">])</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isIntEndo</span> <span class="kr">_</span>                                       <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Pattern synonyms permit abstracting from the representation to expose
matchers that behave in a constructor-like manner with respect to
pattern matching. We can create pattern synonyms for the known types we
care about, without committing the representation to them (note that
these don&#8217;t have to be defined in the same module as the <code class="docutils literal"><span class="pre">Type</span></code> type):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="kt">Arrow</span> <span class="n">t1</span> <span class="n">t2</span> <span class="ow">=</span> <span class="kt">App</span> <span class="s">&quot;-&gt;&quot;</span>    <span class="p">[</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">]</span>
<span class="nf">pattern</span> <span class="kt">Int</span>         <span class="ow">=</span> <span class="kt">App</span> <span class="s">&quot;Int&quot;</span>   <span class="kt">[]</span>
<span class="nf">pattern</span> <span class="kt">Maybe</span> <span class="n">t</span>     <span class="ow">=</span> <span class="kt">App</span> <span class="s">&quot;Maybe&quot;</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
</pre></div>
</div>
<p>Which enables us to rewrite our functions in a much cleaner style:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">collectArgs</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Type</span><span class="p">]</span>
<span class="nf">collectArgs</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">t1</span> <span class="kt">:</span> <span class="n">collectArgs</span> <span class="n">t2</span>
<span class="nf">collectArgs</span> <span class="kr">_</span>             <span class="ow">=</span> <span class="kt">[]</span>

<span class="nf">isInt</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isInt</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isInt</span> <span class="kr">_</span>   <span class="ow">=</span> <span class="kt">False</span>

<span class="nf">isIntEndo</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isIntEndo</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="kt">Int</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isIntEndo</span> <span class="kr">_</span>               <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>In general there are three kinds of pattern synonyms. Unidirectional,
bidirectional and explicitly bidirectional. The examples given so far are
examples of bidirectional pattern synonyms. A bidirectional synonym
behaves the same as an ordinary data constructor. We can use it in a pattern
context to deconstruct values and in an expression context to construct values.
For example, we can construct the value <cite>intEndo</cite> using the pattern synonyms
<cite>Arrow</cite> and <cite>Int</cite> as defined previously.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">intEndo</span> <span class="ow">::</span> <span class="kt">Type</span>
<span class="nf">intEndo</span> <span class="ow">=</span> <span class="kt">Arrow</span> <span class="kt">Int</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>This example is equivalent to the much more complicated construction if we had
directly used the <cite>Type</cite> constructors.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">intEndo</span> <span class="ow">::</span> <span class="kt">Type</span>
<span class="nf">intEndo</span> <span class="ow">=</span> <span class="kt">App</span> <span class="s">&quot;-&gt;&quot;</span> <span class="p">[</span><span class="kt">App</span> <span class="s">&quot;Int&quot;</span> <span class="kt">[]</span><span class="p">,</span> <span class="kt">App</span> <span class="s">&quot;Int&quot;</span> <span class="kt">[]</span><span class="p">]</span>
</pre></div>
</div>
<p>Unidirectional synonyms can only be used in a pattern context and are
defined as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="kt">Head</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span>
</pre></div>
</div>
<p>In this case, <code class="docutils literal"><span class="pre">Head</span></code> ⟨x⟩ cannot be used in expressions, only patterns,
since it wouldn&#8217;t specify a value for the ⟨xs⟩ on the right-hand side. However,
we can define an explicitly bidirectional pattern synonym by separately
specifying how to construct and deconstruct a type. The syntax for
doing this is as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="kt">HeadC</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span> <span class="kr">where</span>
  <span class="kt">HeadC</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>We can then use <code class="docutils literal"><span class="pre">HeadC</span></code> in both expression and pattern contexts. In a pattern
context it will match the head of any list with length at least one. In an
expression context it will construct a singleton list.</p>
<p>The table below summarises where each kind of pattern synonym can be used.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="22%" />
<col width="21%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Context</th>
<th class="head">Unidirectional</th>
<th class="head">Bidirectional</th>
<th class="head">Explicitly Bidirectional</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Pattern</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="row-odd"><td>Expression</td>
<td>No</td>
<td>Yes (Inferred)</td>
<td>Yes (Explicit)</td>
</tr>
</tbody>
</table>
<div class="section" id="record-pattern-synonyms">
<span id="record-patsyn"></span><h2>10.7.1. Record Pattern Synonyms<a class="headerlink" href="#record-pattern-synonyms" title="Permalink to this headline">¶</a></h2>
<p>It is also possible to define pattern synonyms which behave just like record
constructors. The syntax for doing this is as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="kt">Point</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">pattern</span> <span class="kt">Point</span><span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">}</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>The idea is that we can then use <code class="docutils literal"><span class="pre">Point</span></code> just as if we had defined a new
datatype <code class="docutils literal"><span class="pre">MyPoint</span></code> with two fields <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">MyPoint</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">y</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>
</pre></div>
</div>
<p>Whilst a normal pattern synonym can be used in two ways, there are then seven
ways in which to use <code class="docutils literal"><span class="pre">Point</span></code>. Precisely the ways in which a normal record
constructor can be used.</p>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Usage</th>
<th class="head">Example</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>As a constructor</td>
<td><code class="docutils literal"><span class="pre">zero</span> <span class="pre">=</span> <span class="pre">Point</span> <span class="pre">0</span> <span class="pre">0</span></code></td>
</tr>
<tr class="row-odd"><td>As a constructor with record syntax</td>
<td><code class="docutils literal"><span class="pre">zero</span> <span class="pre">=</span> <span class="pre">Point</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">0}</span></code></td>
</tr>
<tr class="row-even"><td>In a pattern context</td>
<td><code class="docutils literal"><span class="pre">isZero</span> <span class="pre">(Point</span> <span class="pre">0</span> <span class="pre">0)</span> <span class="pre">=</span> <span class="pre">True</span></code></td>
</tr>
<tr class="row-odd"><td>In a pattern context with record syntax</td>
<td><code class="docutils literal"><span class="pre">isZero</span> <span class="pre">(Point</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">}</span></code></td>
</tr>
<tr class="row-even"><td>In a pattern context with field puns</td>
<td><code class="docutils literal"><span class="pre">getX</span> <span class="pre">(Point</span> <span class="pre">{x})</span> <span class="pre">=</span> <span class="pre">x</span></code></td>
</tr>
<tr class="row-odd"><td>In a record update</td>
<td><code class="docutils literal"><span class="pre">(0,</span> <span class="pre">0)</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">}</span> <span class="pre">==</span> <span class="pre">(1,0)</span></code></td>
</tr>
<tr class="row-even"><td>Using record selectors</td>
<td><code class="docutils literal"><span class="pre">x</span> <span class="pre">(0,0)</span> <span class="pre">==</span> <span class="pre">0</span></code></td>
</tr>
</tbody>
</table>
<p>For a unidirectional record pattern synonym we define record selectors but do
not allow record updates or construction.</p>
<p>The syntax and semantics of pattern synonyms are elaborated in the
following subsections.
There are also lots more details in the <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf">paper</a>.</p>
<p>See the <a class="reference external" href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms">Wiki page</a> for more
details.</p>
</div>
<div class="section" id="syntax-and-scoping-of-pattern-synonyms">
<h2>10.7.2. Syntax and scoping of pattern synonyms<a class="headerlink" href="#syntax-and-scoping-of-pattern-synonyms" title="Permalink to this headline">¶</a></h2>
<p>A pattern synonym declaration can be either unidirectional,
bidirectional or explicitly bidirectional.
The syntax for unidirectional pattern synonyms is:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="n">pat_lhs</span> <span class="ow">&lt;-</span> <span class="n">pat</span>
</pre></div>
</div>
<p>the syntax for bidirectional pattern synonyms is:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="n">pat_lhs</span> <span class="ow">=</span> <span class="n">pat</span>
</pre></div>
</div>
<p>and the syntax for explicitly bidirectional pattern synonyms is:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="n">pat_lhs</span> <span class="ow">&lt;-</span> <span class="n">pat</span> <span class="kr">where</span>
  <span class="n">pat_lhs</span> <span class="ow">=</span> <span class="n">expr</span>
</pre></div>
</div>
<p>We can define either prefix, infix or record pattern synonyms by modifying
the form of <cite>pat_lhs</cite>. The syntax for these is as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Prefix</td>
<td><code class="docutils literal"><span class="pre">Name</span> <span class="pre">args</span></code></td>
</tr>
<tr class="row-even"><td>Infix</td>
<td><code class="docutils literal"><span class="pre">arg1</span> <span class="pre">`Name`</span> <span class="pre">arg2</span></code>
or <code class="docutils literal"><span class="pre">arg1</span> <span class="pre">op</span> <span class="pre">arg2</span></code></td>
</tr>
<tr class="row-odd"><td>Record</td>
<td><code class="docutils literal"><span class="pre">Name{arg1,arg2,...,argn}</span></code></td>
</tr>
</tbody>
</table>
<p>Pattern synonym declarations can only occur in the top level of a
module. In particular, they are not allowed as local definitions.</p>
<p>The variables in the left-hand side of the definition are bound by the
pattern on the right-hand side. For bidirectional pattern
synonyms, all the variables of the right-hand side must also occur on
the left-hand side; also, wildcard patterns and view patterns are not
allowed. For unidirectional and explicitly bidirectional pattern
synonyms, there is no restriction on the right-hand side pattern.</p>
<p>Pattern synonyms cannot be defined recursively.</p>
<p><a class="reference internal" href="#complete-pragma"><span>COMPLETE pragmas</span></a> can be specified in order to tell
the pattern match exhaustiveness checker that a set of pattern synonyms is
complete.</p>
</div>
<div class="section" id="import-and-export-of-pattern-synonyms">
<span id="patsyn-impexp"></span><h2>10.7.3. Import and export of pattern synonyms<a class="headerlink" href="#import-and-export-of-pattern-synonyms" title="Permalink to this headline">¶</a></h2>
<p>The name of the pattern synonym is in the same namespace as proper data
constructors. Like normal data constructors, pattern synonyms can be imported
and exported through association with a type constructor or independently.</p>
<p>To export them on their own, in an export or import specification, you must
prefix pattern names with the <code class="docutils literal"><span class="pre">pattern</span></code> keyword, e.g.:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Example</span> <span class="p">(</span><span class="nf">pattern</span> <span class="kt">Zero</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">data</span> <span class="kt">MyNum</span> <span class="ow">=</span> <span class="kt">MkNum</span> <span class="kt">Int</span>

<span class="nf">pattern</span> <span class="kt">Zero</span> <span class="ow">::</span> <span class="kt">MyNum</span>
<span class="nf">pattern</span> <span class="kt">Zero</span> <span class="ow">=</span> <span class="kt">MkNum</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Without the <code class="docutils literal"><span class="pre">pattern</span></code> prefix, <code class="docutils literal"><span class="pre">Zero</span></code> would be interpreted as a
type constructor in the export list.</p>
<p>You may also use the <code class="docutils literal"><span class="pre">pattern</span></code> keyword in an import/export
specification to import or export an ordinary data constructor. For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.Maybe</span><span class="p">(</span> <span class="n">pattern</span> <span class="kt">Just</span> <span class="p">)</span>
</pre></div>
</div>
<p>would bring into scope the data constructor <code class="docutils literal"><span class="pre">Just</span></code> from the <code class="docutils literal"><span class="pre">Maybe</span></code>
type, without also bringing the type constructor <code class="docutils literal"><span class="pre">Maybe</span></code> into scope.</p>
<p>To bundle a pattern synonym with a type constructor, we list the pattern
synonym in the export list of a module which exports the type constructor.
For example, to bundle <code class="docutils literal"><span class="pre">Zero</span></code> with <code class="docutils literal"><span class="pre">MyNum</span></code> we could write the following:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Example</span> <span class="p">(</span> <span class="kt">MyNum</span><span class="p">(</span><span class="kt">Zero</span><span class="p">)</span> <span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>If a module was then to import <code class="docutils literal"><span class="pre">MyNum</span></code> from <code class="docutils literal"><span class="pre">Example</span></code>, it would also import
the pattern synonym <code class="docutils literal"><span class="pre">Zero</span></code>.</p>
<p>It is also possible to use the special token <code class="docutils literal"><span class="pre">..</span></code> in an export list to mean
all currently bundled constructors. For example, we could write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Example</span> <span class="p">(</span> <span class="kt">MyNum</span><span class="p">(</span><span class="o">..</span><span class="p">,</span> <span class="kt">Zero</span><span class="p">)</span> <span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>in which case, <code class="docutils literal"><span class="pre">Example</span></code> would export the type constructor <code class="docutils literal"><span class="pre">MyNum</span></code> with
the data constructor <code class="docutils literal"><span class="pre">MkNum</span></code> and also the pattern synonym <code class="docutils literal"><span class="pre">Zero</span></code>.</p>
<p>Bundled pattern synonyms are type checked to ensure that they are of the same
type as the type constructor which they are bundled with. A pattern synonym
<code class="docutils literal"><span class="pre">P</span></code> can not be bundled with a type constructor <code class="docutils literal"><span class="pre">T</span></code> if <code class="docutils literal"><span class="pre">P</span></code>&#8216;s type is visibly
incompatible with <code class="docutils literal"><span class="pre">T</span></code>.</p>
<p>A module which imports <code class="docutils literal"><span class="pre">MyNum(..)</span></code> from <code class="docutils literal"><span class="pre">Example</span></code> and then re-exports
<code class="docutils literal"><span class="pre">MyNum(..)</span></code> will also export any pattern synonyms bundled with <code class="docutils literal"><span class="pre">MyNum</span></code> in
<code class="docutils literal"><span class="pre">Example</span></code>. A more complete specification can be found on the
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms/AssociatingSynonyms">wiki.</a></p>
</div>
<div class="section" id="typing-of-pattern-synonyms">
<span id="patsyn-typing"></span><h2>10.7.4. Typing of pattern synonyms<a class="headerlink" href="#typing-of-pattern-synonyms" title="Permalink to this headline">¶</a></h2>
<p>Given a pattern synonym definition of the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="kt">P</span> <span class="n">var1</span> <span class="n">var2</span> <span class="o">...</span> <span class="n">varN</span> <span class="ow">&lt;-</span> <span class="n">pat</span>
</pre></div>
</div>
<p>it is assigned a <em>pattern type</em> of the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="kt">P</span> <span class="ow">::</span> <span class="kt">CReq</span> <span class="ow">=&gt;</span> <span class="kt">CProv</span> <span class="ow">=&gt;</span> <span class="n">t1</span> <span class="ow">-&gt;</span> <span class="n">t2</span> <span class="ow">-&gt;</span> <span class="o">...</span> <span class="ow">-&gt;</span> <span class="n">tN</span> <span class="ow">-&gt;</span> <span class="n">t</span>
</pre></div>
</div>
<p>where ⟨CReq⟩ and ⟨CProv⟩ are type contexts, and ⟨t1⟩, ⟨t2⟩, ..., ⟨tN⟩
and ⟨t⟩ are types. Notice the unusual form of the type, with two
contexts ⟨CReq⟩ and ⟨CProv⟩:</p>
<ul class="simple">
<li>⟨CReq⟩ are the constraints <em>required</em> to match the pattern.</li>
<li>⟨CProv⟩ are the constraints <em>made available (provided)</em> by a
successful pattern match.</li>
</ul>
<p>For example, consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">MkT</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">a</span>

<span class="nf">f1</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">f1</span> <span class="p">(</span><span class="kt">MkT</span> <span class="mi">42</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">x</span>

<span class="nf">pattern</span> <span class="kt">ExNumPat</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">a</span>
<span class="nf">pattern</span> <span class="kt">ExNumPat</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="mi">42</span> <span class="n">x</span>

<span class="nf">f2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">f2</span> <span class="p">(</span><span class="kt">ExNumPat</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">x</span>
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">f1</span></code> does not use pattern synonyms. To match against the numeric
pattern <code class="docutils literal"><span class="pre">42</span></code> <em>requires</em> the caller to satisfy the constraints
<code class="docutils literal"><span class="pre">(Num</span> <span class="pre">a,</span> <span class="pre">Eq</span> <span class="pre">a)</span></code>, so they appear in <code class="docutils literal"><span class="pre">f1</span></code>&#8216;s type. The call to <code class="docutils literal"><span class="pre">show</span></code>
generates a <code class="docutils literal"><span class="pre">(Show</span> <span class="pre">b)</span></code> constraint, where <code class="docutils literal"><span class="pre">b</span></code> is an existentially
type variable bound by the pattern match on <code class="docutils literal"><span class="pre">MkT</span></code>. But the same
pattern match also <em>provides</em> the constraint <code class="docutils literal"><span class="pre">(Show</span> <span class="pre">b)</span></code> (see <code class="docutils literal"><span class="pre">MkT</span></code>&#8216;s
type), and so all is well.</p>
<p>Exactly the same reasoning applies to <code class="docutils literal"><span class="pre">ExNumPat</span></code>: matching against
<code class="docutils literal"><span class="pre">ExNumPat</span></code> <em>requires</em> the constraints <code class="docutils literal"><span class="pre">(Num</span> <span class="pre">a,</span> <span class="pre">Eq</span> <span class="pre">a)</span></code>, and
<em>provides</em> the constraint <code class="docutils literal"><span class="pre">(Show</span> <span class="pre">b)</span></code>.</p>
<p>Note also the following points</p>
<ul>
<li><p class="first">In the common case where <code class="docutils literal"><span class="pre">CProv</span></code> is empty, (i.e., <code class="docutils literal"><span class="pre">()</span></code>), it can be
omitted altogether in the above pattern type signature for <code class="docutils literal"><span class="pre">P</span></code>.</p>
</li>
<li><p class="first">However, if <code class="docutils literal"><span class="pre">CProv</span></code> is non-empty, while <code class="docutils literal"><span class="pre">CReq</span></code> is, the above pattern type
signature for <code class="docutils literal"><span class="pre">P</span></code> must be specified as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">P</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">=&gt;</span> <span class="kt">CProv</span> <span class="ow">=&gt;</span> <span class="n">t1</span> <span class="ow">-&gt;</span> <span class="n">t2</span> <span class="ow">-&gt;</span> <span class="o">..</span> <span class="ow">-&gt;</span> <span class="n">tN</span> <span class="ow">-&gt;</span> <span class="n">t</span>
</pre></div>
</div>
</li>
<li><p class="first">You may specify an explicit <em>pattern signature</em>, as we did for
<code class="docutils literal"><span class="pre">ExNumPat</span></code> above, to specify the type of a pattern, just as you can
for a function. As usual, the type signature can be less polymorphic
than the inferred type. For example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- Inferred type would be &#39;a -&gt; [a]&#39;</span>
<span class="nf">pattern</span> <span class="kt">SinglePair</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span>
<span class="nf">pattern</span> <span class="kt">SinglePair</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>Just like signatures on value-level bindings, pattern synonym signatures can
apply to more than one pattern. For instance,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="kt">Left&#39;</span><span class="p">,</span> <span class="kt">Right&#39;</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">a</span>
<span class="nf">pattern</span> <span class="kt">Left&#39;</span> <span class="n">x</span>  <span class="ow">=</span> <span class="kt">Left</span> <span class="n">x</span>
<span class="nf">pattern</span> <span class="kt">Right&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="n">x</span>
</pre></div>
</div>
</li>
<li><p class="first">The GHCi <a class="reference internal" href="ghci.html#ghci-cmd-:info"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:info</span></code></a> command shows pattern types in this format.</p>
</li>
<li><p class="first">For a bidirectional pattern synonym, a use of the pattern synonym as
an expression has the type</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="kt">CReq</span><span class="p">,</span> <span class="kt">CProv</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t1</span> <span class="ow">-&gt;</span> <span class="n">t2</span> <span class="ow">-&gt;</span> <span class="o">...</span> <span class="ow">-&gt;</span> <span class="n">tN</span> <span class="ow">-&gt;</span> <span class="n">t</span>
</pre></div>
</div>
<p>So in the previous example, when used in an expression, <code class="docutils literal"><span class="pre">ExNumPat</span></code>
has type</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">ExNumPat</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">t</span>
</pre></div>
</div>
<p>Notice that this is a tiny bit more restrictive than the expression
<code class="docutils literal"><span class="pre">MkT</span> <span class="pre">42</span> <span class="pre">x</span></code> which would not require <code class="docutils literal"><span class="pre">(Eq</span> <span class="pre">a)</span></code>.</p>
</li>
<li><p class="first">Consider these two pattern synonyms:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">S</span> <span class="n">a</span> <span class="kr">where</span>
   <span class="kt">S1</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">S</span> <span class="kt">Bool</span>

<span class="nf">pattern</span> <span class="kt">P1</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Bool</span>
<span class="nf">pattern</span> <span class="kt">P1</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">b</span>

<span class="nf">pattern</span> <span class="kt">P2</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">~</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">S</span> <span class="n">b</span>
<span class="nf">pattern</span> <span class="kt">P2</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">S1</span> <span class="n">b</span>

<span class="nf">f</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">P1</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;no no no&quot;</span>     <span class="c1">-- Type-incorrect</span>

<span class="nf">g</span> <span class="ow">::</span> <span class="kt">S</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">g</span> <span class="p">(</span><span class="kt">P2</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;yes yes yes&quot;</span>  <span class="c1">-- Fine</span>
</pre></div>
</div>
<p>Pattern <code class="docutils literal"><span class="pre">P1</span></code> can only match against a value of type <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Bool</span></code>,
so function <code class="docutils literal"><span class="pre">f</span></code> is rejected because the type signature is
<code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></code>. (To see this, imagine expanding the pattern synonym.)</p>
<p>On the other hand, function <code class="docutils literal"><span class="pre">g</span></code> works fine, because matching
against <code class="docutils literal"><span class="pre">P2</span></code> (which wraps the GADT <code class="docutils literal"><span class="pre">S</span></code>) provides the local
equality <code class="docutils literal"><span class="pre">(a~Bool)</span></code>. If you were to give an explicit pattern
signature <code class="docutils literal"><span class="pre">P2</span> <span class="pre">::</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">S</span> <span class="pre">Bool</span></code>, then <code class="docutils literal"><span class="pre">P2</span></code> would become less
polymorphic, and would behave exactly like <code class="docutils literal"><span class="pre">P1</span></code> so that <code class="docutils literal"><span class="pre">g</span></code> would
then be rejected.</p>
<p>In short, if you want GADT-like behaviour for pattern synonyms, then
(unlike concrete data constructors like <code class="docutils literal"><span class="pre">S1</span></code>) you must write
its type with explicit provided equalities. For a concrete data
constructor like <code class="docutils literal"><span class="pre">S1</span></code> you can write its type signature as either
<code class="docutils literal"><span class="pre">S1</span> <span class="pre">::</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">S</span> <span class="pre">Bool</span></code> or <code class="docutils literal"><span class="pre">S1</span> <span class="pre">::</span> <span class="pre">(b~Bool)</span> <span class="pre">=&gt;</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">S</span> <span class="pre">b</span></code>; the
two are equivalent. Not so for pattern synonyms: the two forms are
different, in order to distinguish the two cases above. (See
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/9953">Trac #9953</a> for discussion of this choice.)</p>
</li>
</ul>
</div>
<div class="section" id="matching-of-pattern-synonyms">
<h2>10.7.5. Matching of pattern synonyms<a class="headerlink" href="#matching-of-pattern-synonyms" title="Permalink to this headline">¶</a></h2>
<p>A pattern synonym occurrence in a pattern is evaluated by first matching
against the pattern synonym itself, and then on the argument patterns.
For example, in the following program, <code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">f'</span></code> are equivalent:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pattern</span> <span class="kt">Pair</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="nf">f</span> <span class="p">(</span><span class="kt">Pair</span> <span class="kt">True</span> <span class="kt">True</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">f</span> <span class="kr">_</span>                <span class="ow">=</span> <span class="kt">False</span>

<span class="nf">f&#39;</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">|</span> <span class="kt">True</span> <span class="ow">&lt;-</span> <span class="n">x</span><span class="p">,</span> <span class="kt">True</span> <span class="ow">&lt;-</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">f&#39;</span> <span class="kr">_</span>                              <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Note that the strictness of <code class="docutils literal"><span class="pre">f</span></code> differs from that of <code class="docutils literal"><span class="pre">g</span></code> defined
below:</p>
<div class="highlight-none"><div class="highlight"><pre>g [True, True] = True
g _            = False

*Main&gt; f (False:undefined)
*** Exception: Prelude.undefined
*Main&gt; g (False:undefined)
False
</pre></div>
</div>
</div>
</div>
<div class="section" id="class-and-instances-declarations">
<span id="type-class-extensions"></span><h1>10.8. Class and instances declarations<a class="headerlink" href="#class-and-instances-declarations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="class-declarations">
<span id="multi-param-type-classes"></span><h2>10.8.1. Class declarations<a class="headerlink" href="#class-declarations" title="Permalink to this headline">¶</a></h2>
<p>This section, and the next one, documents GHC&#8217;s type-class extensions.
There&#8217;s lots of background in the paper <a class="reference external" href="http://research.microsoft.com/~simonpj/Papers/type-class-design-space/">Type classes: exploring the
design
space</a>
(Simon Peyton Jones, Mark Jones, Erik Meijer).</p>
<div class="section" id="multi-parameter-type-classes">
<h3>10.8.1.1. Multi-parameter type classes<a class="headerlink" href="#multi-parameter-type-classes" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XMultiParamTypeClasses">
<code class="descname">-XMultiParamTypeClasses</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XMultiParamTypeClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XConstrainedClassMethods"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XConstrainedClassMethods</span></code></a></td>
</tr>
</tbody>
</table>
<p>Allow the definition of typeclasses with more than one parameter.</p>
</dd></dl>

<p>Multi-parameter type classes are permitted, with flag
<a class="reference internal" href="#ghc-flag--XMultiParamTypeClasses"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMultiParamTypeClasses</span></code></a>. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Collection</span> <span class="n">c</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">union</span> <span class="ow">::</span> <span class="n">c</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="n">a</span>
    <span class="o">...</span><span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="the-superclasses-of-a-class-declaration">
<span id="superclass-rules"></span><h3>10.8.1.2. The superclasses of a class declaration<a class="headerlink" href="#the-superclasses-of-a-class-declaration" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XFlexibleContexts">
<code class="descname">-XFlexibleContexts</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XFlexibleContexts" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the use of complex constraints in class declaration contexts.</p>
</dd></dl>

<p>In Haskell 98 the context of a class declaration (which introduces
superclasses) must be simple; that is, each predicate must consist of a
class applied to type variables. The flag <a class="reference internal" href="#ghc-flag--XFlexibleContexts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleContexts</span></code></a>
(<a class="reference internal" href="#flexible-contexts"><span>The context of a type signature</span></a>) lifts this restriction, so that the only
restriction on the context in a class declaration is that the class
hierarchy must be acyclic. So these class declarations are OK:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Functor</span> <span class="p">(</span><span class="n">m</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">FiniteMap</span> <span class="n">m</span> <span class="n">k</span> <span class="kr">where</span>
  <span class="o">...</span>

<span class="kr">class</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Monad</span> <span class="p">(</span><span class="n">t</span> <span class="n">m</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="kt">Transform</span> <span class="n">t</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">lift</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">t</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span>
</pre></div>
</div>
<p>As in Haskell 98, the class hierarchy must be acyclic. However, the
definition of &#8220;acyclic&#8221; involves only the superclass relationships. For
example, this is okay:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">op</span> <span class="ow">::</span> <span class="kt">D</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">D</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">C</span></code> is a superclass of <code class="docutils literal"><span class="pre">D</span></code>, but it&#8217;s OK for a class operation
<code class="docutils literal"><span class="pre">op</span></code> of <code class="docutils literal"><span class="pre">C</span></code> to mention <code class="docutils literal"><span class="pre">D</span></code>. (It would not be OK for <code class="docutils literal"><span class="pre">D</span></code> to be a
superclass of <code class="docutils literal"><span class="pre">C</span></code>.)</p>
<p>With the extension that adds a <a class="reference external" href="#constraint-kind">kind of
constraints</a>, you can write more exotic superclass
definitions. The superclass cycle check is even more liberal in these
case. For example, this is OK:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">A</span> <span class="n">cls</span> <span class="n">c</span> <span class="kr">where</span>
  <span class="n">meth</span> <span class="ow">::</span> <span class="n">cls</span> <span class="n">c</span> <span class="ow">=&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span>

<span class="kr">class</span> <span class="kt">A</span> <span class="kt">B</span> <span class="n">c</span> <span class="ow">=&gt;</span> <span class="kt">B</span> <span class="n">c</span> <span class="kr">where</span>
</pre></div>
</div>
<p>A superclass context for a class <code class="docutils literal"><span class="pre">C</span></code> is allowed if, after expanding
type synonyms to their right-hand-sides, and uses of classes (other than
<code class="docutils literal"><span class="pre">C</span></code>) to their superclasses, <code class="docutils literal"><span class="pre">C</span></code> does not occur syntactically in the
context.</p>
</div>
<div class="section" id="constrained-class-method-types">
<span id="class-method-types"></span><h3>10.8.1.3. Constrained class method types<a class="headerlink" href="#constrained-class-method-types" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XConstrainedClassMethods">
<code class="descname">-XConstrainedClassMethods</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XConstrainedClassMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows the definition of further constraints on individual class methods.</p>
</dd></dl>

<p>Haskell 98 prohibits class method types to mention constraints on the
class type variable, thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Seq</span> <span class="n">s</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">fromList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="n">a</span>
  <span class="n">elem</span>     <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>The type of <code class="docutils literal"><span class="pre">elem</span></code> is illegal in Haskell 98, because it contains the
constraint <code class="docutils literal"><span class="pre">Eq</span> <span class="pre">a</span></code>, which constrains only the class type variable (in
this case <code class="docutils literal"><span class="pre">a</span></code>).
this case <code class="docutils literal"><span class="pre">a</span></code>).  More precisely, a constraint in a class method signature is rejected if</p>
<ul>
<li><p class="first">The constraint mentions at least one type variable.  So this is allowed:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">op1</span> <span class="ow">::</span> <span class="kt">HasCallStack</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
  <span class="n">op2</span> <span class="ow">::</span> <span class="p">(</span><span class="o">?</span><span class="n">x</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
</li>
<li><p class="first">All of the type variables mentioned are bound by the class declaration, and none is locally quantified.  Examples:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">op3</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>    <span class="c1">-- Rejected: constrains class variable only</span>
  <span class="n">op4</span> <span class="ow">::</span> <span class="kt">D</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>     <span class="c1">-- Accepted: constrains a locally-quantified variable `b`</span>
  <span class="n">op5</span> <span class="ow">::</span> <span class="kt">D</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="c1">-- Accepted: constrains a locally-quantified variable `b`</span>
</pre></div>
</div>
</li>
</ul>
<p>GHC lifts this restriction with language extension
<a class="reference internal" href="#ghc-flag--XConstrainedClassMethods"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XConstrainedClassMethods</span></code></a>. The restriction is a pretty stupid one in
the first place, so <a class="reference internal" href="#ghc-flag--XConstrainedClassMethods"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XConstrainedClassMethods</span></code></a> is implied by
<a class="reference internal" href="#ghc-flag--XMultiParamTypeClasses"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMultiParamTypeClasses</span></code></a>.</p>
</div>
<div class="section" id="default-method-signatures">
<span id="class-default-signatures"></span><h3>10.8.1.4. Default method signatures<a class="headerlink" href="#default-method-signatures" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XDefaultSignatures">
<code class="descname">-XDefaultSignatures</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDefaultSignatures" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.2</td>
</tr>
</tbody>
</table>
<p>Allows the definition of default method signatures in class definitions.</p>
</dd></dl>

<p>Haskell 98 allows you to define a default implementation when declaring
a class:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Enum</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">enum</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
  <span class="n">enum</span> <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>The type of the <code class="docutils literal"><span class="pre">enum</span></code> method is <code class="docutils literal"><span class="pre">[a]</span></code>, and this is also the type of
the default method. You can lift this restriction and give another type
to the default method using the flag <a class="reference internal" href="#ghc-flag--XDefaultSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDefaultSignatures</span></code></a>. For
instance, if you have written a generic implementation of enumeration in
a class <code class="docutils literal"><span class="pre">GEnum</span></code> with method <code class="docutils literal"><span class="pre">genum</span></code> in terms of <code class="docutils literal"><span class="pre">GHC.Generics</span></code>,
you can specify a default method that uses that generic implementation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Enum</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">enum</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
  <span class="kr">default</span> <span class="n">enum</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Generic</span> <span class="n">a</span><span class="p">,</span> <span class="kt">GEnum</span> <span class="p">(</span><span class="kt">Rep</span> <span class="n">a</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
  <span class="n">enum</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">to</span> <span class="n">genum</span>
</pre></div>
</div>
<p>We reuse the keyword <code class="docutils literal"><span class="pre">default</span></code> to signal that a signature applies to
the default method only; when defining instances of the <code class="docutils literal"><span class="pre">Enum</span></code> class,
the original type <code class="docutils literal"><span class="pre">[a]</span></code> of <code class="docutils literal"><span class="pre">enum</span></code> still applies. When giving an
empty instance, however, the default implementation <code class="docutils literal"><span class="pre">map</span> <span class="pre">to</span> <span class="pre">genum</span></code> is
filled-in, and type-checked with the type
<code class="docutils literal"><span class="pre">(Generic</span> <span class="pre">a,</span> <span class="pre">GEnum</span> <span class="pre">(Rep</span> <span class="pre">a))</span> <span class="pre">=&gt;</span> <span class="pre">[a]</span></code>.</p>
<p>The type signature for a default method of a type class must take on the same
form as the corresponding main method&#8217;s type signature. Otherwise, the
typechecker will reject that class&#8217;s definition. By &#8220;take on the same form&#8221;, we
mean that the default type signature should differ from the main type signature
only in their contexts. Therefore, if you have a method <code class="docutils literal"><span class="pre">bar</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">bar</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="kt">C</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>Then a default method for <code class="docutils literal"><span class="pre">bar</span></code> must take on the form:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">default</span> <span class="n">bar</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="kt">C&#39;</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">C</span></code> is allowed to be different from <code class="docutils literal"><span class="pre">C'</span></code>, but the right-hand sides of the
type signatures must coincide. We require this because when you declare an
empty instance for a class that uses <a class="reference internal" href="#ghc-flag--XDefaultSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDefaultSignatures</span></code></a>, GHC
implicitly fills in the default implementation like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Foo</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="n">bar</span> <span class="ow">=</span> <span class="n">default_bar</span> <span class="o">@</span><span class="kt">Int</span>
</pre></div>
</div>
<p>Where <code class="docutils literal"><span class="pre">&#64;Int</span></code> utilizes visible type application
(<a class="reference internal" href="#visible-type-application"><span>Visible type application</span></a>) to instantiate the <code class="docutils literal"><span class="pre">b</span></code> in
<code class="docutils literal"><span class="pre">default</span> <span class="pre">bar</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">b.</span> <span class="pre">C'</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>. In order for this type
application to work, the default type signature for <code class="docutils literal"><span class="pre">bar</span></code> must have the same
type variable order as the non-default signature! But there is no obligation
for <code class="docutils literal"><span class="pre">C</span></code> and <code class="docutils literal"><span class="pre">C'</span></code> to be the same (see, for instance, the <code class="docutils literal"><span class="pre">Enum</span></code> example
above, which relies on this).</p>
<p>To further explain this example, the right-hand side of the default
type signature for <code class="docutils literal"><span class="pre">bar</span></code> must be something that is alpha-equivalent to
<code class="docutils literal"><span class="pre">forall</span> <span class="pre">b.</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> (where <code class="docutils literal"><span class="pre">a</span></code> is bound by the class itself, and is
thus free in the methods&#8217; type signatures). So this would also be an acceptable
default type signature:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">default</span> <span class="n">bar</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="kt">C&#39;</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span>
</pre></div>
</div>
<p>But not this (since the free variable <code class="docutils literal"><span class="pre">a</span></code> is in the wrong place):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">default</span> <span class="n">bar</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="kt">C&#39;</span> <span class="ow">=&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>Nor this, since we can&#8217;t match the type variable <code class="docutils literal"><span class="pre">b</span></code> with the concrete type
<code class="docutils literal"><span class="pre">Int</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">default</span> <span class="n">bar</span> <span class="ow">::</span> <span class="kt">C&#39;</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>That last one deserves a special mention, however, since <code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> is
a straightforward instantiation of <code class="docutils literal"><span class="pre">forall</span> <span class="pre">b.</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>. You can still
write such a default type signature, but you now must use type equalities to
do so:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">default</span> <span class="n">bar</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="kt">C&#39;</span><span class="p">,</span> <span class="n">b</span> <span class="o">~</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>We use default signatures to simplify generic programming in GHC
(<a class="reference internal" href="#generic-programming"><span>Generic programming</span></a>).</p>
</div>
<div class="section" id="nullary-type-classes">
<span id="id25"></span><h3>10.8.1.5. Nullary type classes<a class="headerlink" href="#nullary-type-classes" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XNullaryTypeClasses">
<code class="descname">-XNullaryTypeClasses</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XNullaryTypeClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.8.1</td>
</tr>
</tbody>
</table>
<p>Allows the use definition of type classes with no parameters. This flag
has been replaced by <a class="reference internal" href="#ghc-flag--XMultiParamTypeClasses"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMultiParamTypeClasses</span></code></a>.</p>
</dd></dl>

<p>Nullary (no parameter) type classes are enabled with
<a class="reference internal" href="#ghc-flag--XMultiParamTypeClasses"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMultiParamTypeClasses</span></code></a>; historically, they were enabled with the
(now deprecated) <a class="reference internal" href="#ghc-flag--XNullaryTypeClasses"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNullaryTypeClasses</span></code></a>. Since there are no available
parameters, there can be at most one instance of a nullary class. A nullary type
class might be used to document some assumption in a type signature (such as
reliance on the Riemann hypothesis) or add some globally configurable settings
in a program. For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">RiemannHypothesis</span> <span class="kr">where</span>
  <span class="n">assumeRH</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="c1">-- Deterministic version of the Miller test</span>
<span class="c1">-- correctness depends on the generalised Riemann hypothesis</span>
<span class="nf">isPrime</span> <span class="ow">::</span> <span class="kt">RiemannHypothesis</span> <span class="ow">=&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isPrime</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">assumeRH</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The type signature of <code class="docutils literal"><span class="pre">isPrime</span></code> informs users that its correctness depends on
an unproven conjecture. If the function is used, the user has to acknowledge the
dependence with:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">RiemannHypothesis</span> <span class="kr">where</span>
  <span class="n">assumeRH</span> <span class="ow">=</span> <span class="n">id</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="functional-dependencies">
<span id="id26"></span><h2>10.8.2. Functional dependencies<a class="headerlink" href="#functional-dependencies" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XFunctionalDependencies">
<code class="descname">-XFunctionalDependencies</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XFunctionalDependencies" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XMultiParamTypeClasses"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMultiParamTypeClasses</span></code></a></td>
</tr>
</tbody>
</table>
<p>Allow use of functional dependencies in class declarations.</p>
</dd></dl>

<p>Functional dependencies are implemented as described by Mark Jones in
<a class="reference internal" href="#jones2000" id="id27">[Jones2000]</a>.</p>
<p>Functional dependencies are introduced by a vertical bar in the syntax
of a class declaration; e.g.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadState</span> <span class="n">s</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="kr">where</span> <span class="o">...</span>

<span class="kr">class</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">|</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>There should be more documentation, but there isn&#8217;t (yet). Yell if you
need it.</p>
<table class="docutils citation" frame="void" id="jones2000" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[Jones2000]</a></td><td>&#8220;<a class="reference external" href="http://citeseer.ist.psu.edu/jones00type.html">Type Classes with Functional
Dependencies</a>&#8221;,
Mark P. Jones, In <em>Proceedings of the 9th European Symposium on Programming</em>,
ESOP 2000, Berlin, Germany, March 2000, Springer-Verlag LNCS 1782, .</td></tr>
</tbody>
</table>
<div class="section" id="rules-for-functional-dependencies">
<h3>10.8.2.1. Rules for functional dependencies<a class="headerlink" href="#rules-for-functional-dependencies" title="Permalink to this headline">¶</a></h3>
<p>In a class declaration, all of the class type variables must be
reachable (in the sense mentioned in <a class="reference internal" href="#flexible-contexts"><span>The context of a type signature</span></a>) from the
free variables of each method type. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Coll</span> <span class="n">s</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">empty</span>  <span class="ow">::</span> <span class="n">s</span>
  <span class="n">insert</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span>
</pre></div>
</div>
<p>is not OK, because the type of <code class="docutils literal"><span class="pre">empty</span></code> doesn&#8217;t mention <code class="docutils literal"><span class="pre">a</span></code>.
Functional dependencies can make the type variable reachable:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Coll</span> <span class="n">s</span> <span class="n">a</span> <span class="o">|</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">empty</span>  <span class="ow">::</span> <span class="n">s</span>
  <span class="n">insert</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span>
</pre></div>
</div>
<p>Alternatively <code class="docutils literal"><span class="pre">Coll</span></code> might be rewritten</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Coll</span> <span class="n">s</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">empty</span>  <span class="ow">::</span> <span class="n">s</span> <span class="n">a</span>
  <span class="n">insert</span> <span class="ow">::</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="n">a</span>
</pre></div>
</div>
<p>which makes the connection between the type of a collection of <code class="docutils literal"><span class="pre">a</span></code>&#8216;s
(namely <code class="docutils literal"><span class="pre">(s</span> <span class="pre">a)</span></code>) and the element type <code class="docutils literal"><span class="pre">a</span></code>. Occasionally this really
doesn&#8217;t work, in which case you can split the class like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">CollE</span> <span class="n">s</span> <span class="kr">where</span>
  <span class="n">empty</span>  <span class="ow">::</span> <span class="n">s</span>

<span class="kr">class</span> <span class="kt">CollE</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Coll</span> <span class="n">s</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">insert</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span>
</pre></div>
</div>
</div>
<div class="section" id="background-on-functional-dependencies">
<h3>10.8.2.2. Background on functional dependencies<a class="headerlink" href="#background-on-functional-dependencies" title="Permalink to this headline">¶</a></h3>
<p>The following description of the motivation and use of functional
dependencies is taken from the Hugs user manual, reproduced here (with
minor changes) by kind permission of Mark Jones.</p>
<p>Consider the following class, intended as part of a library for
collection types:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Collects</span> <span class="n">e</span> <span class="n">ce</span> <span class="kr">where</span>
    <span class="n">empty</span>  <span class="ow">::</span> <span class="n">ce</span>
    <span class="n">insert</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
    <span class="n">member</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>The type variable <code class="docutils literal"><span class="pre">e</span></code> used here represents the element type, while <code class="docutils literal"><span class="pre">ce</span></code> is
the type of the container itself. Within this framework, we might want to define
instances of this class for lists or characteristic functions (both of which can
be used to represent collections of any equality type), bit sets (which can be
used to represent collections of characters), or hash tables (which can be used
to represent any collection whose elements have a hash function). Omitting
standard implementation details, this would lead to the following declarations:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">Collects</span> <span class="n">e</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">Collects</span> <span class="n">e</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Collects</span> <span class="kt">Char</span> <span class="kt">BitSet</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Collects</span> <span class="n">a</span> <span class="n">ce</span><span class="p">)</span>
           <span class="ow">=&gt;</span> <span class="kt">Collects</span> <span class="n">e</span> <span class="p">(</span><span class="kt">Array</span> <span class="kt">Int</span> <span class="n">ce</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>All this looks quite promising; we have a class and a range of
interesting implementations. Unfortunately, there are some serious
problems with the class declaration. First, the empty function has an
ambiguous type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">empty</span> <span class="ow">::</span> <span class="kt">Collects</span> <span class="n">e</span> <span class="n">ce</span> <span class="ow">=&gt;</span> <span class="n">ce</span>
</pre></div>
</div>
<p>By &#8220;ambiguous&#8221; we mean that there is a type variable <code class="docutils literal"><span class="pre">e</span></code> that appears on
the left of the <code class="docutils literal"><span class="pre">=&gt;</span></code> symbol, but not on the right. The problem with
this is that, according to the theoretical foundations of Haskell
overloading, we cannot guarantee a well-defined semantics for any term
with an ambiguous type.</p>
<p>We can sidestep this specific problem by removing the empty member from
the class declaration. However, although the remaining members, insert
and member, do not have ambiguous types, we still run into problems when
we try to use them. For example, consider the following two functions:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">.</span> <span class="n">insert</span> <span class="n">y</span>
<span class="nf">g</span>     <span class="ow">=</span> <span class="n">f</span> <span class="kt">True</span> <span class="sc">&#39;a&#39;</span>
</pre></div>
</div>
<p>for which GHC infers the following types:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Collects</span> <span class="n">a</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Collects</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">g</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Collects</span> <span class="kt">Bool</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Collects</span> <span class="kt">Char</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span>
</pre></div>
</div>
<p>Notice that the type for <code class="docutils literal"><span class="pre">f</span></code> allows the two parameters <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> to be
assigned different types, even though it attempts to insert each of the
two values, one after the other, into the same collection. If we&#8217;re
trying to model collections that contain only one type of value, then
this is clearly an inaccurate type. Worse still, the definition for g is
accepted, without causing a type error. As a result, the error in this
code will not be flagged at the point where it appears. Instead, it will
show up only when we try to use <code class="docutils literal"><span class="pre">g</span></code>, which might even be in a different
module.</p>
<div class="section" id="an-attempt-to-use-constructor-classes">
<h4>10.8.2.2.1. An attempt to use constructor classes<a class="headerlink" href="#an-attempt-to-use-constructor-classes" title="Permalink to this headline">¶</a></h4>
<p>Faced with the problems described above, some Haskell programmers might
be tempted to use something like the following version of the class
declaration:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Collects</span> <span class="n">e</span> <span class="n">c</span> <span class="kr">where</span>
   <span class="n">empty</span>  <span class="ow">::</span> <span class="n">c</span> <span class="n">e</span>
   <span class="n">insert</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="n">e</span>
   <span class="n">member</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>The key difference here is that we abstract over the type constructor <code class="docutils literal"><span class="pre">c</span></code>
that is used to form the collection type <code class="docutils literal"><span class="pre">c</span> <span class="pre">e</span></code>, and not over that
collection type itself, represented by <code class="docutils literal"><span class="pre">ce</span></code> in the original class
declaration. This avoids the immediate problems that we mentioned above:
empty has type <code class="docutils literal"><span class="pre">Collects</span> <span class="pre">e</span> <span class="pre">c</span> <span class="pre">=&gt;</span> <span class="pre">c</span> <span class="pre">e</span></code>, which is not ambiguous.</p>
<p>The function <code class="docutils literal"><span class="pre">f</span></code> from the previous section has a more accurate type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Collects</span> <span class="n">e</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="n">e</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">g</span></code> from the previous section is now rejected with a type
error as we would hope because the type of <code class="docutils literal"><span class="pre">f</span></code> does not allow the two
arguments to have different types. This, then, is an example of a
multiple parameter class that does actually work quite well in practice,
without ambiguity problems. There is, however, a catch. This version of
the <code class="docutils literal"><span class="pre">Collects</span></code> class is nowhere near as general as the original class
seemed to be: only one of the four instances for <code class="docutils literal"><span class="pre">Collects</span></code> given
above can be used with this version of Collects because only one of them—the
instance for lists—has a collection type that can be written in the form <code class="docutils literal"><span class="pre">c</span>
<span class="pre">e</span></code>, for some type constructor <code class="docutils literal"><span class="pre">c</span></code>, and element type <code class="docutils literal"><span class="pre">e</span></code>.</p>
</div>
<div class="section" id="adding-functional-dependencies">
<h4>10.8.2.2.2. Adding functional dependencies<a class="headerlink" href="#adding-functional-dependencies" title="Permalink to this headline">¶</a></h4>
<p>To get a more useful version of the <code class="docutils literal"><span class="pre">Collects</span></code> class, GHC provides a
mechanism that allows programmers to specify dependencies between the
parameters of a multiple parameter class (For readers with an interest
in theoretical foundations and previous work: The use of dependency
information can be seen both as a generalisation of the proposal for
&#8220;parametric type classes&#8221; that was put forward by Chen, Hudak, and
Odersky, or as a special case of Mark Jones&#8217;s later framework for
&#8220;improvement&#8221; of qualified types. The underlying ideas are also
discussed in a more theoretical and abstract setting in a manuscript
[implparam], where they are identified as one point in a general design
space for systems of implicit parameterisation). To start with an
abstract example, consider a declaration such as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>which tells us simply that <code class="docutils literal"><span class="pre">C</span></code> can be thought of as a binary relation on
types (or type constructors, depending on the kinds of <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>). Extra
clauses can be included in the definition of classes to add information
about dependencies between parameters, as in the following examples:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">D</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">class</span> <span class="kt">E</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>The notation <code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> used here between the <code class="docutils literal"><span class="pre">|</span></code> and <code class="docutils literal"><span class="pre">where</span></code> symbols —
not to be confused with a function type — indicates that the a
parameter uniquely determines the <code class="docutils literal"><span class="pre">b</span></code> parameter, and might be read as &#8220;<code class="docutils literal"><span class="pre">a</span></code>
determines <code class="docutils literal"><span class="pre">b</span></code>.&#8221; Thus <code class="docutils literal"><span class="pre">D</span></code> is not just a relation, but actually a (partial)
function. Similarly, from the two dependencies that are included in the
definition of <code class="docutils literal"><span class="pre">E</span></code>, we can see that <code class="docutils literal"><span class="pre">E</span></code> represents a (partial) one-to-one
mapping between types.</p>
<p>More generally, dependencies take the form <code class="docutils literal"><span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span> <span class="pre">-&gt;</span> <span class="pre">y1</span> <span class="pre">...</span> <span class="pre">ym</span></code>,
where <code class="docutils literal"><span class="pre">x1</span></code>, ..., <code class="docutils literal"><span class="pre">xn</span></code>, and <code class="docutils literal"><span class="pre">y1</span></code>, ..., <code class="docutils literal"><span class="pre">yn</span></code> are type variables with n&gt;0 and m&gt;=0,
meaning that the <code class="docutils literal"><span class="pre">y</span></code> parameters are uniquely determined by the <code class="docutils literal"><span class="pre">x</span></code>
parameters. Spaces can be used as separators if more than one variable
appears on any single side of a dependency, as in <code class="docutils literal"><span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">b</span></code>. Note
that a class may be annotated with multiple dependencies using commas as
separators, as in the definition of <code class="docutils literal"><span class="pre">E</span></code> above. Some dependencies that we
can write in this notation are redundant, and will be rejected because
they don&#8217;t serve any useful purpose, and may instead indicate an error
in the program. Examples of dependencies like this include <code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>,
<code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span></code>, etc. There can also be some redundancy if
multiple dependencies are given, as in <code class="docutils literal"><span class="pre">a-&gt;b</span></code>, <code class="docutils literal"><span class="pre">b-&gt;c</span></code>, <code class="docutils literal"><span class="pre">a-&gt;c</span></code>, and
in which some subset implies the remaining dependencies. Examples like
this are not treated as errors. Note that dependencies appear only in
class declarations, and not in any other part of the language. In
particular, the syntax for instance declarations, class constraints, and
types is completely unchanged.</p>
<p>By including dependencies in a class declaration, we provide a mechanism
for the programmer to specify each multiple parameter class more
precisely. The compiler, on the other hand, is responsible for ensuring
that the set of instances that are in scope at any given point in the
program is consistent with any declared dependencies. For example, the
following pair of instance declarations cannot appear together in the
same scope because they violate the dependency for <code class="docutils literal"><span class="pre">D</span></code>, even though either
one on its own would be acceptable:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">D</span> <span class="kt">Bool</span> <span class="kt">Int</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="kt">D</span> <span class="kt">Bool</span> <span class="kt">Char</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>Note also that the following declaration is not allowed, even by itself:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">D</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="n">b</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>The problem here is that this instance would allow one particular choice
of <code class="docutils literal"><span class="pre">[a]</span></code> to be associated with more than one choice for <code class="docutils literal"><span class="pre">b</span></code>, which
contradicts the dependency specified in the definition of <code class="docutils literal"><span class="pre">D</span></code>. More
generally, this means that, in any instance of the form:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">D</span> <span class="n">t</span> <span class="n">s</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>for some particular types <code class="docutils literal"><span class="pre">t</span></code> and <code class="docutils literal"><span class="pre">s</span></code>, the only variables that can appear in
<code class="docutils literal"><span class="pre">s</span></code> are the ones that appear in <code class="docutils literal"><span class="pre">t</span></code>, and hence, if the type <code class="docutils literal"><span class="pre">t</span></code> is known,
then <code class="docutils literal"><span class="pre">s</span></code> will be uniquely determined.</p>
<p>The benefit of including dependency information is that it allows us to
define more general multiple parameter classes, without ambiguity
problems, and with the benefit of more accurate types. To illustrate
this, we return to the collection class example, and annotate the
original definition of <code class="docutils literal"><span class="pre">Collects</span></code> with a simple dependency:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Collects</span> <span class="n">e</span> <span class="n">ce</span> <span class="o">|</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">e</span> <span class="kr">where</span>
   <span class="n">empty</span>  <span class="ow">::</span> <span class="n">ce</span>
   <span class="n">insert</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
   <span class="n">member</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>The dependency <code class="docutils literal"><span class="pre">ce</span> <span class="pre">-&gt;</span> <span class="pre">e</span></code> here specifies that the type <code class="docutils literal"><span class="pre">e</span></code> of elements is
uniquely determined by the type of the collection <code class="docutils literal"><span class="pre">ce</span></code>. Note that both
parameters of Collects are of kind <code class="docutils literal"><span class="pre">*</span></code>; there are no constructor classes
here. Note too that all of the instances of <code class="docutils literal"><span class="pre">Collects</span></code> that we gave
earlier can be used together with this new definition.</p>
<p>What about the ambiguity problems that we encountered with the original
definition? The empty function still has type <code class="docutils literal"><span class="pre">Collects</span> <span class="pre">e</span> <span class="pre">ce</span> <span class="pre">=&gt;</span> <span class="pre">ce</span></code>, but
it is no longer necessary to regard that as an ambiguous type: Although
the variable <code class="docutils literal"><span class="pre">e</span></code> does not appear on the right of the <code class="docutils literal"><span class="pre">=&gt;</span></code> symbol, the
dependency for class <code class="docutils literal"><span class="pre">Collects</span></code> tells us that it is uniquely determined by
<code class="docutils literal"><span class="pre">ce</span></code>, which does appear on the right of the <code class="docutils literal"><span class="pre">=&gt;</span></code> symbol. Hence the context
in which empty is used can still give enough information to determine
types for both <code class="docutils literal"><span class="pre">ce</span></code> and <code class="docutils literal"><span class="pre">e</span></code>, without ambiguity. More generally, we need only
regard a type as ambiguous if it contains a variable on the left of the
<code class="docutils literal"><span class="pre">=&gt;</span></code> that is not uniquely determined (either directly or indirectly) by
the variables on the right.</p>
<p>Dependencies also help to produce more accurate types for user defined
functions, and hence to provide earlier detection of errors, and less
cluttered types for programmers to work with. Recall the previous
definition for a function <code class="docutils literal"><span class="pre">f</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">.</span> <span class="n">insert</span> <span class="n">y</span>
</pre></div>
</div>
<p>for which we originally obtained a type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Collects</span> <span class="n">a</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Collects</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span>
</pre></div>
</div>
<p>Given the dependency information that we have for <code class="docutils literal"><span class="pre">Collects</span></code>, however, we
can deduce that <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> must be equal because they both appear as the
second parameter in a <code class="docutils literal"><span class="pre">Collects</span></code> constraint with the same first parameter
<code class="docutils literal"><span class="pre">c</span></code>. Hence we can infer a shorter and more accurate type for <code class="docutils literal"><span class="pre">f</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Collects</span> <span class="n">a</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span>
</pre></div>
</div>
<p>In a similar way, the earlier definition of <code class="docutils literal"><span class="pre">g</span></code> will now be flagged as a
type error.</p>
<p>Although we have given only a few examples here, it should be clear that
the addition of dependency information can help to make multiple
parameter classes more useful in practice, avoiding ambiguity problems,
and allowing more general sets of instance declarations.</p>
</div>
</div>
</div>
<div class="section" id="instance-declarations">
<span id="instance-decls"></span><h2>10.8.3. Instance declarations<a class="headerlink" href="#instance-declarations" title="Permalink to this headline">¶</a></h2>
<p>An instance declaration has the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span> <span class="n">assertion1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">assertionn</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kr">class</span> <span class="n">type1</span> <span class="o">...</span> <span class="n">typem</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>The part before the &#8220;<code class="docutils literal"><span class="pre">=&gt;</span></code>&#8221; is the <em>context</em>, while the part after the
&#8220;<code class="docutils literal"><span class="pre">=&gt;</span></code>&#8221; is the <em>head</em> of the instance declaration.</p>
<div class="section" id="instance-resolution">
<span id="id28"></span><h3>10.8.3.1. Instance resolution<a class="headerlink" href="#instance-resolution" title="Permalink to this headline">¶</a></h3>
<p>When GHC tries to resolve, say, the constraint <code class="docutils literal"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">Bool</span></code>, it tries
to match every instance declaration against the constraint, by
instantiating the head of the instance declaration. Consider these
declarations:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="n">context1</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="kt">Int</span> <span class="n">a</span>     <span class="kr">where</span> <span class="o">...</span>  <span class="c1">-- (A)</span>
<span class="kr">instance</span> <span class="n">context2</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">a</span>   <span class="kt">Bool</span>  <span class="kr">where</span> <span class="o">...</span>  <span class="c1">-- (B)</span>
</pre></div>
</div>
<p>GHC&#8217;s default behaviour is that <em>exactly one instance must match the
constraint it is trying to resolve</em>. For example, the constraint
<code class="docutils literal"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">Bool</span></code> matches instances (A) and (B), and hence would be
rejected; while <code class="docutils literal"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">Char</span></code> matches only (A) and hence (A) is chosen.</p>
<p>Notice that</p>
<ul class="simple">
<li>When matching, GHC takes no account of the context of the instance
declaration (<code class="docutils literal"><span class="pre">context1</span></code> etc).</li>
<li>It is fine for there to be a <em>potential</em> of overlap (by including
both declarations (A) and (B), say); an error is only reported if a
particular constraint matches more than one.</li>
</ul>
<p>See also <a class="reference internal" href="#instance-overlap"><span>Overlapping instances</span></a> for flags that loosen the instance
resolution rules.</p>
</div>
<div class="section" id="relaxed-rules-for-the-instance-head">
<span id="flexible-instance-head"></span><h3>10.8.3.2. Relaxed rules for the instance head<a class="headerlink" href="#relaxed-rules-for-the-instance-head" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XTypeSynonymInstances">
<code class="descname">-XTypeSynonymInstances</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XTypeSynonymInstances" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow definition of type class instances for type synonyms.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--XFlexibleInstances">
<code class="descname">-XFlexibleInstances</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XFlexibleInstances" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XTypeSynonymInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeSynonymInstances</span></code></a></td>
</tr>
</tbody>
</table>
<p>Allow definition of type class instances with arbitrary nested types in the
instance head.</p>
</dd></dl>

<p>In Haskell 98 the head of an instance declaration must be of the form
<code class="docutils literal"><span class="pre">C</span> <span class="pre">(T</span> <span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an)</span></code>, where <code class="docutils literal"><span class="pre">C</span></code> is the class, <code class="docutils literal"><span class="pre">T</span></code> is a data type
constructor, and the <code class="docutils literal"><span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an</span></code> are distinct type variables. In the
case of multi-parameter type classes, this rule applies to each
parameter of the instance head (Arguably it should be okay if just one
has this form and the others are type variables, but that&#8217;s the rules at
the moment).</p>
<p>GHC relaxes this rule in two ways:</p>
<ul>
<li><p class="first">With the <a class="reference internal" href="#ghc-flag--XTypeSynonymInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeSynonymInstances</span></code></a> flag, instance heads may use type
synonyms. As always, using a type synonym is just shorthand for
writing the RHS of the type synonym definition. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Point</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">C</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">a</span><span class="p">)</span>   <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>is legal. The instance declaration is equivalent to</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>As always, type synonyms must be fully applied. You cannot, for
example, write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Point</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first">The <a class="reference internal" href="#ghc-flag--XFlexibleInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleInstances</span></code></a> flag allows the head of the instance
declaration to mention arbitrary nested types. For example, this
becomes a legal instance declaration</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>See also the <a class="reference external" href="#instance-overlap">rules on overlap</a>.</p>
<p>The <a class="reference internal" href="#ghc-flag--XFlexibleInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleInstances</span></code></a> flag implies
<a class="reference internal" href="#ghc-flag--XTypeSynonymInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeSynonymInstances</span></code></a>.</p>
</li>
</ul>
<p>However, the instance declaration must still conform to the rules for
instance termination: see <a class="reference internal" href="#instance-termination"><span>Instance termination rules</span></a>.</p>
</div>
<div class="section" id="relaxed-rules-for-instance-contexts">
<span id="instance-rules"></span><h3>10.8.3.3. Relaxed rules for instance contexts<a class="headerlink" href="#relaxed-rules-for-instance-contexts" title="Permalink to this headline">¶</a></h3>
<p>In Haskell 98, the class constraints in the context of the instance
declaration must be of the form <code class="docutils literal"><span class="pre">C</span> <span class="pre">a</span></code> where <code class="docutils literal"><span class="pre">a</span></code> is a type variable
that occurs in the head.</p>
<p>The <a class="reference internal" href="#ghc-flag--XFlexibleContexts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleContexts</span></code></a> flag relaxes this rule, as well as relaxing
the corresponding rule for type signatures (see
<a class="reference internal" href="#flexible-contexts"><span>The context of a type signature</span></a>). Specifically, <a class="reference internal" href="#ghc-flag--XFlexibleContexts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleContexts</span></code></a>, allows
(well-kinded) class constraints of form <code class="docutils literal"><span class="pre">(C</span> <span class="pre">t1</span> <span class="pre">...</span> <span class="pre">tn)</span></code> in the context
of an instance declaration.</p>
<p>Notice that the flag does not affect equality constraints in an instance
context; they are permitted by <a class="reference internal" href="#ghc-flag--XTypeFamilies"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeFamilies</span></code></a> or <a class="reference internal" href="#ghc-flag--XGADTs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGADTs</span></code></a>.</p>
<p>However, the instance declaration must still conform to the rules for
instance termination: see <a class="reference internal" href="#instance-termination"><span>Instance termination rules</span></a>.</p>
</div>
<div class="section" id="instance-termination-rules">
<span id="instance-termination"></span><h3>10.8.3.4. Instance termination rules<a class="headerlink" href="#instance-termination-rules" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XUndecidableInstances">
<code class="descname">-XUndecidableInstances</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XUndecidableInstances" title="Permalink to this definition">¶</a></dt>
<dd><p>Permit definition of instances which may lead to type-checker non-termination.</p>
</dd></dl>

<p>Regardless of <a class="reference internal" href="#ghc-flag--XFlexibleInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleInstances</span></code></a> and <a class="reference internal" href="#ghc-flag--XFlexibleContexts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleContexts</span></code></a>,
instance declarations must conform to some rules that ensure that
instance resolution will terminate. The restrictions can be lifted with
<a class="reference internal" href="#ghc-flag--XUndecidableInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUndecidableInstances</span></code></a> (see <a class="reference internal" href="#undecidable-instances"><span>Undecidable instances</span></a>).</p>
<p>The rules are these:</p>
<ol class="arabic simple">
<li>The Paterson Conditions: for each class constraint <code class="docutils literal"><span class="pre">(C</span> <span class="pre">t1</span> <span class="pre">...</span> <span class="pre">tn)</span></code>
in the context<ol class="arabic">
<li>No type variable has more occurrences in the constraint than in
the head</li>
<li>The constraint has fewer constructors and variables (taken
together and counting repetitions) than the head</li>
<li>The constraint mentions no type functions. A type function
application can in principle expand to a type of arbitrary size,
and so are rejected out of hand</li>
</ol>
</li>
<li>The Coverage Condition. For each functional dependency,
⟨tvs⟩<sub>left</sub> <code class="docutils literal"><span class="pre">-&gt;</span></code> ⟨tvs⟩<sub>right</sub>, of the class, every
type variable in S(⟨tvs⟩<sub>right</sub>) must appear in
S(⟨tvs⟩<sub>left</sub>), where S is the substitution mapping each type
variable in the class declaration to the corresponding type in the
instance head.</li>
</ol>
<p>These restrictions ensure that instance resolution terminates: each
reduction step makes the problem smaller by at least one constructor.
You can find lots of background material about the reason for these
restrictions in the paper <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf">Understanding functional dependencies via
Constraint Handling
Rules</a>.</p>
<p>For example, these are okay:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="kt">Int</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>          <span class="c1">-- Multiple parameters</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">S</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>         <span class="c1">-- Structured type in head</span>

    <span class="c1">-- Repeated type variable in head</span>
<span class="kr">instance</span> <span class="kt">C4</span> <span class="n">a</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">C4</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kr">instance</span> <span class="kt">Stateful</span> <span class="p">(</span><span class="kt">ST</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="kt">MutVar</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1">-- Head can consist of type variables only</span>
<span class="kr">instance</span> <span class="kt">C</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">C2</span> <span class="n">a</span> <span class="n">b</span>

    <span class="c1">-- Non-type variables in context</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="p">(</span><span class="n">s</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Sized</span> <span class="n">s</span> <span class="n">a</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">C2</span> <span class="kt">Int</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">C3</span> <span class="kt">Bool</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kr">instance</span> <span class="kt">C2</span> <span class="kt">Int</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">C3</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="n">b</span>
</pre></div>
</div>
<p>But these are not:</p>
<div class="highlight-haskell"><div class="highlight"><pre>    <span class="c1">-- Context assertion no smaller than head</span>
<span class="kr">instance</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">...</span>
    <span class="c1">-- (C b b) has more occurrences of b than the head</span>
<span class="kr">instance</span> <span class="kt">C</span> <span class="n">b</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">Foo</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>The same restrictions apply to instances generated by <code class="docutils literal"><span class="pre">deriving</span></code>
clauses. Thus the following is accepted:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">MinHeap</span> <span class="n">h</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">H</span> <span class="n">a</span> <span class="p">(</span><span class="n">h</span> <span class="n">a</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>because the derived instance</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="p">(</span><span class="n">h</span> <span class="n">a</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">MinHeap</span> <span class="n">h</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>conforms to the above rules.</p>
<p>A useful idiom permitted by the above rules is as follows. If one allows
overlapping instance declarations then it&#8217;s quite convenient to have a
&#8220;default instance&#8221; declaration that applies if something more specific
does not:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">op</span> <span class="ow">=</span> <span class="o">...</span> <span class="c1">-- Default</span>
</pre></div>
</div>
</div>
<div class="section" id="undecidable-instances">
<span id="id29"></span><h3>10.8.3.5. Undecidable instances<a class="headerlink" href="#undecidable-instances" title="Permalink to this headline">¶</a></h3>
<p id="index-14">Sometimes even the termination rules of <a class="reference internal" href="#instance-termination"><span>Instance termination rules</span></a> are
too onerous. So GHC allows you to experiment with more liberal rules: if
you use the experimental flag <a class="reference internal" href="#ghc-flag--XUndecidableInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUndecidableInstances</span></code></a>, both the Paterson
Conditions and the Coverage
Condition (described in <a class="reference internal" href="#instance-termination"><span>Instance termination rules</span></a>) are lifted.
Termination is still ensured by having a fixed-depth recursion stack. If
you exceed the stack depth you get a sort of backtrace, and the
opportunity to increase the stack depth with
<code class="docutils literal"><span class="pre">-freduction-depth=⟨n⟩</span></code>. However, if you should exceed the default
reduction depth limit, it is probably best just to disable depth
checking, with <code class="docutils literal"><span class="pre">-freduction-depth=0</span></code>. The exact depth your program
requires depends on minutiae of your code, and it may change between
minor GHC releases. The safest bet for released code &#8211; if you&#8217;re sure
that it should compile in finite time &#8211; is just to disable the check.</p>
<p>For example, sometimes you might want to use the following to get the
effect of a &#8220;class synonym&#8221;:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="p">(</span><span class="kt">C1</span> <span class="n">a</span><span class="p">,</span> <span class="kt">C2</span> <span class="n">a</span><span class="p">,</span> <span class="kt">C3</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span> <span class="p">{</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">C1</span> <span class="n">a</span><span class="p">,</span> <span class="kt">C2</span> <span class="n">a</span><span class="p">,</span> <span class="kt">C3</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>This allows you to write shorter signatures:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="o">...</span>
</pre></div>
</div>
<p>instead of</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">C1</span> <span class="n">a</span><span class="p">,</span> <span class="kt">C2</span> <span class="n">a</span><span class="p">,</span> <span class="kt">C3</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="o">...</span>
</pre></div>
</div>
<p>The restrictions on functional dependencies
(<a class="reference internal" href="#functional-dependencies"><span>Functional dependencies</span></a>) are particularly troublesome. It is
tempting to introduce type variables in the context that do not appear
in the head, something that is excluded by the normal rules. For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">HasConverter</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span>
   <span class="n">convert</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkFoo</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">HasConverter</span> <span class="n">a</span> <span class="n">b</span><span class="p">,</span><span class="kt">Show</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Foo</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
   <span class="n">show</span> <span class="p">(</span><span class="kt">MkFoo</span> <span class="n">value</span><span class="p">)</span> <span class="ow">=</span> <span class="n">show</span> <span class="p">(</span><span class="n">convert</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>This is dangerous territory, however. Here, for example, is a program
that would make the typechecker loop:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">D</span> <span class="n">a</span>
<span class="kr">class</span> <span class="kt">F</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span>
<span class="kr">instance</span> <span class="kt">F</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">D</span> <span class="n">c</span><span class="p">,</span> <span class="kt">F</span> <span class="n">a</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">D</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>   <span class="c1">-- &#39;c&#39; is not mentioned in the head</span>
</pre></div>
</div>
<p>Similarly, it can be tempting to lift the coverage condition:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Mul</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">|</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">.*.</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span>

<span class="kr">instance</span> <span class="kt">Mul</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kr">where</span> <span class="p">(</span><span class="o">.*.</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">Mul</span> <span class="kt">Int</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">where</span> <span class="n">x</span> <span class="o">.*.</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="kr">instance</span> <span class="kt">Mul</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=&gt;</span> <span class="kt">Mul</span> <span class="n">a</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="kr">where</span> <span class="n">x</span> <span class="o">.*.</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="n">x</span><span class="o">.*.</span><span class="p">)</span> <span class="n">v</span>
</pre></div>
</div>
<p>The third instance declaration does not obey the coverage condition; and
indeed the (somewhat strange) definition:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">=</span> <span class="nf">\</span> <span class="n">b</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">x</span> <span class="o">.*.</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="kr">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>makes instance inference go into a loop, because it requires the
constraint <code class="docutils literal"><span class="pre">(Mul</span> <span class="pre">a</span> <span class="pre">[b]</span> <span class="pre">b)</span></code>.</p>
<p>The <a class="reference internal" href="#ghc-flag--XUndecidableInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUndecidableInstances</span></code></a> flag is also used to lift some of the
restrictions imposed on type family instances. See
<a class="reference internal" href="#type-family-decidability"><span>Decidability of type synonym instances</span></a>.</p>
</div>
<div class="section" id="overlapping-instances">
<span id="instance-overlap"></span><h3>10.8.3.6. Overlapping instances<a class="headerlink" href="#overlapping-instances" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XOverlappingInstances">
<code class="descname">-XOverlappingInstances</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XOverlappingInstances" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--XIncoherentInstances">
<code class="descname">-XIncoherentInstances</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XIncoherentInstances" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated flags to weaken checks intended to ensure instance resolution
termination.</p>
</dd></dl>

<p>In general, as discussed in <a class="reference internal" href="#instance-resolution"><span>Instance resolution</span></a>, <em>GHC requires
that it be unambiguous which instance declaration should be used to
resolve a type-class constraint</em>. GHC also provides a way to to loosen
the instance resolution, by allowing more than one instance to match,
<em>provided there is a most specific one</em>. Moreover, it can be loosened
further, by allowing more than one instance to match irrespective of
whether there is a most specific one. This section gives the details.</p>
<p>To control the choice of instance, it is possible to specify the overlap
behavior for individual instances with a pragma, written immediately
after the <code class="docutils literal"><span class="pre">instance</span></code> keyword. The pragma may be one of:
<code class="docutils literal"><span class="pre">{-#</span> <span class="pre">OVERLAPPING</span> <span class="pre">#-}</span></code>, <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">OVERLAPPABLE</span> <span class="pre">#-}</span></code>, <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">OVERLAPS</span> <span class="pre">#-}</span></code>,
or <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">INCOHERENT</span> <span class="pre">#-}</span></code>.</p>
<p>The matching behaviour is also influenced by two module-level language
extension flags: <a class="reference internal" href="#ghc-flag--XOverlappingInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverlappingInstances</span></code></a> and
<a class="reference internal" href="#ghc-flag--XIncoherentInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XIncoherentInstances</span></code></a>. These flags are now
deprecated (since GHC 7.10) in favour of the fine-grained per-instance
pragmas.</p>
<p>A more precise specification is as follows. The willingness to be
overlapped or incoherent is a property of the <em>instance declaration</em>
itself, controlled as follows:</p>
<ul class="simple">
<li>An instance is <em>incoherent</em> if: it has an <code class="docutils literal"><span class="pre">INCOHERENT</span></code> pragma; or
if the instance has no pragma and it appears in a module compiled
with <a class="reference internal" href="#ghc-flag--XIncoherentInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XIncoherentInstances</span></code></a>.</li>
<li>An instance is <em>overlappable</em> if: it has an <code class="docutils literal"><span class="pre">OVERLAPPABLE</span></code> or
<code class="docutils literal"><span class="pre">OVERLAPS</span></code> pragma; or if the instance has no pragma and it appears
in a module compiled with <a class="reference internal" href="#ghc-flag--XOverlappingInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverlappingInstances</span></code></a>; or if the
instance is incoherent.</li>
<li>An instance is <em>overlapping</em> if: it has an <code class="docutils literal"><span class="pre">OVERLAPPING</span></code> or
<code class="docutils literal"><span class="pre">OVERLAPS</span></code> pragma; or if the instance has no pragma and it appears
in a module compiled with <a class="reference internal" href="#ghc-flag--XOverlappingInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverlappingInstances</span></code></a>; or if the
instance is incoherent.</li>
</ul>
<p>Now suppose that, in some client module, we are searching for an
instance of the <em>target constraint</em> <code class="docutils literal"><span class="pre">(C</span> <span class="pre">ty1</span> <span class="pre">..</span> <span class="pre">tyn)</span></code>. The search works
like this:</p>
<ul class="simple">
<li>Find all instances I that <em>match</em> the target constraint; that is, the
target constraint is a substitution instance of I. These instance
declarations are the <em>candidates</em>.</li>
<li>Eliminate any candidate IX for which both of the following hold:<ul>
<li>There is another candidate IY that is strictly more specific; that
is, IY is a substitution instance of IX but not vice versa.</li>
<li>Either IX is <em>overlappable</em>, or IY is <em>overlapping</em>. (This
&#8220;either/or&#8221; design, rather than a &#8220;both/and&#8221; design, allow a
client to deliberately override an instance from a library,
without requiring a change to the library.)</li>
</ul>
</li>
<li>If exactly one non-incoherent candidate remains, select it. If all
remaining candidates are incoherent, select an arbitrary one.
Otherwise the search fails (i.e. when more than one surviving
candidate is not incoherent).</li>
<li>If the selected candidate (from the previous step) is incoherent, the
search succeeds, returning that candidate.</li>
<li>If not, find all instances that <em>unify</em> with the target constraint,
but do not <em>match</em> it. Such non-candidate instances might match when
the target constraint is further instantiated. If all of them are
incoherent, the search succeeds, returning the selected candidate; if
not, the search fails.</li>
</ul>
<p>Notice that these rules are not influenced by flag settings in the
client module, where the instances are <em>used</em>. These rules make it
possible for a library author to design a library that relies on
overlapping instances without the client having to know.</p>
<p>Errors are reported <em>lazily</em> (when attempting to solve a constraint),
rather than <em>eagerly</em> (when the instances themselves are defined).
Consider, for example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="kt">Int</span>  <span class="n">b</span> <span class="kr">where</span> <span class="o">..</span>
<span class="kr">instance</span> <span class="kt">C</span> <span class="n">a</span> <span class="kt">Bool</span> <span class="kr">where</span> <span class="o">..</span>
</pre></div>
</div>
<p>These potentially overlap, but GHC will not complain about the instance
declarations themselves, regardless of flag settings. If we later try to
solve the constraint <code class="docutils literal"><span class="pre">(C</span> <span class="pre">Int</span> <span class="pre">Char)</span></code> then only the first instance
matches, and all is well. Similarly with <code class="docutils literal"><span class="pre">(C</span> <span class="pre">Bool</span> <span class="pre">Bool)</span></code>. But if we
try to solve <code class="docutils literal"><span class="pre">(C</span> <span class="pre">Int</span> <span class="pre">Bool)</span></code>, both instances match and an error is
reported.</p>
<p>As a more substantial example of the rules in action, consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="cm">{-# OVERLAPPABLE #-}</span> <span class="n">context1</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="kt">Int</span> <span class="n">b</span>     <span class="kr">where</span> <span class="o">...</span>  <span class="c1">-- (A)</span>
<span class="kr">instance</span> <span class="cm">{-# OVERLAPPABLE #-}</span> <span class="n">context2</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">a</span>   <span class="kt">Bool</span>  <span class="kr">where</span> <span class="o">...</span>  <span class="c1">-- (B)</span>
<span class="kr">instance</span> <span class="cm">{-# OVERLAPPABLE #-}</span> <span class="n">context3</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">a</span>   <span class="p">[</span><span class="n">b</span><span class="p">]</span>   <span class="kr">where</span> <span class="o">...</span>  <span class="c1">-- (C)</span>
<span class="kr">instance</span> <span class="cm">{-# OVERLAPPING  #-}</span> <span class="n">context4</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="kt">Int</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="kr">where</span> <span class="o">...</span>  <span class="c1">-- (D)</span>
</pre></div>
</div>
<p>Now suppose that the type inference engine needs to solve the constraint
<code class="docutils literal"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">[Int]</span></code>. This constraint matches instances (A), (C) and (D), but
the last is more specific, and hence is chosen.</p>
<p>If (D) did not exist then (A) and (C) would still be matched, but
neither is most specific. In that case, the program would be rejected,
unless <a class="reference internal" href="#ghc-flag--XIncoherentInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XIncoherentInstances</span></code></a> is enabled, in which case it would be
accepted and (A) or (C) would be chosen arbitrarily.</p>
<p>An instance declaration is <em>more specific</em> than another iff the head of
former is a substitution instance of the latter. For example (D) is
&#8220;more specific&#8221; than (C) because you can get from (C) to (D) by
substituting <code class="docutils literal"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">Int</span></code>.</p>
<p>GHC is conservative about committing to an overlapping instance. For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Suppose that from the RHS of <code class="docutils literal"><span class="pre">f</span></code> we get the constraint <code class="docutils literal"><span class="pre">C</span> <span class="pre">b</span> <span class="pre">[b]</span></code>.
But GHC does not commit to instance (C), because in a particular call of
<code class="docutils literal"><span class="pre">f</span></code>, <code class="docutils literal"><span class="pre">b</span></code> might be instantiate to <code class="docutils literal"><span class="pre">Int</span></code>, in which case instance (D)
would be more specific still. So GHC rejects the program.</p>
<p>If, however, you add the flag <a class="reference internal" href="#ghc-flag--XIncoherentInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XIncoherentInstances</span></code></a> when compiling
the module that contains (D), GHC will instead pick (C), without
complaining about the problem of subsequent instantiations.</p>
<p>Notice that we gave a type signature to <code class="docutils literal"><span class="pre">f</span></code>, so GHC had to <em>check</em>
that <code class="docutils literal"><span class="pre">f</span></code> has the specified type. Suppose instead we do not give a type
signature, asking GHC to <em>infer</em> it instead. In this case, GHC will
refrain from simplifying the constraint <code class="docutils literal"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">[b]</span></code> (for the same
reason as before) but, rather than rejecting the program, it will infer
the type</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">C</span> <span class="n">b</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</pre></div>
</div>
<p>That postpones the question of which instance to pick to the call site
for <code class="docutils literal"><span class="pre">f</span></code> by which time more is known about the type <code class="docutils literal"><span class="pre">b</span></code>. You can
write this type signature yourself if you use the
<a class="reference internal" href="#ghc-flag--XFlexibleContexts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleContexts</span></code></a> flag.</p>
<p>Exactly the same situation can arise in instance declarations
themselves. Suppose we have</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="kr">where</span>
   <span class="n">f</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Foo</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="kr">where</span>
   <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>and, as before, the constraint <code class="docutils literal"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">[b]</span></code> arises from <code class="docutils literal"><span class="pre">f</span></code>&#8216;s right
hand side. GHC will reject the instance, complaining as before that it
does not know how to resolve the constraint <code class="docutils literal"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">[b]</span></code>, because it
matches more than one instance declaration. The solution is to postpone
the choice by adding the constraint to the context of the instance
declaration, thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="kt">Int</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">=&gt;</span> <span class="kt">Foo</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="kr">where</span>
   <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>(You need <a class="reference internal" href="#ghc-flag--XFlexibleInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleInstances</span></code></a> to do this.)</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Overlapping instances must be used with care. They can give
rise to incoherence (i.e. different instance choices are made in
different parts of the program) even without <a class="reference internal" href="#ghc-flag--XIncoherentInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XIncoherentInstances</span></code></a>.
Consider:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE OverlappingInstances #-}</span>
<span class="kr">module</span> <span class="nn">Help</span> <span class="kr">where</span>

    <span class="kr">class</span> <span class="kt">MyShow</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">myshow</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>

    <span class="kr">instance</span> <span class="kt">MyShow</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">MyShow</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">myshow</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">concatMap</span> <span class="n">myshow</span> <span class="n">xs</span>

    <span class="n">showHelp</span> <span class="ow">::</span> <span class="kt">MyShow</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
    <span class="n">showHelp</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">myshow</span> <span class="n">xs</span>

<span class="cm">{-# LANGUAGE FlexibleInstances, OverlappingInstances #-}</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>
    <span class="kr">import</span> <span class="nn">Help</span>

    <span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">MkT</span>

    <span class="kr">instance</span> <span class="kt">MyShow</span> <span class="kt">T</span> <span class="kr">where</span>
    <span class="n">myshow</span> <span class="n">x</span> <span class="ow">=</span> <span class="s">&quot;Used generic instance&quot;</span>

    <span class="kr">instance</span> <span class="kt">MyShow</span> <span class="p">[</span><span class="kt">T</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">myshow</span> <span class="n">xs</span> <span class="ow">=</span> <span class="s">&quot;Used more specific instance&quot;</span>

    <span class="n">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">print</span> <span class="p">(</span><span class="n">myshow</span> <span class="p">[</span><span class="kt">MkT</span><span class="p">]);</span> <span class="n">print</span> <span class="p">(</span><span class="n">showHelp</span> <span class="p">[</span><span class="kt">MkT</span><span class="p">])</span> <span class="p">}</span>
</pre></div>
</div>
<p>In function <code class="docutils literal"><span class="pre">showHelp</span></code> GHC sees no overlapping instances, and so uses
the <code class="docutils literal"><span class="pre">MyShow</span> <span class="pre">[a]</span></code> instance without complaint. In the call to <code class="docutils literal"><span class="pre">myshow</span></code>
in <code class="docutils literal"><span class="pre">main</span></code>, GHC resolves the <code class="docutils literal"><span class="pre">MyShow</span> <span class="pre">[T]</span></code> constraint using the
overlapping instance declaration in module <code class="docutils literal"><span class="pre">Main</span></code>. As a result, the
program prints</p>
<div class="highlight-none"><div class="highlight"><pre>&quot;Used more specific instance&quot;
&quot;Used generic instance&quot;
</pre></div>
</div>
<p class="last">(An alternative possible behaviour, not currently implemented, would be
to reject module <code class="docutils literal"><span class="pre">Help</span></code> on the grounds that a later instance
declaration might overlap the local one.)</p>
</div>
</div>
<div class="section" id="instance-signatures-type-signatures-in-instance-declarations">
<span id="instance-sigs"></span><h3>10.8.3.7. Instance signatures: type signatures in instance declarations<a class="headerlink" href="#instance-signatures-type-signatures-in-instance-declarations" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XInstanceSigs">
<code class="descname">-XInstanceSigs</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XInstanceSigs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.6.1</td>
</tr>
</tbody>
</table>
<p>Allow type signatures for members in instance definitions.</p>
</dd></dl>

<p>In Haskell, you can&#8217;t write a type signature in an instance declaration,
but it is sometimes convenient to do so, and the language extension
<a class="reference internal" href="#ghc-flag--XInstanceSigs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XInstanceSigs</span></code></a> allows you to do so. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="n">a</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>   <span class="c1">-- The signature</span>
  <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="p">(</span><span class="kt">MkT</span> <span class="n">x1</span> <span class="n">x2</span><span class="p">)</span> <span class="p">(</span><span class="kt">MkTy</span> <span class="n">y1</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x1</span><span class="o">==</span><span class="n">y1</span> <span class="o">&amp;&amp;</span> <span class="n">x2</span><span class="o">==</span><span class="n">y2</span>
</pre></div>
</div>
<p>Some details</p>
<ul>
<li><p class="first">The type signature in the instance declaration must be more
polymorphic than (or the same as) the one in the class declaration,
instantiated with the instance type. For example, this is fine:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
   <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
   <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Here the signature in the instance declaration is more polymorphic
than that required by the instantiated class method.</p>
</li>
<li><p class="first">The code for the method in the instance declaration is typechecked
against the type signature supplied in the instance declaration, as
you would expect. So if the instance signature is more polymorphic
than required, the code must be too.</p>
</li>
<li><p class="first">One stylistic reason for wanting to write a type signature is simple
documentation. Another is that you may want to bring scoped type
variables into scope. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">foo</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="n">b</span><span class="p">])</span>

<span class="kr">instance</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">foo</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="n">b</span><span class="p">])</span>
  <span class="n">foo</span> <span class="n">x</span> <span class="p">(</span><span class="kt">T</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">T</span> <span class="n">y</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
     <span class="kr">where</span>
       <span class="n">xs</span> <span class="ow">::</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
       <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>Provided that you also specify <a class="reference internal" href="#ghc-flag--XScopedTypeVariables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XScopedTypeVariables</span></code></a>
(<a class="reference internal" href="#scoped-type-variables"><span>Lexically scoped type variables</span></a>), the <code class="docutils literal"><span class="pre">forall</span> <span class="pre">b</span></code> scopes over the
definition of <code class="docutils literal"><span class="pre">foo</span></code>, and in particular over the type signature for
<code class="docutils literal"><span class="pre">xs</span></code>.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="overloaded-string-literals">
<span id="overloaded-strings"></span><h2>10.8.4. Overloaded string literals<a class="headerlink" href="#overloaded-string-literals" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XOverloadedStrings">
<code class="descname">-XOverloadedStrings</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XOverloadedStrings" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable overloaded string literals (e.g. string literals desugared via the
<code class="docutils literal"><span class="pre">IsString</span></code> class).</p>
</dd></dl>

<p>GHC supports <em>overloaded string literals</em>. Normally a string literal has
type <code class="docutils literal"><span class="pre">String</span></code>, but with overloaded string literals enabled (with
<a class="reference internal" href="#ghc-flag--XOverloadedStrings"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverloadedStrings</span></code></a>) a string literal has type
<code class="docutils literal"><span class="pre">(IsString</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code>.</p>
<p>This means that the usual string syntax can be used, e.g., for
<code class="docutils literal"><span class="pre">ByteString</span></code>, <code class="docutils literal"><span class="pre">Text</span></code>, and other variations of string like types.
String literals behave very much like integer literals, i.e., they can
be used in both expressions and patterns. If used in a pattern the
literal will be replaced by an equality test, in the same way as an
integer literal is.</p>
<p>The class <code class="docutils literal"><span class="pre">IsString</span></code> is defined as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">IsString</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">fromString</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>The only predefined instance is the obvious one to make strings work as
usual:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">IsString</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">fromString</span> <span class="n">cs</span> <span class="ow">=</span> <span class="n">cs</span>
</pre></div>
</div>
<p>The class <code class="docutils literal"><span class="pre">IsString</span></code> is not in scope by default. If you want to
mention it explicitly (for example, to give an instance declaration for
it), you can import it from module <code class="docutils literal"><span class="pre">GHC.Exts</span></code>.</p>
<p>Haskell&#8217;s defaulting mechanism (<a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.3.4">Haskell Report, Section
4.3.4</a>) is
extended to cover string literals, when <a class="reference internal" href="#ghc-flag--XOverloadedStrings"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverloadedStrings</span></code></a> is
specified. Specifically:</p>
<ul class="simple">
<li>Each type in a <code class="docutils literal"><span class="pre">default</span></code> declaration must be an instance of <code class="docutils literal"><span class="pre">Num</span></code>
<em>or</em> of <code class="docutils literal"><span class="pre">IsString</span></code>.</li>
<li>If no <code class="docutils literal"><span class="pre">default</span></code> declaration is given, then it is just as if the
module contained the declaration
<code class="docutils literal"><span class="pre">default(</span> <span class="pre">Integer,</span> <span class="pre">Double,</span> <span class="pre">String)</span></code>.</li>
<li>The standard defaulting rule is extended thus: defaulting applies
when all the unresolved constraints involve standard classes <em>or</em>
<code class="docutils literal"><span class="pre">IsString</span></code>; and at least one is a numeric class <em>or</em> <code class="docutils literal"><span class="pre">IsString</span></code>.</li>
</ul>
<p>So, for example, the expression <code class="docutils literal"><span class="pre">length</span> <span class="pre">&quot;foo&quot;</span></code> will give rise to an
ambiguous use of <code class="docutils literal"><span class="pre">IsString</span> <span class="pre">a0</span></code> which, because of the above rules, will
default to <code class="docutils literal"><span class="pre">String</span></code>.</p>
<p>A small example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">GHC.Exts</span><span class="p">(</span> <span class="kt">IsString</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">MyString</span> <span class="ow">=</span> <span class="kt">MyString</span> <span class="kt">String</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">IsString</span> <span class="kt">MyString</span> <span class="kr">where</span>
    <span class="n">fromString</span> <span class="ow">=</span> <span class="kt">MyString</span>

<span class="nf">greet</span> <span class="ow">::</span> <span class="kt">MyString</span> <span class="ow">-&gt;</span> <span class="kt">MyString</span>
<span class="nf">greet</span> <span class="s">&quot;hello&quot;</span> <span class="ow">=</span> <span class="s">&quot;world&quot;</span>
<span class="nf">greet</span> <span class="n">other</span> <span class="ow">=</span> <span class="n">other</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">greet</span> <span class="s">&quot;hello&quot;</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">greet</span> <span class="s">&quot;fool&quot;</span>
</pre></div>
</div>
<p>Note that deriving <code class="docutils literal"><span class="pre">Eq</span></code> is necessary for the pattern matching to work
since it gets translated into an equality comparison.</p>
</div>
<div class="section" id="overloaded-labels">
<span id="id30"></span><h2>10.8.5. Overloaded labels<a class="headerlink" href="#overloaded-labels" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XOverloadedLabels">
<code class="descname">-XOverloadedLabels</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XOverloadedLabels" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Enable use of the <code class="docutils literal"><span class="pre">#foo</span></code> overloaded label syntax.</p>
</dd></dl>

<p>GHC supports <em>overloaded labels</em>, a form of identifier whose interpretation may
depend both on its type and on its literal text.  When the
<a class="reference internal" href="#ghc-flag--XOverloadedLabels"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverloadedLabels</span></code></a> extension is enabled, an overloaded label can written
with a prefix hash, for example <code class="docutils literal"><span class="pre">#foo</span></code>.  The type of this expression is
<code class="docutils literal"><span class="pre">IsLabel</span> <span class="pre">&quot;foo&quot;</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code>.</p>
<p>The class <code class="docutils literal"><span class="pre">IsLabel</span></code> is defined as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">IsLabel</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="kt">Symbol</span><span class="p">)</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">fromLabel</span> <span class="ow">::</span> <span class="n">a</span>
</pre></div>
</div>
<p>This is rather similar to the class <code class="docutils literal"><span class="pre">IsString</span></code> (see
<a class="reference internal" href="#overloaded-strings"><span>Overloaded string literals</span></a>), but with an additional type parameter that makes the
text of the label available as a type-level string (see
<a class="reference internal" href="#type-level-literals"><span>Type-Level Literals</span></a>).  Note that <code class="docutils literal"><span class="pre">fromLabel</span></code> had an extra <code class="docutils literal"><span class="pre">Proxy#</span> <span class="pre">x</span></code>
argument in GHC 8.0, but this was removed in GHC 8.2 as a type application (see
<a class="reference internal" href="#visible-type-application"><span>Visible type application</span></a>) can be used instead.</p>
<p>There are no predefined instances of this class.  It is not in scope by default,
but can be brought into scope by importing
<a class="reference external" href="../libraries/base-4.10.1.0/GHC-OverloadedLabels.html">GHC.OverloadedLabels</a>.  Unlike
<code class="docutils literal"><span class="pre">IsString</span></code>, there are no special defaulting rules for <code class="docutils literal"><span class="pre">IsLabel</span></code>.</p>
<p>During typechecking, GHC will replace an occurrence of an overloaded label like
<code class="docutils literal"><span class="pre">#foo</span></code> with <code class="docutils literal"><span class="pre">fromLabel</span> <span class="pre">&#64;&quot;foo&quot;</span></code>.  This will have some type <code class="docutils literal"><span class="pre">alpha</span></code> and
require the solution of a class constraint <code class="docutils literal"><span class="pre">IsLabel</span> <span class="pre">&quot;foo&quot;</span> <span class="pre">alpha</span></code>.</p>
<p>The intention is for <code class="docutils literal"><span class="pre">IsLabel</span></code> to be used to support overloaded record fields
and perhaps anonymous records.  Thus, it may be given instances for base
datatypes (in particular <code class="docutils literal"><span class="pre">(-&gt;)</span></code>) in the future.</p>
<p>If <a class="reference internal" href="#ghc-flag--XRebindableSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRebindableSyntax</span></code></a> is enabled, overloaded
labels will be desugared using whatever <code class="docutils literal"><span class="pre">fromLabel</span></code> function is in scope,
rather than always using <code class="docutils literal"><span class="pre">GHC.OverloadedLabels.fromLabel</span></code>.</p>
<p>When writing an overloaded label, there must be no space between the hash sign
and the following identifier.  The <a class="reference internal" href="#ghc-flag--XMagicHash"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMagicHash</span></code></a> extension makes use
of postfix hash signs; if <a class="reference internal" href="#ghc-flag--XOverloadedLabels"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverloadedLabels</span></code></a> and
<a class="reference internal" href="#ghc-flag--XMagicHash"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMagicHash</span></code></a> are both enabled then <code class="docutils literal"><span class="pre">x#y</span></code> means <code class="docutils literal"><span class="pre">x#</span> <span class="pre">y</span></code>, but if
only <a class="reference internal" href="#ghc-flag--XOverloadedLabels"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverloadedLabels</span></code></a> is enabled then it means <code class="docutils literal"><span class="pre">x</span> <span class="pre">#y</span></code>.  The
<a class="reference internal" href="#ghc-flag--XUnboxedTuples"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUnboxedTuples</span></code></a> extension makes <code class="docutils literal"><span class="pre">(#</span></code> a single lexeme, so when
<a class="reference internal" href="#ghc-flag--XUnboxedTuples"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUnboxedTuples</span></code></a> is enabled you must write a space between an opening
parenthesis and an overloaded label.  To avoid confusion, you are strongly
encouraged to put a space before the hash when using
<a class="reference internal" href="#ghc-flag--XOverloadedLabels"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverloadedLabels</span></code></a>.</p>
<p>When using <a class="reference internal" href="#ghc-flag--XOverloadedLabels"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverloadedLabels</span></code></a> (or other extensions that make use of
hash signs) in a <code class="docutils literal"><span class="pre">.hsc</span></code> file (see <a class="reference internal" href="utils.html#hsc2hs"><span>Writing Haskell interfaces to C code: hsc2hs</span></a>), the hash signs must be
doubled (write <code class="docutils literal"><span class="pre">##foo</span></code> instead of <code class="docutils literal"><span class="pre">#foo</span></code>) to avoid them being treated as
<code class="docutils literal"><span class="pre">hsc2hs</span></code> directives.</p>
<p>Here is an extension of the record access example in <a class="reference internal" href="#type-level-literals"><span>Type-Level Literals</span></a>
showing how an overloaded label can be used as a record selector:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE DataKinds, KindSignatures, MultiParamTypeClasses,</span>
<span class="cm">             FunctionalDependencies, FlexibleInstances,</span>
<span class="cm">             OverloadedLabels, ScopedTypeVariables #-}</span>

<span class="kr">import</span> <span class="nn">GHC.OverloadedLabels</span> <span class="p">(</span><span class="kt">IsLabel</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">GHC.TypeLits</span> <span class="p">(</span><span class="kt">Symbol</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Label</span> <span class="p">(</span><span class="n">l</span> <span class="ow">::</span> <span class="kt">Symbol</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Get</span>

<span class="kr">class</span> <span class="kt">Has</span> <span class="n">a</span> <span class="n">l</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="n">l</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="n">from</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Label</span> <span class="n">l</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">instance</span> <span class="kt">Has</span> <span class="kt">Point</span> <span class="s">&quot;x&quot;</span> <span class="kt">Int</span> <span class="kr">where</span> <span class="n">from</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="kr">_</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">x</span>
<span class="kr">instance</span> <span class="kt">Has</span> <span class="kt">Point</span> <span class="s">&quot;y&quot;</span> <span class="kt">Int</span> <span class="kr">where</span> <span class="n">from</span> <span class="p">(</span><span class="kt">Point</span> <span class="kr">_</span> <span class="n">y</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">y</span>

<span class="kr">instance</span> <span class="kt">Has</span> <span class="n">a</span> <span class="n">l</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">IsLabel</span> <span class="n">l</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fromLabel</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">from</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Get</span> <span class="ow">::</span> <span class="kt">Label</span> <span class="n">l</span><span class="p">)</span>

<span class="nf">example</span> <span class="ow">=</span> <span class="o">#</span><span class="n">x</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="overloaded-lists">
<span id="id31"></span><h2>10.8.6. Overloaded lists<a class="headerlink" href="#overloaded-lists" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XOverloadedLists">
<code class="descname">-XOverloadedLists</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XOverloadedLists" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.8.1</td>
</tr>
</tbody>
</table>
<p>Enable overloaded list syntax (e.g. desugaring of lists via the
<code class="docutils literal"><span class="pre">IsList</span></code> class).</p>
</dd></dl>

<p>GHC supports <em>overloading of the list notation</em>. Let us recap the
notation for constructing lists. In Haskell, the list notation can be be
used in the following seven ways:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">[]</span>          <span class="c1">-- Empty list</span>
<span class="p">[</span><span class="n">x</span><span class="p">]</span>         <span class="c1">-- x : []</span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>     <span class="c1">-- x : y : z : []</span>
<span class="p">[</span><span class="n">x</span> <span class="o">..</span> <span class="p">]</span>     <span class="c1">-- enumFrom x</span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">..</span><span class="p">]</span>    <span class="c1">-- enumFromThen x y</span>
<span class="p">[</span><span class="n">x</span> <span class="o">..</span> <span class="n">y</span><span class="p">]</span>    <span class="c1">-- enumFromTo x y</span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">..</span> <span class="n">z</span><span class="p">]</span>  <span class="c1">-- enumFromThenTo x y z</span>
</pre></div>
</div>
<p>When the <code class="docutils literal"><span class="pre">OverloadedLists</span></code> extension is turned on, the aforementioned
seven notations are desugared as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">[]</span>          <span class="c1">-- fromListN 0 []</span>
<span class="p">[</span><span class="n">x</span><span class="p">]</span>         <span class="c1">-- fromListN 1 (x : [])</span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>     <span class="c1">-- fromListN 3 (x : y : z : [])</span>
<span class="p">[</span><span class="n">x</span> <span class="o">..</span> <span class="p">]</span>     <span class="c1">-- fromList (enumFrom x)</span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">..</span><span class="p">]</span>    <span class="c1">-- fromList (enumFromThen x y)</span>
<span class="p">[</span><span class="n">x</span> <span class="o">..</span> <span class="n">y</span><span class="p">]</span>    <span class="c1">-- fromList (enumFromTo x y)</span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">..</span> <span class="n">z</span><span class="p">]</span>  <span class="c1">-- fromList (enumFromThenTo x y z)</span>
</pre></div>
</div>
<p>This extension allows programmers to use the list notation for
construction of structures like: <code class="docutils literal"><span class="pre">Set</span></code>, <code class="docutils literal"><span class="pre">Map</span></code>, <code class="docutils literal"><span class="pre">IntMap</span></code>,
<code class="docutils literal"><span class="pre">Vector</span></code>, <code class="docutils literal"><span class="pre">Text</span></code> and <code class="docutils literal"><span class="pre">Array</span></code>. The following code listing gives a
few examples:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="sc">&#39;0&#39;</span> <span class="o">..</span> <span class="sc">&#39;9&#39;</span><span class="p">]</span>             <span class="ow">::</span> <span class="kt">Set</span> <span class="kt">Char</span>
<span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">]</span>                <span class="ow">::</span> <span class="kt">Vector</span> <span class="kt">Int</span>
<span class="p">[(</span><span class="s">&quot;default&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">k1</span><span class="p">,</span><span class="n">v1</span><span class="p">)]</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="p">[</span><span class="sc">&#39;a&#39;</span> <span class="o">..</span> <span class="sc">&#39;z&#39;</span><span class="p">]</span>             <span class="ow">::</span> <span class="kt">Text</span>
</pre></div>
</div>
<p>List patterns are also overloaded. When the <code class="docutils literal"><span class="pre">OverloadedLists</span></code>
extension is turned on, these definitions are desugared as follows</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="o">...</span>          <span class="c1">-- f (toList -&gt; []) = ...</span>
<span class="nf">g</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="ow">=</span> <span class="o">...</span>     <span class="c1">-- g (toList -&gt; [x,y,z]) = ...</span>
</pre></div>
</div>
<p>(Here we are using view-pattern syntax for the translation, see
<a class="reference internal" href="#view-patterns"><span>View patterns</span></a>.)</p>
<div class="section" id="the-islist-class">
<h3>10.8.6.1. The <code class="docutils literal"><span class="pre">IsList</span></code> class<a class="headerlink" href="#the-islist-class" title="Permalink to this headline">¶</a></h3>
<p>In the above desugarings, the functions <code class="docutils literal"><span class="pre">toList</span></code>, <code class="docutils literal"><span class="pre">fromList</span></code> and
<code class="docutils literal"><span class="pre">fromListN</span></code> are all methods of the <code class="docutils literal"><span class="pre">IsList</span></code> class, which is itself
exported from the <code class="docutils literal"><span class="pre">GHC.Exts</span></code> module. The type class is defined as
follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">IsList</span> <span class="n">l</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Item</span> <span class="n">l</span>

  <span class="n">fromList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Item</span> <span class="n">l</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">l</span>
  <span class="n">toList</span>   <span class="ow">::</span> <span class="n">l</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Item</span> <span class="n">l</span><span class="p">]</span>

  <span class="n">fromListN</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Item</span> <span class="n">l</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">l</span>
  <span class="n">fromListN</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">fromList</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">IsList</span></code> class and its methods are intended to be used in
conjunction with the <code class="docutils literal"><span class="pre">OverloadedLists</span></code> extension.</p>
<ul class="simple">
<li>The type function <code class="docutils literal"><span class="pre">Item</span></code> returns the type of items of the structure
<code class="docutils literal"><span class="pre">l</span></code>.</li>
<li>The function <code class="docutils literal"><span class="pre">fromList</span></code> constructs the structure <code class="docutils literal"><span class="pre">l</span></code> from the
given list of <code class="docutils literal"><span class="pre">Item</span> <span class="pre">l</span></code>.</li>
<li>The function <code class="docutils literal"><span class="pre">fromListN</span></code> takes the input list&#8217;s length as a hint.
Its behaviour should be equivalent to <code class="docutils literal"><span class="pre">fromList</span></code>. The hint can be
used for more efficient construction of the structure <code class="docutils literal"><span class="pre">l</span></code> compared
to <code class="docutils literal"><span class="pre">fromList</span></code>. If the given hint is not equal to the input list&#8217;s
length the behaviour of <code class="docutils literal"><span class="pre">fromListN</span></code> is not specified.</li>
<li>The function <code class="docutils literal"><span class="pre">toList</span></code> should be the inverse of <code class="docutils literal"><span class="pre">fromList</span></code>.</li>
</ul>
<p>It is perfectly fine to declare new instances of <code class="docutils literal"><span class="pre">IsList</span></code>, so that
list notation becomes useful for completely new data types. Here are
several example instances:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">IsList</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Item</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">=</span> <span class="n">a</span>
  <span class="n">fromList</span> <span class="ow">=</span> <span class="n">id</span>
  <span class="n">toList</span> <span class="ow">=</span> <span class="n">id</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">IsList</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Item</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>
  <span class="n">fromList</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span>
  <span class="n">toList</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">toList</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">IsList</span> <span class="p">(</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Item</span> <span class="p">(</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
  <span class="n">fromList</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span>
  <span class="n">toList</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span>

<span class="kr">instance</span> <span class="kt">IsList</span> <span class="p">(</span><span class="kt">IntMap</span> <span class="n">v</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Item</span> <span class="p">(</span><span class="kt">IntMap</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
  <span class="n">fromList</span> <span class="ow">=</span> <span class="kt">IntMap</span><span class="o">.</span><span class="n">fromList</span>
  <span class="n">toList</span> <span class="ow">=</span> <span class="kt">IntMap</span><span class="o">.</span><span class="n">toList</span>

<span class="kr">instance</span> <span class="kt">IsList</span> <span class="kt">Text</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Item</span> <span class="kt">Text</span> <span class="ow">=</span> <span class="kt">Char</span>
  <span class="n">fromList</span> <span class="ow">=</span> <span class="kt">Text</span><span class="o">.</span><span class="n">pack</span>
  <span class="n">toList</span> <span class="ow">=</span> <span class="kt">Text</span><span class="o">.</span><span class="n">unpack</span>

<span class="kr">instance</span> <span class="kt">IsList</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Item</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>
  <span class="n">fromList</span>  <span class="ow">=</span> <span class="kt">Vector</span><span class="o">.</span><span class="n">fromList</span>
  <span class="n">fromListN</span> <span class="ow">=</span> <span class="kt">Vector</span><span class="o">.</span><span class="n">fromListN</span>
  <span class="n">toList</span> <span class="ow">=</span> <span class="kt">Vector</span><span class="o">.</span><span class="n">toList</span>
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h3>10.8.6.2. Rebindable syntax<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>When desugaring list notation with <a class="reference internal" href="#ghc-flag--XOverloadedLists"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XOverloadedLists</span></code></a> GHC uses the
<code class="docutils literal"><span class="pre">fromList</span></code> (etc) methods from module <code class="docutils literal"><span class="pre">GHC.Exts</span></code>. You do not need to
import <code class="docutils literal"><span class="pre">GHC.Exts</span></code> for this to happen.</p>
<p>However if you use <a class="reference internal" href="#ghc-flag--XRebindableSyntax"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRebindableSyntax</span></code></a>, then GHC instead uses
whatever is in scope with the names of <code class="docutils literal"><span class="pre">toList</span></code>, <code class="docutils literal"><span class="pre">fromList</span></code> and
<code class="docutils literal"><span class="pre">fromListN</span></code>. That is, these functions are rebindable; c.f.
<a class="reference internal" href="#rebindable-syntax"><span>Rebindable syntax and the implicit Prelude import</span></a>.</p>
</div>
<div class="section" id="defaulting">
<h3>10.8.6.3. Defaulting<a class="headerlink" href="#defaulting" title="Permalink to this headline">¶</a></h3>
<p>Currently, the <code class="docutils literal"><span class="pre">IsList</span></code> class is not accompanied with defaulting
rules. Although feasible, not much thought has gone into how to specify
the meaning of the default declarations like:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">default</span> <span class="p">([</span><span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="speculation-about-the-future">
<h3>10.8.6.4. Speculation about the future<a class="headerlink" href="#speculation-about-the-future" title="Permalink to this headline">¶</a></h3>
<p>The current implementation of the <code class="docutils literal"><span class="pre">OverloadedLists</span></code> extension can be
improved by handling the lists that are only populated with literals in
a special way. More specifically, the compiler could allocate such lists
statically using a compact representation and allow <code class="docutils literal"><span class="pre">IsList</span></code> instances
to take advantage of the compact representation. Equipped with this
capability the <code class="docutils literal"><span class="pre">OverloadedLists</span></code> extension will be in a good position
to subsume the <code class="docutils literal"><span class="pre">OverloadedStrings</span></code> extension (currently, as a special
case, string literals benefit from statically allocated compact
representation).</p>
</div>
</div>
<div class="section" id="undecidable-or-recursive-superclasses">
<h2>10.8.7. Undecidable (or recursive) superclasses<a class="headerlink" href="#undecidable-or-recursive-superclasses" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XUndecidableSuperClasses">
<code class="descname">-XUndecidableSuperClasses</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XUndecidableSuperClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Allow all superclass constraints, including those that may result in
non-termination of the typechecker.</p>
</dd></dl>

<p>The language extension <a class="reference internal" href="#ghc-flag--XUndecidableSuperClasses"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUndecidableSuperClasses</span></code></a> allows much more flexible
constraints in superclasses.</p>
<p>A class cannot generally have itself as a superclass. So this is illegal</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">D</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">class</span> <span class="kt">D</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>GHC implements this test conservatively when type functions, or type variables,
are involved. For example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">F</span> <span class="n">a</span> <span class="ow">::</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">F</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>GHC will complain about this, because you might later add</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">C</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>and now we&#8217;d be in a superclass loop.  Here&#8217;s an example involving a type variable</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="n">f</span> <span class="p">(</span><span class="kt">C</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">f</span>
<span class="kr">class</span> <span class="n">c</span>       <span class="ow">=&gt;</span> <span class="kt">Id</span> <span class="n">c</span>
</pre></div>
</div>
<p>If we expanded the superclasses of <code class="docutils literal"><span class="pre">C</span> <span class="pre">Id</span></code> we&#8217;d get first <code class="docutils literal"><span class="pre">Id</span> <span class="pre">(C</span> <span class="pre">Id)</span></code> and
thence <code class="docutils literal"><span class="pre">C</span> <span class="pre">Id</span></code> again.</p>
<p>But superclass constraints like these are sometimes useful, and the conservative
check is annoying where no actual recursion is involved.</p>
<p>Moreover genuninely-recursive superclasses are sometimes useful. Here&#8217;s a real-life
example (Trac #10318)</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="p">(</span><span class="kt">Frac</span> <span class="p">(</span><span class="kt">Frac</span> <span class="n">a</span><span class="p">)</span> <span class="o">~</span> <span class="kt">Frac</span> <span class="n">a</span><span class="p">,</span>
       <span class="kt">Fractional</span> <span class="p">(</span><span class="kt">Frac</span> <span class="n">a</span><span class="p">),</span>
       <span class="kt">IntegralDomain</span> <span class="p">(</span><span class="kt">Frac</span> <span class="n">a</span><span class="p">))</span>
    <span class="ow">=&gt;</span> <span class="kt">IntegralDomain</span> <span class="n">a</span> <span class="kr">where</span>
 <span class="kr">type</span> <span class="kt">Frac</span> <span class="n">a</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div>
</div>
<p>Here the superclass cycle does terminate but it&#8217;s not entirely straightforward
to see that it does.</p>
<p>With the language extension <a class="reference internal" href="#ghc-flag--XUndecidableSuperClasses"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUndecidableSuperClasses</span></code></a> GHC lifts all restrictions
on superclass constraints. If there really <em>is</em> a loop, GHC will only
expand it to finite depth.</p>
</div>
</div>
<div class="section" id="type-families">
<span id="id33"></span><h1>10.9. Type families<a class="headerlink" href="#type-families" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XTypeFamilies">
<code class="descname">-XTypeFamilies</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XTypeFamilies" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XMonoLocalBinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonoLocalBinds</span></code></a>, <a class="reference internal" href="#ghc-flag--XKindSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XKindSignatures</span></code></a>,
<a class="reference internal" href="#ghc-flag--XExplicitNamespaces"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitNamespaces</span></code></a></td>
</tr>
</tbody>
</table>
<p>Allow use and definition of indexed type and data families.</p>
</dd></dl>

<p>Indexed type families form an extension to facilitate type-level
programming. Type families are a generalisation of associated data types
<a class="reference internal" href="#assocdatatypes2005" id="id34">[AssocDataTypes2005]</a> and associated type synonyms
<a class="reference internal" href="#assoctypesyn2005" id="id35">[AssocTypeSyn2005]</a> Type families themselves are described in
Schrijvers 2008 <a class="reference internal" href="#typefamilies2008" id="id36">[TypeFamilies2008]</a>. Type families essentially provide
type-indexed data types and named functions on types, which are useful for
generic programming and highly parameterised library interfaces as well as
interfaces with enhanced static information, much like dependent types. They
might also be regarded as an alternative to functional dependencies, but provide
a more functional style of type-level programming than the relational style of
functional dependencies.</p>
<p>Indexed type families, or type families for short, are type constructors
that represent sets of types. Set members are denoted by supplying the
type family constructor with type parameters, which are called type
indices. The difference between vanilla parametrised type constructors
and family constructors is much like between parametrically polymorphic
functions and (ad-hoc polymorphic) methods of type classes. Parametric
polymorphic functions behave the same at all type instances, whereas
class methods can change their behaviour in dependence on the class type
parameters. Similarly, vanilla type constructors imply the same data
representation for all type instances, but family constructors can have
varying representation types for varying type indices.</p>
<p>Indexed type families come in three flavours: data families, open type
synonym families, and closed type synonym families. They are the indexed
family variants of algebraic data types and type synonyms, respectively.
The instances of data families can be data types and newtypes.</p>
<p>Type families are enabled by the flag <a class="reference internal" href="#ghc-flag--XTypeFamilies"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeFamilies</span></code></a>. Additional
information on the use of type families in GHC is available on <a class="reference external" href="http://www.haskell.org/haskellwiki/GHC/Indexed_types">the
Haskell wiki page on type
families</a>.</p>
<table class="docutils citation" frame="void" id="assocdatatypes2005" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id34">[AssocDataTypes2005]</a></td><td>“<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html">Associated Types with Class</a>”, M.
Chakravarty, G. Keller, S. Peyton Jones,
and S. Marlow. In Proceedings of “The 32nd Annual
ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages (POPL&#8216;05)”, pages 1-13, ACM
Press, 2005)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="assoctypesyn2005" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id35">[AssocTypeSyn2005]</a></td><td>“<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/CKP05.html">Type Associated Type
Synonyms</a>”. M.
Chakravarty, G. Keller, and S. Peyton Jones. In Proceedings of “The
Tenth ACM SIGPLAN International Conference on Functional Programming”,
ACM Press, pages 241-253, 2005).</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="typefamilies2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id36">[TypeFamilies2008]</a></td><td>“<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type Checking with Open Type
Functions</a>”,
T. Schrijvers, S. Peyton-Jones, M. Chakravarty, and M. Sulzmann, in
Proceedings of “ICFP 2008: The 13th ACM SIGPLAN International Conference
on Functional Programming”, ACM Press, pages 51-62, 2008.</td></tr>
</tbody>
</table>
<div class="section" id="data-families">
<span id="id37"></span><h2>10.9.1. Data families<a class="headerlink" href="#data-families" title="Permalink to this headline">¶</a></h2>
<p>Data families appear in two flavours: (1) they can be defined on the
toplevel or (2) they can appear inside type classes (in which case they
are known as associated types). The former is the more general variant,
as it lacks the requirement for the type-indexes to coincide with the
class parameters. However, the latter can lead to more clearly
structured code and compiler warnings if some type instances were -
possibly accidentally - omitted. In the following, we always discuss the
general toplevel form first and then cover the additional constraints
placed on associated types.</p>
<div class="section" id="data-family-declarations">
<span id="id38"></span><h3>10.9.1.1. Data family declarations<a class="headerlink" href="#data-family-declarations" title="Permalink to this headline">¶</a></h3>
<p>Indexed data families are introduced by a signature, such as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">family</span> <span class="kt">GMap</span> <span class="n">k</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div>
</div>
<p>The special <code class="docutils literal"><span class="pre">family</span></code> distinguishes family from standard data
declarations. The result kind annotation is optional and, as usual,
defaults to <code class="docutils literal"><span class="pre">*</span></code> if omitted. An example is</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">family</span> <span class="kt">Array</span> <span class="n">e</span>
</pre></div>
</div>
<p>Named arguments can also be given explicit kind signatures if needed.
Just as with <a class="reference internal" href="#gadt"><span>GADT declarations</span></a> named arguments are
entirely optional, so that we can declare <code class="docutils literal"><span class="pre">Array</span></code> alternatively with</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">family</span> <span class="kt">Array</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div>
</div>
</div>
<div class="section" id="data-instance-declarations">
<span id="id39"></span><h3>10.9.1.2. Data instance declarations<a class="headerlink" href="#data-instance-declarations" title="Permalink to this headline">¶</a></h3>
<p>Instance declarations of data and newtype families are very similar to
standard data and newtype declarations. The only two differences are
that the keyword <code class="docutils literal"><span class="pre">data</span></code> or <code class="docutils literal"><span class="pre">newtype</span></code> is followed by <code class="docutils literal"><span class="pre">instance</span></code> and
that some or all of the type arguments can be non-variable types, but
may not contain forall types or type synonym families. However, data
families are generally allowed in type parameters, and type synonyms are
allowed as long as they are fully applied and expand to a type that is
itself admissible - exactly as this is required for occurrences of type
synonyms in class instance parameters. For example, the <code class="docutils literal"><span class="pre">Either</span></code>
instance for <code class="docutils literal"><span class="pre">GMap</span></code> is</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kr">instance</span> <span class="kt">GMap</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">GMapEither</span> <span class="p">(</span><span class="kt">GMap</span> <span class="n">a</span> <span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="kt">GMap</span> <span class="n">b</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, the declaration has only one variant. In general, it
can be any number.</p>
<p>When the flag <a class="reference internal" href="using-warnings.html#ghc-flag--Wunused-type-patterns"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wunused-type-patterns</span></code></a> is enabled, type
variables that are mentioned in the patterns on the left hand side, but not
used on the right hand side are reported. Variables that occur multiple times
on the left hand side are also considered used. To suppress the warnings,
unused variables should be either replaced or prefixed with underscores. Type
variables starting with an underscore (<code class="docutils literal"><span class="pre">_x</span></code>) are otherwise treated as
ordinary type variables.</p>
<p>This resembles the wildcards that can be used in
<a class="reference internal" href="#partial-type-signatures"><span>Partial Type Signatures</span></a>. However, there are some differences.
No error messages reporting the inferred types are generated, nor does
the flag <a class="reference internal" href="#ghc-flag--XPartialTypeSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPartialTypeSignatures</span></code></a> have any effect.</p>
<p>Data and newtype instance declarations are only permitted when an
appropriate family declaration is in scope - just as a class instance
declaration requires the class declaration to be visible. Moreover, each
instance declaration has to conform to the kind determined by its family
declaration. This implies that the number of parameters of an instance
declaration matches the arity determined by the kind of the family.</p>
<p>A data family instance declaration can use the full expressiveness of
ordinary <code class="docutils literal"><span class="pre">data</span></code> or <code class="docutils literal"><span class="pre">newtype</span></code> declarations:</p>
<ul>
<li><p class="first">Although, a data family is <em>introduced</em> with the keyword &#8220;<code class="docutils literal"><span class="pre">data</span></code>&#8221;,
a data family <em>instance</em> can use either <code class="docutils literal"><span class="pre">data</span></code> or <code class="docutils literal"><span class="pre">newtype</span></code>. For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">family</span> <span class="kt">T</span> <span class="n">a</span>
<span class="kr">data</span>    <span class="kr">instance</span> <span class="kt">T</span> <span class="kt">Int</span>  <span class="ow">=</span> <span class="kt">T1</span> <span class="kt">Int</span> <span class="o">|</span> <span class="kt">T2</span> <span class="kt">Bool</span>
<span class="kr">newtype</span> <span class="kr">instance</span> <span class="kt">T</span> <span class="kt">Char</span> <span class="ow">=</span> <span class="kt">TC</span> <span class="kt">Bool</span>
</pre></div>
</div>
</li>
<li><p class="first">A <code class="docutils literal"><span class="pre">data</span> <span class="pre">instance</span></code> can use GADT syntax for the data constructors,
and indeed can define a GADT. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">family</span> <span class="kt">G</span> <span class="n">a</span> <span class="n">b</span>
<span class="kr">data</span> <span class="kr">instance</span> <span class="kt">G</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="n">b</span> <span class="kr">where</span>
   <span class="kt">G1</span> <span class="ow">::</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kt">G</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="n">b</span>
   <span class="kt">G2</span> <span class="ow">::</span> <span class="kt">G</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kt">Bool</span>
</pre></div>
</div>
</li>
<li><p class="first">You can use a <code class="docutils literal"><span class="pre">deriving</span></code> clause on a <code class="docutils literal"><span class="pre">data</span> <span class="pre">instance</span></code> or
<code class="docutils literal"><span class="pre">newtype</span> <span class="pre">instance</span></code> declaration.</p>
</li>
</ul>
<p>Even if data families are defined as toplevel declarations, functions
that perform different computations for different family instances may
still need to be defined as methods of type classes. In particular, the
following is not possible:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">family</span> <span class="kt">T</span> <span class="n">a</span>
<span class="kr">data</span> <span class="kr">instance</span> <span class="kt">T</span> <span class="kt">Int</span>  <span class="ow">=</span> <span class="kt">A</span>
<span class="kr">data</span> <span class="kr">instance</span> <span class="kt">T</span> <span class="kt">Char</span> <span class="ow">=</span> <span class="kt">B</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="kt">A</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">foo</span> <span class="kt">B</span> <span class="ow">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Instead, you would have to write <code class="docutils literal"><span class="pre">foo</span></code> as a class operation, thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">foo</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="kr">instance</span> <span class="kt">Foo</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="n">foo</span> <span class="kt">A</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="kr">instance</span> <span class="kt">Foo</span> <span class="kt">Char</span> <span class="kr">where</span>
  <span class="n">foo</span> <span class="kt">B</span> <span class="ow">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Given the functionality provided by GADTs (Generalised Algebraic Data
Types), it might seem as if a definition, such as the above, should be
feasible. However, type families - in contrast to GADTs - are
<em>open;</em> i.e., new instances can always be added, possibly in other
modules. Supporting pattern matching across different data instances
would require a form of extensible case construct.</p>
</div>
<div class="section" id="overlap-of-data-instances">
<span id="data-family-overlap"></span><h3>10.9.1.3. Overlap of data instances<a class="headerlink" href="#overlap-of-data-instances" title="Permalink to this headline">¶</a></h3>
<p>The instance declarations of a data family used in a single program may
not overlap at all, independent of whether they are associated or not.
In contrast to type class instances, this is not only a matter of
consistency, but one of type safety.</p>
</div>
</div>
<div class="section" id="synonym-families">
<span id="id40"></span><h2>10.9.2. Synonym families<a class="headerlink" href="#synonym-families" title="Permalink to this headline">¶</a></h2>
<p>Type families appear in three flavours: (1) they can be defined as open
families on the toplevel, (2) they can be defined as closed families on
the toplevel, or (3) they can appear inside type classes (in which case
they are known as associated type synonyms). Toplevel families are more
general, as they lack the requirement for the type-indexes to coincide
with the class parameters. However, associated type synonyms can lead to
more clearly structured code and compiler warnings if some type
instances were - possibly accidentally - omitted. In the following, we
always discuss the general toplevel forms first and then cover the
additional constraints placed on associated types. Note that closed
associated type synonyms do not exist.</p>
<div class="section" id="type-family-declarations">
<span id="id41"></span><h3>10.9.2.1. Type family declarations<a class="headerlink" href="#type-family-declarations" title="Permalink to this headline">¶</a></h3>
<p>Open indexed type families are introduced by a signature, such as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">Elem</span> <span class="n">c</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div>
</div>
<p>The special <code class="docutils literal"><span class="pre">family</span></code> distinguishes family from standard type
declarations. The result kind annotation is optional and, as usual,
defaults to <code class="docutils literal"><span class="pre">*</span></code> if omitted. An example is</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">Elem</span> <span class="n">c</span>
</pre></div>
</div>
<p>Parameters can also be given explicit kind signatures if needed. We call
the number of parameters in a type family declaration, the family&#8217;s
arity, and all applications of a type family must be fully saturated
with respect to to that arity. This requirement is unlike ordinary type synonyms
and it implies that the kind of a type family is not sufficient to
determine a family&#8217;s arity, and hence in general, also insufficient to
determine whether a type family application is well formed. As an
example, consider the following declaration:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">F</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>   <span class="c1">-- F&#39;s arity is 2,</span>
                              <span class="c1">-- although its overall kind is * -&gt; * -&gt; * -&gt; *</span>
</pre></div>
</div>
<p>Given this declaration the following are examples of well-formed and
malformed types:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">F</span> <span class="kt">Char</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>       <span class="c1">-- OK!  Kind: * -&gt; *</span>
<span class="kt">F</span> <span class="kt">Char</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="kt">Bool</span>  <span class="c1">-- OK!  Kind: *</span>
<span class="kt">F</span> <span class="kt">IO</span> <span class="kt">Bool</span>          <span class="c1">-- WRONG: kind mismatch in the first argument</span>
<span class="kt">F</span> <span class="kt">Bool</span>             <span class="c1">-- WRONG: unsaturated application</span>
</pre></div>
</div>
<p>The result kind annotation is optional and defaults to <code class="docutils literal"><span class="pre">*</span></code> (like
argument kinds) if omitted. Polykinded type families can be declared
using a parameter in the kind annotation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">F</span> <span class="n">a</span> <span class="ow">::</span> <span class="n">k</span>
</pre></div>
</div>
<p>In this case the kind parameter <code class="docutils literal"><span class="pre">k</span></code> is actually an implicit parameter
of the type family.</p>
</div>
<div class="section" id="type-instance-declarations">
<span id="id42"></span><h3>10.9.2.2. Type instance declarations<a class="headerlink" href="#type-instance-declarations" title="Permalink to this headline">¶</a></h3>
<p>Instance declarations of type families are very similar to standard type
synonym declarations. The only two differences are that the keyword
<code class="docutils literal"><span class="pre">type</span></code> is followed by <code class="docutils literal"><span class="pre">instance</span></code> and that some or all of the type
arguments can be non-variable types, but may not contain forall types or
type synonym families. However, data families are generally allowed, and
type synonyms are allowed as long as they are fully applied and expand
to a type that is admissible - these are the exact same requirements as
for data instances. For example, the <code class="docutils literal"><span class="pre">[e]</span></code> instance for <code class="docutils literal"><span class="pre">Elem</span></code> is</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Elem</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="ow">=</span> <span class="n">e</span>
</pre></div>
</div>
<p>Type arguments can be replaced with underscores (<code class="docutils literal"><span class="pre">_</span></code>) if the names of
the arguments don&#8217;t matter. This is the same as writing type variables
with unique names. Unused type arguments can be replaced or prefixed
with underscores to avoid warnings when the
<a class="reference internal" href="using-warnings.html#ghc-flag--Wunused-type-patterns"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wunused-type-patterns</span></code></a> flag is enabled. The same rules apply
as for <a class="reference internal" href="#data-instance-declarations"><span>Data instance declarations</span></a>.</p>
<p>Type family instance declarations are only legitimate when an
appropriate family declaration is in scope - just like class instances
require the class declaration to be visible. Moreover, each instance
declaration has to conform to the kind determined by its family
declaration, and the number of type parameters in an instance
declaration must match the number of type parameters in the family
declaration. Finally, the right-hand side of a type instance must be a
monotype (i.e., it may not include foralls) and after the expansion of
all saturated vanilla type synonyms, no synonyms, except family synonyms
may remain.</p>
</div>
<div class="section" id="closed-type-families">
<span id="id43"></span><h3>10.9.2.3. Closed type families<a class="headerlink" href="#closed-type-families" title="Permalink to this headline">¶</a></h3>
<p>A type family can also be declared with a <code class="docutils literal"><span class="pre">where</span></code> clause, defining the
full set of equations for that family. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">F</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">F</span> <span class="kt">Int</span>  <span class="ow">=</span> <span class="kt">Double</span>
  <span class="kt">F</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">Char</span>
  <span class="kt">F</span> <span class="n">a</span>    <span class="ow">=</span> <span class="kt">String</span>
</pre></div>
</div>
<p>A closed type family&#8217;s equations are tried in order, from top to bottom,
when simplifying a type family application. In this example, we declare
an instance for <code class="docutils literal"><span class="pre">F</span></code> such that <code class="docutils literal"><span class="pre">F</span> <span class="pre">Int</span></code> simplifies to <code class="docutils literal"><span class="pre">Double</span></code>,
<code class="docutils literal"><span class="pre">F</span> <span class="pre">Bool</span></code> simplifies to <code class="docutils literal"><span class="pre">Char</span></code>, and for any other type <code class="docutils literal"><span class="pre">a</span></code> that is
known not to be <code class="docutils literal"><span class="pre">Int</span></code> or <code class="docutils literal"><span class="pre">Bool</span></code>, <code class="docutils literal"><span class="pre">F</span> <span class="pre">a</span></code> simplifies to <code class="docutils literal"><span class="pre">String</span></code>.
Note that GHC must be sure that <code class="docutils literal"><span class="pre">a</span></code> cannot unify with <code class="docutils literal"><span class="pre">Int</span></code> or
<code class="docutils literal"><span class="pre">Bool</span></code> in that last case; if a programmer specifies just <code class="docutils literal"><span class="pre">F</span> <span class="pre">a</span></code> in
their code, GHC will not be able to simplify the type. After all, <code class="docutils literal"><span class="pre">a</span></code>
might later be instantiated with <code class="docutils literal"><span class="pre">Int</span></code>.</p>
<p>A closed type family&#8217;s equations have the same restrictions as the
equations for open type family instances.</p>
<p>A closed type family may be declared with no equations. Such closed type
families are opaque type-level definitions that will never reduce, are
not necessarily injective (unlike empty data types), and cannot be given
any instances. This is different from omitting the equations of a closed
type family in a <code class="docutils literal"><span class="pre">hs-boot</span></code> file, which uses the syntax <code class="docutils literal"><span class="pre">where</span> <span class="pre">..</span></code>,
as in that case there may or may not be equations given in the <code class="docutils literal"><span class="pre">hs</span></code>
file.</p>
</div>
<div class="section" id="type-family-examples">
<span id="id44"></span><h3>10.9.2.4. Type family examples<a class="headerlink" href="#type-family-examples" title="Permalink to this headline">¶</a></h3>
<p>Here are some examples of admissible and illegal type instances:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">F</span> <span class="n">a</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>   <span class="ow">=</span> <span class="kt">Int</span>   <span class="c1">-- OK!</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="kt">String</span>  <span class="ow">=</span> <span class="kt">Char</span>  <span class="c1">-- OK!</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="p">(</span><span class="kt">F</span> <span class="n">a</span><span class="p">)</span>   <span class="ow">=</span> <span class="n">a</span>     <span class="c1">-- WRONG: type parameter mentions a type family</span>
<span class="kr">type</span> <span class="kr">instance</span>
  <span class="kt">F</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>  <span class="ow">=</span> <span class="n">b</span>     <span class="c1">-- WRONG: a forall type appears in a type parameter</span>
<span class="kr">type</span> <span class="kr">instance</span>
  <span class="kt">F</span> <span class="kt">Float</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span><span class="n">a</span>          <span class="c1">-- WRONG: right-hand side may not be a forall type</span>
<span class="kr">type</span> <span class="n">family</span> <span class="kt">H</span> <span class="n">a</span> <span class="kr">where</span>          <span class="c1">-- OK!</span>
  <span class="kt">H</span> <span class="kt">Int</span>  <span class="ow">=</span> <span class="kt">Int</span>
  <span class="kt">H</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">Bool</span>
  <span class="kt">H</span> <span class="n">a</span>    <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">H</span> <span class="kt">Char</span> <span class="ow">=</span> <span class="kt">Char</span>    <span class="c1">-- WRONG: cannot have instances of closed family</span>
<span class="kr">type</span> <span class="n">family</span> <span class="kt">K</span> <span class="n">a</span> <span class="kr">where</span>          <span class="c1">-- OK!</span>

<span class="kr">type</span> <span class="n">family</span> <span class="kt">G</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">G</span> <span class="kt">Int</span>            <span class="ow">=</span> <span class="p">(,)</span>     <span class="c1">-- WRONG: must be two type parameters</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">G</span> <span class="kt">Int</span> <span class="kt">Char</span> <span class="kt">Float</span> <span class="ow">=</span> <span class="kt">Double</span>  <span class="c1">-- WRONG: must be two type parameters</span>
</pre></div>
</div>
</div>
<div class="section" id="compatibility-and-apartness-of-type-family-equations">
<span id="type-family-overlap"></span><h3>10.9.2.5. Compatibility and apartness of type family equations<a class="headerlink" href="#compatibility-and-apartness-of-type-family-equations" title="Permalink to this headline">¶</a></h3>
<p>There must be some restrictions on the equations of type families, lest
we define an ambiguous rewrite system. So, equations of open type
families are restricted to be compatible. Two type patterns are
compatible if</p>
<ol class="arabic simple">
<li>all corresponding types and implicit kinds in the patterns are apart,
or</li>
<li>the two patterns unify producing a substitution, and the right-hand
sides are equal under that substitution.</li>
</ol>
<p>Two types are considered apart if, for all possible substitutions, the
types cannot reduce to a common reduct.</p>
<p>The first clause of &#8220;compatible&#8221; is the more straightforward one. It
says that the patterns of two distinct type family instances cannot
overlap. For example, the following is disallowed:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Bool</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Char</span>
</pre></div>
</div>
<p>The second clause is a little more interesting. It says that two
overlapping type family instances are allowed if the right-hand sides
coincide in the region of overlap. Some examples help here:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>   <span class="c1">-- overlap permitted</span>

<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">G</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>  <span class="ow">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">G</span> <span class="p">(</span><span class="kt">Char</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>  <span class="c1">-- ILLEGAL overlap, as [Char] /= [Int]</span>
</pre></div>
</div>
<p>Note that this compatibility condition is independent of whether the
type family is associated or not, and it is not only a matter of
consistency, but one of type safety.</p>
<p>For a polykinded type family, the kinds are checked for apartness just
like types. For example, the following is accepted:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">J</span> <span class="n">a</span> <span class="ow">::</span> <span class="n">k</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">J</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Bool</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">J</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Maybe</span>
</pre></div>
</div>
<p>These instances are compatible because they differ in their implicit
kind parameter; the first uses <code class="docutils literal"><span class="pre">*</span></code> while the second uses <code class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>.</p>
<p>The definition for &#8220;compatible&#8221; uses a notion of &#8220;apart&#8221;, whose
definition in turn relies on type family reduction. This condition of
&#8220;apartness&#8221;, as stated, is impossible to check, so we use this
conservative approximation: two types are considered to be apart when
the two types cannot be unified, even by a potentially infinite unifier.
Allowing the unifier to be infinite disallows the following pair of
instances:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kr">instance</span> <span class="kt">H</span> <span class="n">x</span>   <span class="n">x</span> <span class="ow">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">H</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>The type patterns in this pair equal if <code class="docutils literal"><span class="pre">x</span></code> is replaced by an infinite
nesting of lists. Rejecting instances such as these is necessary for
type soundness.</p>
<p>Compatibility also affects closed type families. When simplifying an
application of a closed type family, GHC will select an equation only
when it is sure that no incompatible previous equation will ever apply.
Here are some examples:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">F</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">F</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Bool</span>
  <span class="kt">F</span> <span class="n">a</span>   <span class="ow">=</span> <span class="kt">Char</span>

<span class="kr">type</span> <span class="n">family</span> <span class="kt">G</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">G</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Int</span>
  <span class="kt">G</span> <span class="n">a</span>   <span class="ow">=</span> <span class="n">a</span>
</pre></div>
</div>
<p>In the definition for <code class="docutils literal"><span class="pre">F</span></code>, the two equations are incompatible &#8211; their
patterns are not apart, and yet their right-hand sides do not coincide.
Thus, before GHC selects the second equation, it must be sure that the
first can never apply. So, the type <code class="docutils literal"><span class="pre">F</span> <span class="pre">a</span></code> does not simplify; only a
type such as <code class="docutils literal"><span class="pre">F</span> <span class="pre">Double</span></code> will simplify to <code class="docutils literal"><span class="pre">Char</span></code>. In <code class="docutils literal"><span class="pre">G</span></code>, on the
other hand, the two equations are compatible. Thus, GHC can ignore the
first equation when looking at the second. So, <code class="docutils literal"><span class="pre">G</span> <span class="pre">a</span></code> will simplify to
<code class="docutils literal"><span class="pre">a</span></code>.</p>
<p>However see <a class="reference internal" href="ghci.html#ghci-decls"><span>Type, class and other declarations</span></a> for the overlap rules in GHCi.</p>
</div>
<div class="section" id="decidability-of-type-synonym-instances">
<span id="type-family-decidability"></span><h3>10.9.2.6. Decidability of type synonym instances<a class="headerlink" href="#decidability-of-type-synonym-instances" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt>
<code class="descname">-XUndecidableInstances</code><code class="descclassname"></code></dt>
<dd><p>Relax restrictions on the decidability of type synonym family instances.</p>
</dd></dl>

<p>In order to guarantee that type inference in the presence of type
families decidable, we need to place a number of additional restrictions
on the formation of type instance declarations (c.f., Definition 5
(Relaxed Conditions) of “<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type Checking with Open Type
Functions</a>”).
Instance declarations have the general form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="n">t1</span> <span class="o">..</span> <span class="n">tn</span> <span class="ow">=</span> <span class="n">t</span>
</pre></div>
</div>
<p>where we require that for every type family application <code class="docutils literal"><span class="pre">(G</span> <span class="pre">s1</span> <span class="pre">..</span> <span class="pre">sm)</span></code>
in <code class="docutils literal"><span class="pre">t</span></code>,</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">s1</span> <span class="pre">..</span> <span class="pre">sm</span></code> do not contain any type family constructors,</li>
<li>the total number of symbols (data type constructors and type
variables) in <code class="docutils literal"><span class="pre">s1</span> <span class="pre">..</span> <span class="pre">sm</span></code> is strictly smaller than in <code class="docutils literal"><span class="pre">t1</span> <span class="pre">..</span> <span class="pre">tn</span></code>,
and</li>
<li>for every type variable <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">a</span></code> occurs in <code class="docutils literal"><span class="pre">s1</span> <span class="pre">..</span> <span class="pre">sm</span></code> at most
as often as in <code class="docutils literal"><span class="pre">t1</span> <span class="pre">..</span> <span class="pre">tn</span></code>.</li>
</ol>
<p>These restrictions are easily verified and ensure termination of type
inference. However, they are not sufficient to guarantee completeness of
type inference in the presence of, so called, &#8216;&#8217;loopy equalities&#8217;&#8216;, such
as <code class="docutils literal"><span class="pre">a</span> <span class="pre">~</span> <span class="pre">[F</span> <span class="pre">a]</span></code>, where a recursive occurrence of a type variable is
underneath a family application and data constructor application - see
the above mentioned paper for details.</p>
<p>If the option <a class="reference internal" href="#ghc-flag--XUndecidableInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUndecidableInstances</span></code></a> is passed to the compiler, the
above restrictions are not enforced and it is on the programmer to ensure
termination of the normalisation of type families during type inference.</p>
</div>
</div>
<div class="section" id="wildcards-on-the-lhs-of-data-and-type-family-instances">
<span id="type-wildcards-lhs"></span><h2>10.9.3. Wildcards on the LHS of data and type family instances<a class="headerlink" href="#wildcards-on-the-lhs-of-data-and-type-family-instances" title="Permalink to this headline">¶</a></h2>
<p>When the name of a type argument of a data or type instance
declaration doesn&#8217;t matter, it can be replaced with an underscore
(<code class="docutils literal"><span class="pre">_</span></code>). This is the same as writing a type variable with a unique name.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">family</span> <span class="kt">F</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="kt">Int</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Int</span>
<span class="c1">-- Equivalent to  data instance F Int b = Int</span>

<span class="kr">type</span> <span class="n">family</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">T</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>
<span class="c1">-- Equivalent to  type instance T (a,b) = a</span>
</pre></div>
</div>
<p>This use of underscore for wildcard in a type pattern is exactly like
pattern matching in the term language, but is rather different to the
use of a underscore in a partial type signature (see <a class="reference internal" href="#type-wildcards"><span>Type Wildcards</span></a>).</p>
<p>A type variable beginning with an underscore is not treated specially in a
type or data instance declaration.  For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="kt">Bool</span> <span class="n">_a</span> <span class="ow">=</span> <span class="n">_a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="c1">-- Equivalent to  data instance F Bool a = a -&gt; Int</span>
</pre></div>
</div>
<p>Contrast this with the special treatment of named wildcards in
type signatures (<a class="reference internal" href="#named-wildcards"><span>Named Wildcards</span></a>).</p>
</div>
<div class="section" id="associated-data-and-type-families">
<span id="assoc-decl"></span><h2>10.9.4. Associated data and type families<a class="headerlink" href="#associated-data-and-type-families" title="Permalink to this headline">¶</a></h2>
<p>A data or type synonym family can be declared as part of a type class,
thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">GMapKey</span> <span class="n">k</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">GMap</span> <span class="n">k</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
  <span class="o">...</span>

<span class="kr">class</span> <span class="kt">Collects</span> <span class="n">ce</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Elem</span> <span class="n">ce</span> <span class="ow">::</span> <span class="o">*</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>When doing so, we (optionally) may drop the &#8220;<code class="docutils literal"><span class="pre">family</span></code>&#8221; keyword.</p>
<p>The type parameters must all be type variables, of course, and some (but
not necessarily all) of then can be the class parameters. Each class
parameter may only be used at most once per associated type, but some
may be omitted and they may be in an order other than in the class head.
Hence, the following contrived example is admissible:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">T</span> <span class="n">c</span> <span class="n">a</span> <span class="n">x</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">c</span></code> and <code class="docutils literal"><span class="pre">a</span></code> are class parameters, but the type is also indexed
on a third parameter <code class="docutils literal"><span class="pre">x</span></code>.</p>
<div class="section" id="associated-instances">
<span id="assoc-data-inst"></span><h3>10.9.4.1. Associated instances<a class="headerlink" href="#associated-instances" title="Permalink to this headline">¶</a></h3>
<p>When an associated data or type synonym family instance is declared
within a type class instance, we (optionally) may drop the <code class="docutils literal"><span class="pre">instance</span></code>
keyword in the family instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">GMapKey</span> <span class="n">a</span><span class="p">,</span> <span class="kt">GMapKey</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">GMapKey</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">GMap</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">GMapEither</span> <span class="p">(</span><span class="kt">GMap</span> <span class="n">a</span> <span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="kt">GMap</span> <span class="n">b</span> <span class="n">v</span><span class="p">)</span>
  <span class="o">...</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Elem</span> <span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="ow">=&gt;</span> <span class="kt">Collects</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Elem</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="ow">=</span> <span class="n">e</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>The data or type family instance for an assocated type must follow
the rule that the type indexes corresponding to class parameters must have
precisely the same as type given in the instance head. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Collects</span> <span class="n">ce</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Elem</span> <span class="n">ce</span> <span class="ow">::</span> <span class="o">*</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Elem</span> <span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="ow">=&gt;</span> <span class="kt">Collects</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="kr">where</span>
  <span class="c1">-- Choose one of the following alternatives:</span>
  <span class="kr">type</span> <span class="kt">Elem</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="ow">=</span> <span class="n">e</span>       <span class="c1">-- OK</span>
  <span class="kr">type</span> <span class="kt">Elem</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="n">x</span>       <span class="c1">-- BAD; &#39;[x]&#39; is differnet to &#39;[e]&#39; from head</span>
  <span class="kr">type</span> <span class="kt">Elem</span> <span class="n">x</span>   <span class="ow">=</span> <span class="n">x</span>       <span class="c1">-- BAD; &#39;x&#39; is different to &#39;[e]&#39;</span>
  <span class="kr">type</span> <span class="kt">Elem</span> <span class="p">[</span><span class="kt">Maybe</span> <span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="n">x</span> <span class="c1">-- BAD: &#39;[Maybe x]&#39; is different to &#39;[e]&#39;</span>
</pre></div>
</div>
<p>Note the following points:</p>
<ul>
<li><p class="first">An instance for an associated family can only appear as part of an
instance declarations of the class in which the family was declared,
just as with the equations of the methods of a class.</p>
</li>
<li><p class="first">The variables on the right hand side of the type family equation
must, as usual, be bound on the left hand side.</p>
</li>
<li><p class="first">The instance for an associated type can be omitted in class
instances. In that case, unless there is a default instance (see
<a class="reference internal" href="#assoc-decl-defs"><span>Associated type synonym defaults</span></a>), the corresponding instance type is not
inhabited; i.e., only diverging expressions, such as <code class="docutils literal"><span class="pre">undefined</span></code>,
can assume the type.</p>
</li>
<li><p class="first">Although it is unusual, there (currently) can be <em>multiple</em> instances
for an associated family in a single instance declaration. For
example, this is legitimate:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">GMapKey</span> <span class="kt">Flob</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">GMap</span> <span class="kt">Flob</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">=</span> <span class="kt">G1</span> <span class="n">v</span>
  <span class="kr">data</span> <span class="kt">GMap</span> <span class="kt">Flob</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">G2</span> <span class="kt">Int</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>Here we give two data instance declarations, one in which the last
parameter is <code class="docutils literal"><span class="pre">[v]</span></code>, and one for which it is <code class="docutils literal"><span class="pre">Int</span></code>. Since you
cannot give any <em>subsequent</em> instances for <code class="docutils literal"><span class="pre">(GMap</span> <span class="pre">Flob</span> <span class="pre">...)</span></code>, this
facility is most useful when the free indexed parameter is of a kind
with a finite number of alternatives (unlike <code class="docutils literal"><span class="pre">*</span></code>).</p>
</li>
</ul>
</div>
<div class="section" id="associated-type-synonym-defaults">
<span id="assoc-decl-defs"></span><h3>10.9.4.2. Associated type synonym defaults<a class="headerlink" href="#associated-type-synonym-defaults" title="Permalink to this headline">¶</a></h3>
<p>It is possible for the class defining the associated type to specify a
default for associated type instances. So for example, this is OK:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">IsBoolMap</span> <span class="n">v</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Key</span> <span class="n">v</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Key</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Int</span>

  <span class="n">lookupKey</span> <span class="ow">::</span> <span class="kt">Key</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Bool</span>

<span class="kr">instance</span> <span class="kt">IsBoolMap</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Bool</span><span class="p">)]</span> <span class="kr">where</span>
  <span class="n">lookupKey</span> <span class="ow">=</span> <span class="n">lookup</span>
</pre></div>
</div>
<p>In an <code class="docutils literal"><span class="pre">instance</span></code> declaration for the class, if no explicit
<code class="docutils literal"><span class="pre">type</span> <span class="pre">instance</span></code> declaration is given for the associated type, the
default declaration is used instead, just as with default class methods.</p>
<p>Note the following points:</p>
<ul class="simple">
<li>The <code class="docutils literal"><span class="pre">instance</span></code> keyword is optional.</li>
<li>There can be at most one default declaration for an associated type
synonym.</li>
<li>A default declaration is not permitted for an associated <em>data</em> type.</li>
<li>The default declaration must mention only type <em>variables</em> on the
left hand side, and the right hand side must mention only type
variables bound on the left hand side. However, unlike the associated
type family declaration itself, the type variables of the default
instance are independent of those of the parent class.</li>
</ul>
<p>Here are some examples:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">F1</span> <span class="n">a</span> <span class="ow">::</span> <span class="o">*</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F1</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>     <span class="c1">-- OK</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F1</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span>    <span class="c1">-- BAD; only one default instance is allowed</span>

  <span class="kr">type</span> <span class="kt">F2</span> <span class="n">b</span> <span class="n">a</span>                  <span class="c1">-- OK; note the family has more type</span>
                               <span class="c1">--     variables than the class</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F2</span> <span class="n">c</span> <span class="n">d</span> <span class="ow">=</span> <span class="n">c</span><span class="ow">-&gt;</span><span class="n">d</span>  <span class="c1">-- OK; you don&#39;t have to use &#39;a&#39; in the type instance</span>

  <span class="kr">type</span> <span class="kt">F3</span> <span class="n">a</span>
  <span class="kr">type</span> <span class="kt">F3</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">=</span> <span class="n">b</span>              <span class="c1">-- BAD; only type variables allowed on the LHS</span>

  <span class="kr">type</span> <span class="kt">F4</span> <span class="n">a</span>
  <span class="kr">type</span> <span class="kt">F4</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span>                <span class="c1">-- BAD; &#39;a&#39; is not in scope  in the RHS</span>
</pre></div>
</div>
</div>
<div class="section" id="scoping-of-class-parameters">
<span id="scoping-class-params"></span><h3>10.9.4.3. Scoping of class parameters<a class="headerlink" href="#scoping-of-class-parameters" title="Permalink to this headline">¶</a></h3>
<p>The visibility of class parameters in the right-hand side of associated
family instances depends <em>solely</em> on the parameters of the family. As an
example, consider the simple class declaration</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span>
</pre></div>
</div>
<p>Only one of the two class parameters is a parameter to the data family.
Hence, the following instance declaration is invalid:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="n">d</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">T</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>    <span class="c1">-- WRONG!!  &#39;d&#39; is not in scope</span>
</pre></div>
</div>
<p>Here, the right-hand side of the data instance mentions the type
variable <code class="docutils literal"><span class="pre">d</span></code> that does not occur in its left-hand side. We cannot
admit such data instances as they would compromise type safety.</p>
</div>
<div class="section" id="instance-contexts-and-associated-type-and-data-instances">
<h3>10.9.4.4. Instance contexts and associated type and data instances<a class="headerlink" href="#instance-contexts-and-associated-type-and-data-instances" title="Permalink to this headline">¶</a></h3>
<p>Associated type and data instance declarations do not inherit any
context specified on the enclosing instance. For type instance
declarations, it is unclear what the context would mean. For data
instance declarations, it is unlikely a user would want the context
repeated for every data constructor. The only place where the context
might likely be useful is in a <code class="docutils literal"><span class="pre">deriving</span></code> clause of an associated data
instance. However, even here, the role of the outer instance context is
murky. So, for clarity, we just stick to the rule above: the enclosing
instance context is ignored. If you need to use a non-trivial context on
a derived instance, use a <a class="reference internal" href="#ghc-flag--XStandaloneDeriving"><code class="xref std std-ghc-flag docutils literal"><span class="pre">standalone</span> <span class="pre">deriving</span></code></a>
clause (at the top level).</p>
</div>
</div>
<div class="section" id="import-and-export">
<span id="data-family-import-export"></span><h2>10.9.5. Import and export<a class="headerlink" href="#import-and-export" title="Permalink to this headline">¶</a></h2>
<p>The rules for export lists (Haskell Report <a class="reference external" href="http://www.haskell.org/onlinereport/modules.html#sect5.2">Section
5.2</a>) needs
adjustment for type families:</p>
<ul class="simple">
<li>The form <code class="docutils literal"><span class="pre">T(..)</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is a data family, names the family
<code class="docutils literal"><span class="pre">T</span></code> and all the in-scope constructors (whether in scope qualified
or unqualified) that are data instances of <code class="docutils literal"><span class="pre">T</span></code>.</li>
<li>The form <code class="docutils literal"><span class="pre">T(..,</span> <span class="pre">ci,</span> <span class="pre">..,</span> <span class="pre">fj,</span> <span class="pre">..)</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is a data family,
names <code class="docutils literal"><span class="pre">T</span></code> and the specified constructors <code class="docutils literal"><span class="pre">ci</span></code> and fields <code class="docutils literal"><span class="pre">fj</span></code>
as usual. The constructors and field names must belong to some data
instance of <code class="docutils literal"><span class="pre">T</span></code>, but are not required to belong to the <em>same</em>
instance.</li>
<li>The form <code class="docutils literal"><span class="pre">C(..)</span></code>, where <code class="docutils literal"><span class="pre">C</span></code> is a class, names the class <code class="docutils literal"><span class="pre">C</span></code> and
all its methods <em>and associated types</em>.</li>
<li>The form <code class="docutils literal"><span class="pre">C(..,</span> <span class="pre">mi,</span> <span class="pre">..,</span> <span class="pre">type</span> <span class="pre">Tj,</span> <span class="pre">..)</span></code>, where <code class="docutils literal"><span class="pre">C</span></code> is a class,
names the class <code class="docutils literal"><span class="pre">C</span></code>, and the specified methods <code class="docutils literal"><span class="pre">mi</span></code> and
associated types <code class="docutils literal"><span class="pre">Tj</span></code>. The types need a keyword &#8220;<code class="docutils literal"><span class="pre">type</span></code>&#8221; to
distinguish them from data constructors.</li>
<li>Whenever there is no export list and a data instance is defined, the
corresponding data family type constructor is exported along with
the new data constructors, regardless of whether the data family
is defined locally or in another module.</li>
</ul>
<div class="section" id="examples">
<span id="data-family-impexp-examples"></span><h3>10.9.5.1. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>Recall our running <code class="docutils literal"><span class="pre">GMapKey</span></code> class example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">GMapKey</span> <span class="n">k</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">GMap</span> <span class="n">k</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
  <span class="n">insert</span> <span class="ow">::</span> <span class="kt">GMap</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">GMap</span> <span class="n">k</span> <span class="n">v</span>
  <span class="n">lookup</span> <span class="ow">::</span> <span class="kt">GMap</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
  <span class="n">empty</span>  <span class="ow">::</span> <span class="kt">GMap</span> <span class="n">k</span> <span class="n">v</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">GMapKey</span> <span class="n">a</span><span class="p">,</span> <span class="kt">GMapKey</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">GMapKey</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="kt">GMap</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">GMapEither</span> <span class="p">(</span><span class="kt">GMap</span> <span class="n">a</span> <span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="kt">GMap</span> <span class="n">b</span> <span class="n">v</span><span class="p">)</span>
  <span class="o">...</span><span class="n">method</span> <span class="n">declarations</span><span class="o">...</span>
</pre></div>
</div>
<p>Here are some export lists and their meaning:</p>
<ul>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">GMap</span><span class="p">(</span> <span class="kt">GMapKey</span> <span class="p">)</span>
</pre></div>
</div>
<p>Exports just the class name.</p>
</li>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">GMap</span><span class="p">(</span> <span class="kt">GMapKey</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Exports the class, the associated type <code class="docutils literal"><span class="pre">GMap</span></code> and the member functions
<code class="docutils literal"><span class="pre">empty</span></code>, <code class="docutils literal"><span class="pre">lookup</span></code>, and <code class="docutils literal"><span class="pre">insert</span></code>. The data constructors of <code class="docutils literal"><span class="pre">GMap</span></code> (in
this case <code class="docutils literal"><span class="pre">GMapEither</span></code>) are not exported.</p>
</li>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">GMap</span><span class="p">(</span> <span class="kt">GMapKey</span><span class="p">(</span> <span class="kr">type</span> <span class="kt">GMap</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">lookup</span><span class="p">,</span> <span class="n">insert</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Same as the previous item. Note the &#8220;<code class="docutils literal"><span class="pre">type</span></code>&#8221; keyword.</p>
</li>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">GMap</span><span class="p">(</span> <span class="kt">GMapKey</span><span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="kt">GMap</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Same as previous item, but also exports all the data constructors for
<code class="docutils literal"><span class="pre">GMap</span></code>, namely
<code class="docutils literal"><span class="pre">GMapEither</span></code>.</p>
</li>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">GMap</span> <span class="p">(</span> <span class="kt">GMapKey</span><span class="p">(</span> <span class="nf">empty</span><span class="p">,</span> <span class="nf">lookup</span><span class="p">,</span> <span class="nf">insert</span><span class="p">),</span> <span class="kt">GMap</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Same as previous item.</p>
</li>
<li><div class="first highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">GMap</span> <span class="p">(</span> <span class="kt">GMapKey</span><span class="p">,</span> <span class="nf">empty</span><span class="p">,</span> <span class="nf">lookup</span><span class="p">,</span> <span class="nf">insert</span><span class="p">,</span> <span class="kt">GMap</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Same as previous item.</p>
</li>
</ul>
<p>Two things to watch out for:</p>
<ul>
<li><p class="first">You cannot write <code class="docutils literal"><span class="pre">GMapKey(type</span> <span class="pre">GMap(..))</span></code> — i.e., sub-component
specifications cannot be nested. To specify <code class="docutils literal"><span class="pre">GMap</span></code>&#8216;s data
constructors, you have to list it separately.</p>
</li>
<li><p class="first">Consider this example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">X</span> <span class="kr">where</span>
  <span class="kr">data</span> <span class="n">family</span> <span class="kt">D</span>

<span class="kr">module</span> <span class="nn">Y</span> <span class="kr">where</span>
  <span class="kr">import</span> <span class="nn">X</span>
  <span class="kr">data</span> <span class="kr">instance</span> <span class="kt">D</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">D1</span> <span class="o">|</span> <span class="kt">D2</span>
</pre></div>
</div>
<p>Module <code class="docutils literal"><span class="pre">Y</span></code> exports all the entities defined in <code class="docutils literal"><span class="pre">Y</span></code>, namely the data
constructors <code class="docutils literal"><span class="pre">D1</span></code> and <code class="docutils literal"><span class="pre">D2</span></code>, and <em>implicitly</em> the data family <code class="docutils literal"><span class="pre">D</span></code>,
even though it&#8217;s defined in <code class="docutils literal"><span class="pre">X</span></code>.
This means you can write <code class="docutils literal"><span class="pre">import</span> <span class="pre">Y(</span> <span class="pre">D(D1,D2)</span> <span class="pre">)</span></code> <em>without</em>
giving an explicit export list like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre>     <span class="kr">module</span> <span class="nn">Y</span><span class="p">(</span> <span class="kt">D</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
<span class="nf">or</span>   <span class="kr">module</span> <span class="nn">Y</span><span class="p">(</span> <span class="kr">module</span> <span class="nn">Y</span><span class="p">,</span> <span class="kt">D</span> <span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="instances">
<span id="data-family-impexp-instances"></span><h3>10.9.5.2. Instances<a class="headerlink" href="#instances" title="Permalink to this headline">¶</a></h3>
<p>Family instances are implicitly exported, just like class instances.
However, this applies only to the heads of instances, not to the data
constructors an instance defines.</p>
</div>
</div>
<div class="section" id="type-families-and-instance-declarations">
<span id="ty-fams-in-instances"></span><h2>10.9.6. Type families and instance declarations<a class="headerlink" href="#type-families-and-instance-declarations" title="Permalink to this headline">¶</a></h2>
<p>Type families require us to extend the rules for the form of instance
heads, which are given in <a class="reference internal" href="#flexible-instance-head"><span>Relaxed rules for the instance head</span></a>. Specifically:</p>
<ul class="simple">
<li>Data type families may appear in an instance head</li>
<li>Type synonym families may not appear (at all) in an instance head</li>
</ul>
<p>The reason for the latter restriction is that there is no way to check
for instance matching. Consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">F</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">Int</span>

<span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">C</span> <span class="kt">Int</span>
<span class="kr">instance</span> <span class="kt">C</span> <span class="p">(</span><span class="kt">F</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Now a constraint <code class="docutils literal"><span class="pre">(C</span> <span class="pre">(F</span> <span class="pre">Bool))</span></code> would match both instances. The
situation is especially bad because the type instance for <code class="docutils literal"><span class="pre">F</span> <span class="pre">Bool</span></code>
might be in another module, or even in a module that is not yet written.</p>
<p>However, type class instances of instances of data families can be
defined much like any other data type. For example, we can say</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kr">instance</span> <span class="kt">T</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">T1</span> <span class="kt">Int</span> <span class="o">|</span> <span class="kt">T2</span> <span class="kt">Bool</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">T</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">where</span>
  <span class="p">(</span><span class="kt">T1</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">T1</span> <span class="n">j</span><span class="p">)</span> <span class="ow">=</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span>
  <span class="p">(</span><span class="kt">T2</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">T2</span> <span class="n">j</span><span class="p">)</span> <span class="ow">=</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span>
  <span class="kr">_</span>      <span class="o">==</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Note that class instances are always for particular <em>instances</em> of a
data family and never for an entire family as a whole. This is for
essentially the same reasons that we cannot define a toplevel function
that performs pattern matching on the data constructors of <em>different</em>
instances of a single type family. It would require a form of extensible
case construct.</p>
<p>Data instance declarations can also have <code class="docutils literal"><span class="pre">deriving</span></code> clauses. For
example, we can write</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">GMap</span> <span class="nb">()</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">GMapUnit</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">v</span><span class="p">)</span>
               <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>which implicitly defines an instance of the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Show</span> <span class="n">v</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">GMap</span> <span class="nb">()</span> <span class="n">v</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="injective-type-families">
<span id="injective-ty-fams"></span><h2>10.9.7. Injective type families<a class="headerlink" href="#injective-type-families" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XTypeFamilyDependencies">
<code class="descname">-XTypeFamilyDependencies</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XTypeFamilyDependencies" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XTypeFamilies"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeFamilies</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Allow functional dependency annotations on type families. This allows one to
define injective type families.</p>
</dd></dl>

<p>Starting with GHC 8.0 type families can be annotated with injectivity
information. This information is then used by GHC during type checking
to resolve type ambiguities in situations where a type variable appears
only under type family applications. Consider this contrived example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">Id</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Id</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Id</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">Bool</span>

<span class="nf">id</span> <span class="ow">::</span> <span class="kt">Id</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Id</span> <span class="n">t</span>
<span class="nf">id</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div>
</div>
<p>Here the definition of <code class="docutils literal"><span class="pre">id</span></code> will be rejected because type variable <code class="docutils literal"><span class="pre">t</span></code>
appears only under type family applications and is thus ambiguous.  But this
code will be accepted if we tell GHC that <code class="docutils literal"><span class="pre">Id</span></code> is injective, which means it
will be possible to infer <code class="docutils literal"><span class="pre">t</span></code> at call sites from the type of the argument:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">Id</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">r</span> <span class="o">|</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>Injective type families are enabled with <code class="docutils literal"><span class="pre">-XTypeFamilyDependencies</span></code> language
extension.  This extension implies <code class="docutils literal"><span class="pre">-XTypeFamilies</span></code>.</p>
<p>For full details on injective type families refer to Haskell Symposium
2015 paper <a class="reference external" href="http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf">Injective type families for
Haskell</a>.</p>
<div class="section" id="syntax-of-injectivity-annotation">
<span id="injective-ty-fams-syntax"></span><h3>10.9.7.1. Syntax of injectivity annotation<a class="headerlink" href="#syntax-of-injectivity-annotation" title="Permalink to this headline">¶</a></h3>
<p>Injectivity annotation is added after type family head and consists of
two parts:</p>
<ul class="simple">
<li>a type variable that names the result of a type family. Syntax:
<code class="docutils literal"><span class="pre">=</span> <span class="pre">tyvar</span></code> or <code class="docutils literal"><span class="pre">=</span> <span class="pre">(tyvar</span> <span class="pre">::</span> <span class="pre">kind)</span></code>. Type variable must be fresh.</li>
<li>an injectivity annotation of the form <code class="docutils literal"><span class="pre">|</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code>, where <code class="docutils literal"><span class="pre">A</span></code> is the
result type variable (see previous bullet) and <code class="docutils literal"><span class="pre">B</span></code> is a list of
argument type and kind variables in which type family is injective.
It is possible to omit some variables if type family is not injective
in them.</li>
</ul>
<p>Examples:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">Id</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">result</span> <span class="o">|</span> <span class="n">result</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="kr">where</span>
<span class="kr">type</span> <span class="n">family</span> <span class="kt">F</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">d</span> <span class="o">|</span> <span class="n">d</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="n">c</span> <span class="n">b</span>
<span class="kr">type</span> <span class="n">family</span> <span class="kt">G</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">foo</span> <span class="o">|</span> <span class="n">foo</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="n">b</span> <span class="kr">where</span>
</pre></div>
</div>
<p>For open and closed type families it is OK to name the result but skip
the injectivity annotation. This is not the case for associated type
synonyms, where the named result without injectivity annotation will be
interpreted as associated type synonym default.</p>
</div>
<div class="section" id="verifying-injectivity-annotation-against-type-family-equations">
<span id="injective-ty-fams-typecheck"></span><h3>10.9.7.2. Verifying injectivity annotation against type family equations<a class="headerlink" href="#verifying-injectivity-annotation-against-type-family-equations" title="Permalink to this headline">¶</a></h3>
<p>Once the user declares type family to be injective GHC must verify that
this declaration is correct, ie. type family equations don&#8217;t violate the
injectivity annotation. A general idea is that if at least one equation
(bullets (1), (2) and (3) below) or a pair of equations (bullets (4) and
(5) below) violates the injectivity annotation then a type family is not
injective in a way user claims and an error is reported. In the bullets
below <em>RHS</em> refers to the right-hand side of the type family equation
being checked for injectivity. <em>LHS</em> refers to the arguments of that
type family equation. Below are the rules followed when checking
injectivity of a type family:</p>
<ol class="arabic">
<li><p class="first">If a RHS of a type family equation is a type family application GHC
reports that the type family is not injective.</p>
</li>
<li><p class="first">If a RHS of a type family equation is a bare type variable we require
that all LHS variables (including implicit kind variables) are also
bare. In other words, this has to be a sole equation of that type
family and it has to cover all possible patterns. If the patterns are
not covering GHC reports that the type family is not injective.</p>
</li>
<li><p class="first">If a LHS type variable that is declared as injective is not mentioned
on injective position
in the RHS GHC reports that the type family is not injective.
Injective position means either argument to a type constructor or
injective argument to a type family.</p>
</li>
<li><p class="first"><em>Open type families</em> Open type families are typechecked
incrementally. This means that when a module is imported type family
instances contained in that module are checked against instances
present in already imported modules.</p>
<p>A pair of an open type family equations is checked by attempting to
unify their RHSs. If the RHSs don&#8217;t unify this pair does not violate
injectivity annotation. If unification succeeds with a substitution
then LHSs of unified equations must be identical under that
substitution. If they are not identical then GHC reports that the
type family is not injective.</p>
</li>
<li><p class="first">In a <em>closed type family</em> all equations are ordered and in one place.
Equations are also checked pair-wise but this time an equation has to
be paired with all the preceeding equations. Of course a
single-equation closed type family is trivially injective (unless
(1), (2) or (3) above holds).</p>
<p>When checking a pair of closed type family equations GHC tried to
unify their RHSs. If they don&#8217;t unify this pair of equations does not
violate injectivity annotation. If the RHSs can be unified under some
substitution (possibly empty) then either the LHSs unify under the
same substitution or the LHS of the latter equation is subsumed by
earlier equations. If neither condition is met GHC reports that a
type family is not injective.</p>
</li>
</ol>
<p>Note that for the purpose of injectivity check in bullets (4) and (5)
GHC uses a special variant of unification algorithm that treats type
family applications as possibly unifying with anything.</p>
</div>
</div>
</div>
<div class="section" id="datatype-promotion">
<span id="promotion"></span><h1>10.10. Datatype promotion<a class="headerlink" href="#datatype-promotion" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XDataKinds">
<code class="descname">-XDataKinds</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XDataKinds" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.4.1</td>
</tr>
</tbody>
</table>
<p>Allow promotion of data types to kind level.</p>
</dd></dl>

<p>This section describes <em>data type promotion</em>, an extension to the kind
system that complements kind polymorphism. It is enabled by
<a class="reference internal" href="#ghc-flag--XDataKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDataKinds</span></code></a>, and described in more detail in the paper <a class="reference external" href="http://dreixel.net/research/pdf/ghp.pdf">Giving
Haskell a Promotion</a>, which
appeared at TLDI 2012.</p>
<div class="section" id="motivation">
<h2>10.10.1. Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>Standard Haskell has a rich type language. Types classify terms and
serve to avoid many common programming mistakes. The kind language,
however, is relatively simple, distinguishing only regular types (kind
<code class="docutils literal"><span class="pre">*</span></code>) and type constructors (e.g. kind <code class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>).
In particular when using advanced type
system features, such as type families (<a class="reference internal" href="#type-families"><span>Type families</span></a>) or GADTs
(<a class="reference internal" href="#gadt"><span>Generalised Algebraic Data Types (GADTs)</span></a>), this simple kind system is insufficient, and fails to
prevent simple errors. Consider the example of type-level natural
numbers, and length-indexed vectors:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Ze</span>
<span class="kr">data</span> <span class="kt">Su</span> <span class="n">n</span>

<span class="kr">data</span> <span class="kt">Vec</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="kr">where</span>
  <span class="kt">Nil</span>  <span class="ow">::</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="kt">Ze</span>
  <span class="kt">Cons</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Su</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>The kind of <code class="docutils literal"><span class="pre">Vec</span></code> is <code class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. This means that, e.g.,
<code class="docutils literal"><span class="pre">Vec</span> <span class="pre">Int</span> <span class="pre">Char</span></code> is a well-kinded type, even though this is not what we
intend when defining length-indexed vectors.</p>
<p>With <a class="reference internal" href="#ghc-flag--XDataKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDataKinds</span></code></a>, the example above can then be rewritten to:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data Nat = Ze | Su Nat

data Vec :: * -&gt; Nat -&gt; * where
  Nil  :: Vec a &#39;Ze
  Cons :: a -&gt; Vec a n -&gt; Vec a (&#39;Su n)
</pre></div>
</div>
<p>With the improved kind of <code class="docutils literal"><span class="pre">Vec</span></code>, things like <code class="docutils literal"><span class="pre">Vec</span> <span class="pre">Int</span> <span class="pre">Char</span></code> are now
ill-kinded, and GHC will report an error.</p>
</div>
<div class="section" id="overview">
<h2>10.10.2. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>With <a class="reference internal" href="#ghc-flag--XDataKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDataKinds</span></code></a>, GHC automatically promotes every datatype
to be a kind and its (value) constructors to be type constructors. The
following types</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Nat</span> <span class="ow">=</span> <span class="kt">Zero</span> <span class="o">|</span> <span class="kt">Succ</span> <span class="kt">Nat</span>

<span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nil</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span>

<span class="kr">data</span> <span class="kt">Sum</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">L</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">R</span> <span class="n">b</span>
</pre></div>
</div>
<p>give rise to the following kinds and type constructors (where promoted
constructors are prefixed by a tick <code class="docutils literal"><span class="pre">'</span></code>):</p>
<div class="highlight-haskell"><div class="highlight"><pre>Nat :: *
&#39;Zero :: Nat
&#39;Succ :: Nat -&gt; Nat

List :: * -&gt; *
&#39;Nil  :: forall k. List k
&#39;Cons :: forall k. k -&gt; List k -&gt; List k

Pair  :: * -&gt; * -&gt; *
&#39;Pair :: forall k1 k2. k1 -&gt; k2 -&gt; Pair k1 k2

Sum :: * -&gt; * -&gt; *
&#39;L :: k1 -&gt; Sum k1 k2
&#39;R :: k2 -&gt; Sum k1 k2
</pre></div>
</div>
<p>The following restrictions apply to promotion:</p>
<ul class="simple">
<li>We promote <code class="docutils literal"><span class="pre">data</span></code> types and <code class="docutils literal"><span class="pre">newtypes</span></code>; type synonyms and
type/data families are not promoted (<a class="reference internal" href="#type-families"><span>Type families</span></a>).</li>
<li>We only promote types whose kinds are of the form
<code class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. In particular, we do not promote
higher-kinded datatypes such as <code class="docutils literal"><span class="pre">data</span> <span class="pre">Fix</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">In</span> <span class="pre">(f</span> <span class="pre">(Fix</span> <span class="pre">f))</span></code>, or
datatypes whose kinds involve promoted types such as
<code class="docutils literal"><span class="pre">Vec</span> <span class="pre">::</span> <span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">Nat</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>.</li>
<li>We do not promote data constructors that are kind polymorphic,
involve constraints, mention type or data families, or involve types
that are not promotable.</li>
</ul>
<p>The flag <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a> (which implies <a class="reference internal" href="#ghc-flag--XDataKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDataKinds</span></code></a>)
relaxes some of these restrictions, allowing:</p>
<ul>
<li><p class="first">Promotion of type synonyms and type families, but not data families.
GHC&#8217;s type theory just isn&#8217;t up to the task of promoting data families,
which requires full dependent types.</p>
</li>
<li><p class="first">All datatypes, even those with rich kinds, get promoted. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data Proxy a = Proxy
data App f a = MkApp (f a)   -- App :: forall k. (k -&gt; *) -&gt; k -&gt; *
x = Proxy :: Proxy (&#39;MkApp (&#39;Just &#39;True))
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="distinguishing-between-types-and-constructors">
<span id="promotion-syntax"></span><h2>10.10.3. Distinguishing between types and constructors<a class="headerlink" href="#distinguishing-between-types-and-constructors" title="Permalink to this headline">¶</a></h2>
<p>In the examples above, all promoted constructors are prefixed with a single
quote mark <code class="docutils literal"><span class="pre">'</span></code>. This mark tells GHC to look in the data constructor namespace
for a name, not the type (constructor) namespace. Consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">P</span> <span class="ow">=</span> <span class="kt">MkP</span>    <span class="c1">-- 1</span>

<span class="kr">data</span> <span class="kt">Prom</span> <span class="ow">=</span> <span class="kt">P</span>   <span class="c1">-- 2</span>
</pre></div>
</div>
<p>We can thus distinguish the type <code class="docutils literal"><span class="pre">P</span></code> (which has a constructor <code class="docutils literal"><span class="pre">MkP</span></code>)
from the promoted data constructor <code class="docutils literal"><span class="pre">'P</span></code> (of kind <code class="docutils literal"><span class="pre">Prom</span></code>).</p>
<p>As a convenience, GHC allows you to omit the quote mark when the name is
unambiguous. However, our experience has shown that the quote mark helps
to make code more readable and less error-prone. GHC thus supports
<a class="reference internal" href="using-warnings.html#ghc-flag--Wunticked-promoted-constructors"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wunticked-promoted-constructors</span></code></a> that will warn you if you
use a promoted data constructor without a preceding quote mark.</p>
<p>Just as in the case of Template Haskell (<a class="reference internal" href="#th-syntax"><span>Syntax</span></a>), GHC gets
confused if you put a quote mark before a data constructor whose second
character is a quote mark. In this case, just put a space between the
promotion quote and the data constructor:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data T = A&#39;
type S = &#39;A&#39;   -- ERROR: looks like a character
type R = &#39; A&#39;  -- OK: promoted `A&#39;`
</pre></div>
</div>
</div>
<div class="section" id="promoted-list-and-tuple-types">
<span id="promoted-lists-and-tuples"></span><h2>10.10.4. Promoted list and tuple types<a class="headerlink" href="#promoted-list-and-tuple-types" title="Permalink to this headline">¶</a></h2>
<p>With <a class="reference internal" href="#ghc-flag--XDataKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDataKinds</span></code></a>, Haskell&#8217;s list and tuple types are natively
promoted to kinds, and enjoy the same convenient syntax at the type
level, albeit prefixed with a quote:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data HList :: [*] -&gt; * where
  HNil  :: HList &#39;[]
  HCons :: a -&gt; HList t -&gt; HList (a &#39;: t)

data Tuple :: (*,*) -&gt; * where
  Tuple :: a -&gt; b -&gt; Tuple &#39;(a,b)

foo0 :: HList &#39;[]
foo0 = HNil

foo1 :: HList &#39;[Int]
foo1 = HCons (3::Int) HNil

foo2 :: HList [Int, Bool]
foo2 = ...
</pre></div>
</div>
<p>For type-level lists of <em>two or more elements</em>, such as the signature of
<code class="docutils literal"><span class="pre">foo2</span></code> above, the quote may be omitted because the meaning is unambiguous. But
for lists of one or zero elements (as in <code class="docutils literal"><span class="pre">foo0</span></code> and <code class="docutils literal"><span class="pre">foo1</span></code>), the quote is
required, because the types <code class="docutils literal"><span class="pre">[]</span></code> and <code class="docutils literal"><span class="pre">[Int]</span></code> have existing meanings in
Haskell.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The declaration for <code class="docutils literal"><span class="pre">HCons</span></code> also requires <a class="reference internal" href="#ghc-flag--XTypeOperators"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeOperators</span></code></a>
because of infix type operator <code class="docutils literal"><span class="pre">(:')</span></code></p>
</div>
</div>
<div class="section" id="promoting-existential-data-constructors">
<span id="promotion-existentials"></span><h2>10.10.5. Promoting existential data constructors<a class="headerlink" href="#promoting-existential-data-constructors" title="Permalink to this headline">¶</a></h2>
<p>Note that we do promote existential data constructors that are otherwise
suitable. For example, consider the following:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Ex</span> <span class="ow">::</span> <span class="o">*</span> <span class="kr">where</span>
  <span class="kt">MkEx</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ex</span>
</pre></div>
</div>
<p>Both the type <code class="docutils literal"><span class="pre">Ex</span></code> and the data constructor <code class="docutils literal"><span class="pre">MkEx</span></code> get promoted,
with the polymorphic kind <code class="docutils literal"><span class="pre">'MkEx</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">k.</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">Ex</span></code>. Somewhat
surprisingly, you can write a type family to extract the member of a
type-level existential:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">UnEx</span> <span class="p">(</span><span class="n">ex</span> <span class="ow">::</span> <span class="kt">Ex</span><span class="p">)</span> <span class="ow">::</span> <span class="n">k</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">UnEx</span> <span class="p">(</span><span class="kt">MkEx</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div>
</div>
<p>At first blush, <code class="docutils literal"><span class="pre">UnEx</span></code> seems poorly-kinded. The return kind <code class="docutils literal"><span class="pre">k</span></code> is
not mentioned in the arguments, and thus it would seem that an instance
would have to return a member of <code class="docutils literal"><span class="pre">k</span></code> <em>for any</em> <code class="docutils literal"><span class="pre">k</span></code>. However, this is
not the case. The type family <code class="docutils literal"><span class="pre">UnEx</span></code> is a kind-indexed type family.
The return kind <code class="docutils literal"><span class="pre">k</span></code> is an implicit parameter to <code class="docutils literal"><span class="pre">UnEx</span></code>. The
elaborated definitions are as follows (where implicit parameters are
denoted by braces):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">UnEx</span> <span class="p">{</span><span class="n">k</span> <span class="ow">::</span> <span class="o">*</span><span class="p">}</span> <span class="p">(</span><span class="n">ex</span> <span class="ow">::</span> <span class="kt">Ex</span><span class="p">)</span> <span class="ow">::</span> <span class="n">k</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">UnEx</span> <span class="p">{</span><span class="n">k</span><span class="p">}</span> <span class="p">(</span><span class="kt">MkEx</span> <span class="o">@</span><span class="n">k</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div>
</div>
<p>Thus, the instance triggers only when the implicit parameter to <code class="docutils literal"><span class="pre">UnEx</span></code>
matches the implicit parameter to <code class="docutils literal"><span class="pre">MkEx</span></code>. Because <code class="docutils literal"><span class="pre">k</span></code> is actually a
parameter to <code class="docutils literal"><span class="pre">UnEx</span></code>, the kind is not escaping the existential, and the
above code is valid.</p>
<p>See also <a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/7347">Trac #7347</a>.</p>
</div>
</div>
<div class="section" id="kind-polymorphism-and-type-in-type">
<span id="kind-polymorphism"></span><span id="type-in-type"></span><h1>10.11. Kind polymorphism and Type-in-Type<a class="headerlink" href="#kind-polymorphism-and-type-in-type" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XTypeInType">
<code class="descname">-XTypeInType</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XTypeInType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a>, <a class="reference internal" href="#ghc-flag--XDataKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDataKinds</span></code></a>, <a class="reference internal" href="#ghc-flag--XKindSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XKindSignatures</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Allow kinds to be as intricate as types, allowing explicit quantification
over kind variables, higher-rank kinds, and the use of type synonyms and
families in kinds, among other features.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--XPolyKinds">
<code class="descname">-XPolyKinds</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XPolyKinds" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XKindSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XKindSignatures</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Since:</th><td class="field-body">7.4.1</td>
</tr>
</tbody>
</table>
<p>Allow kind polymorphic types.</p>
</dd></dl>

<p>This section describes GHC&#8217;s kind system, as it appears in version 8.0 and beyond.
The kind system as described here is always in effect, with or without extensions,
although it is a conservative extension beyond standard Haskell. The extensions
above simply enable syntax and tweak the inference algorithm to allow users to
take advantage of the extra expressiveness of GHC&#8217;s kind system.</p>
<div class="section" id="the-difference-between-xtypeintype-and-xpolykinds">
<h2>10.11.1. The difference between <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a> and <a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a><a class="headerlink" href="#the-difference-between-xtypeintype-and-xpolykinds" title="Permalink to this headline">¶</a></h2>
<p>It is natural to consider <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a> as an extension of
<a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a>. The latter simply enables fewer features of GHC&#8217;s
rich kind system than does the former. The need for two separate extensions
stems from their history: <a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a> was introduced for GHC 7.4,
when it was experimental and temperamental. The wrinkles were smoothed out for
GHC 7.6. <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a> was introduced for GHC 8.0, and is currently
experimental and temperamental, with the wrinkles to be smoothed out in due
course. The intent of having the two extensions is that users can rely on
<a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a> to work properly while being duly sceptical of
<a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>. In particular, we recommend enabling
<a class="reference internal" href="debugging.html#ghc-flag--dcore-lint"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dcore-lint</span></code></a> whenever using <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>; that flag
turns on a set of internal checks within GHC that will discover bugs in the
implementation of <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>. Please report bugs at <a class="reference external" href="https://ghc.haskell.org/trac/ghc/wiki/ReportABug">our bug
tracker</a>.</p>
<p>Although we have tried to allow the new behavior only when
<a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a> is enabled, some particularly thorny cases may have
slipped through. It is thus possible that some construct is available in GHC
8.0 with <a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a> that was not possible in GHC 7.x. If you spot
such a case, you are welcome to submit that as a bug as well. We flag
newly-available capabilities below.</p>
</div>
<div class="section" id="overview-of-kind-polymorphism">
<h2>10.11.2. Overview of kind polymorphism<a class="headerlink" href="#overview-of-kind-polymorphism" title="Permalink to this headline">¶</a></h2>
<p>Consider inferring the kind for</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">App</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkApp</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>In Haskell 98, the inferred kind for <code class="docutils literal"><span class="pre">App</span></code> is <code class="docutils literal"><span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>.
But this is overly specific, because another suitable Haskell 98 kind for
<code class="docutils literal"><span class="pre">App</span></code> is <code class="docutils literal"><span class="pre">((*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>, where the kind assigned
to <code class="docutils literal"><span class="pre">a</span></code> is <code class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. Indeed, without kind signatures
(<a class="reference internal" href="#ghc-flag--XKindSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XKindSignatures</span></code></a>), it is necessary to use a dummy constructor
to get a Haskell compiler to infer the second kind. With kind polymorphism
(<a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a>), GHC infers the kind <code class="docutils literal"><span class="pre">forall</span> <span class="pre">k.</span> <span class="pre">(k</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>
for <code class="docutils literal"><span class="pre">App</span></code>, which is its most general kind.</p>
<p>Thus, the chief benefit of kind polymorphism is that we can now infer these
most general kinds and use <code class="docutils literal"><span class="pre">App</span></code> at a variety of kinds:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">App</span> <span class="kt">Maybe</span> <span class="kt">Int</span>   <span class="c1">-- `k` is instantiated to *</span>

<span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">(</span><span class="n">a</span> <span class="kt">Int</span><span class="p">)</span>    <span class="c1">-- `a` is inferred to have kind (* -&gt; *)</span>
<span class="kt">App</span> <span class="kt">T</span> <span class="kt">Maybe</span>     <span class="c1">-- `k` is instantiated to (* -&gt; *)</span>
</pre></div>
</div>
</div>
<div class="section" id="overview-of-type-in-type">
<h2>10.11.3. Overview of Type-in-Type<a class="headerlink" href="#overview-of-type-in-type" title="Permalink to this headline">¶</a></h2>
<p>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds
are indeed one and the same. Nothing within GHC distinguishes between types
and kinds. Another way of thinking about this is that the type <code class="docutils literal"><span class="pre">Bool</span></code> and
the &#8220;promoted kind&#8221; <code class="docutils literal"><span class="pre">Bool</span></code> are actually identical. (Note that term
<code class="docutils literal"><span class="pre">True</span></code> and the type <code class="docutils literal"><span class="pre">'True</span></code> are still distinct, because the former can
be used in expressions and the latter in types.) This lack of distinction
between types and kinds is a hallmark of dependently typed languages.
Full dependently typed languages also remove the difference between expressions
and types, but doing that in GHC is a story for another day.</p>
<p>One simplification allowed by combining types and kinds is that the type
of <code class="docutils literal"><span class="pre">*</span></code> is just <code class="docutils literal"><span class="pre">*</span></code>. It is true that the <code class="docutils literal"><span class="pre">*</span> <span class="pre">::</span> <span class="pre">*</span></code> axiom can lead to
non-termination, but this is not a problem in GHC, as we already have other
means of non-terminating programs in both types and expressions. This
decision (among many, many others) <em>does</em> mean that despite the expressiveness
of GHC&#8217;s type system, a &#8220;proof&#8221; you write in Haskell is not an irrefutable
mathematical proof. GHC promises only partial correctness, that if your
programs compile and run to completion, their results indeed have the types
assigned. It makes no claim about programs that do not finish in a finite
amount of time.</p>
<p>To learn more about this decision and the design of GHC under the hood
please see the <a class="reference external" href="http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf">paper</a>
introducing this kind system to GHC/Haskell.</p>
</div>
<div class="section" id="principles-of-kind-inference">
<h2>10.11.4. Principles of kind inference<a class="headerlink" href="#principles-of-kind-inference" title="Permalink to this headline">¶</a></h2>
<p>Generally speaking, when <a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a> is on, GHC tries to infer the
most general kind for a declaration.
In this case the definition has a right-hand side to inform kind
inference. But that is not always the case. Consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">F</span> <span class="n">a</span>
</pre></div>
</div>
<p>Type family declarations have no right-hand side, but GHC must still
infer a kind for <code class="docutils literal"><span class="pre">F</span></code>. Since there are no constraints, it could infer
<code class="docutils literal"><span class="pre">F</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">k1</span> <span class="pre">k2.</span> <span class="pre">k1</span> <span class="pre">-&gt;</span> <span class="pre">k2</span></code>, but that seems <em>too</em> polymorphic. So
GHC defaults those entirely-unconstrained kind variables to <code class="docutils literal"><span class="pre">*</span></code> and we
get <code class="docutils literal"><span class="pre">F</span> <span class="pre">::</span> <span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. You can still declare <code class="docutils literal"><span class="pre">F</span></code> to be kind-polymorphic
using kind signatures:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">F1</span> <span class="n">a</span>                <span class="c1">-- F1 :: * -&gt; *</span>
<span class="kr">type</span> <span class="n">family</span> <span class="kt">F2</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span>         <span class="c1">-- F2 :: forall k. k -&gt; *</span>
<span class="kr">type</span> <span class="n">family</span> <span class="kt">F3</span> <span class="n">a</span> <span class="ow">::</span> <span class="n">k</span>           <span class="c1">-- F3 :: forall k. * -&gt; k</span>
<span class="kr">type</span> <span class="n">family</span> <span class="kt">F4</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k1</span><span class="p">)</span> <span class="ow">::</span> <span class="n">k2</span>  <span class="c1">-- F4 :: forall k1 k2. k1 -&gt; k2</span>
</pre></div>
</div>
<p>The general principle is this:</p>
<ul class="simple">
<li><em>When there is a right-hand side, GHC infers the most polymorphic
kind consistent with the right-hand side.</em> Examples: ordinary data
type and GADT declarations, class declarations. In the case of a
class declaration the role of &#8220;right hand side&#8221; is played by the
class method signatures.</li>
<li><em>When there is no right hand side, GHC defaults argument and result
kinds to ``*``, except when directed otherwise by a kind signature</em>.
Examples: data and open type family declarations.</li>
</ul>
<p>This rule has occasionally-surprising consequences (see
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/10132">Trac #10132</a>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>    <span class="c1">-- Class declarations are generalised</span>
                   <span class="c1">-- so C :: forall k. k -&gt; Constraint</span>
  <span class="kr">data</span> <span class="kt">D1</span> <span class="n">a</span>        <span class="c1">-- No right hand side for these two family</span>
  <span class="kr">type</span> <span class="kt">F1</span> <span class="n">a</span>        <span class="c1">-- declarations, but the class forces (a :: k)</span>
                   <span class="c1">-- so   D1, F1 :: forall k. k -&gt; *</span>

<span class="kr">data</span> <span class="kt">D2</span> <span class="n">a</span>   <span class="c1">-- No right-hand side so D2 :: * -&gt; *</span>
<span class="kr">type</span> <span class="kt">F2</span> <span class="n">a</span>   <span class="c1">-- No right-hand side so F2 :: * -&gt; *</span>
</pre></div>
</div>
<p>The kind-polymorphism from the class declaration makes <code class="docutils literal"><span class="pre">D1</span></code>
kind-polymorphic, but not so <code class="docutils literal"><span class="pre">D2</span></code>; and similarly <code class="docutils literal"><span class="pre">F1</span></code>, <code class="docutils literal"><span class="pre">F1</span></code>.</p>
</div>
<div class="section" id="complete-user-supplied-kind-signatures-and-polymorphic-recursion">
<span id="complete-kind-signatures"></span><span id="index-15"></span><h2>10.11.5. Complete user-supplied kind signatures and polymorphic recursion<a class="headerlink" href="#complete-user-supplied-kind-signatures-and-polymorphic-recursion" title="Permalink to this headline">¶</a></h2>
<p>Just as in type inference, kind inference for recursive types can only
use <em>monomorphic</em> recursion. Consider this (contrived) example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">T</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">))</span>
<span class="c1">-- GHC infers kind  T :: (* -&gt; *) -&gt; * -&gt; *</span>
</pre></div>
</div>
<p>The recursive use of <code class="docutils literal"><span class="pre">T</span></code> forced the second argument to have kind
<code class="docutils literal"><span class="pre">*</span></code>. However, just as in type inference, you can achieve polymorphic
recursion by giving a <em>complete user-supplied kind signature</em> (or CUSK)
for <code class="docutils literal"><span class="pre">T</span></code>. A CUSK is present when all argument kinds and the result kind
are known, without any need for inference. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="p">(</span><span class="n">m</span> <span class="ow">::</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="kr">where</span>
  <span class="kt">MkT</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>The complete user-supplied kind signature specifies the polymorphic kind
for <code class="docutils literal"><span class="pre">T</span></code>, and this signature is used for all the calls to <code class="docutils literal"><span class="pre">T</span></code>
including the recursive ones. In particular, the recursive use of <code class="docutils literal"><span class="pre">T</span></code>
is at kind <code class="docutils literal"><span class="pre">*</span></code>.</p>
<p>What exactly is considered to be a &#8220;complete user-supplied kind
signature&#8221; for a type constructor? These are the forms:</p>
<ul>
<li><p class="first">For a datatype, every type variable must be annotated with a kind. In
a GADT-style declaration, there may also be a kind signature (with a
top-level <code class="docutils literal"><span class="pre">::</span></code> in the header), but the presence or absence of this
annotation does not affect whether or not the declaration has a
complete signature.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T1</span> <span class="ow">::</span> <span class="p">(</span><span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span>       <span class="kr">where</span> <span class="o">...</span>
<span class="c1">-- Yes;  T1 :: forall k. (k-&gt;*) -&gt; k -&gt; *</span>

<span class="kr">data</span> <span class="kt">T2</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span>     <span class="kr">where</span> <span class="o">...</span>
<span class="c1">-- Yes;  T2 :: forall k. (k-&gt;*) -&gt; k -&gt; *</span>

<span class="kr">data</span> <span class="kt">T3</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span> <span class="kr">where</span> <span class="o">...</span>
<span class="c1">-- Yes;  T3 :: forall k. (k-&gt;*) -&gt; k -&gt; *</span>

<span class="kr">data</span> <span class="kt">T4</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span>      <span class="kr">where</span> <span class="o">...</span>
<span class="c1">-- Yes;  T4 :: forall k. (k-&gt;*) -&gt; k -&gt; *</span>

<span class="kr">data</span> <span class="kt">T5</span> <span class="n">a</span> <span class="p">(</span><span class="n">b</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>             <span class="kr">where</span> <span class="o">...</span>
<span class="c1">-- No;  kind is inferred</span>

<span class="kr">data</span> <span class="kt">T6</span> <span class="n">a</span> <span class="n">b</span>                         <span class="kr">where</span> <span class="o">...</span>
<span class="c1">-- No;  kind is inferred</span>
</pre></div>
</div>
</li>
<li><p class="first">For a datatype with a top-level <code class="docutils literal"><span class="pre">::</span></code> when <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>
is in effect: all kind variables introduced after the <code class="docutils literal"><span class="pre">::</span></code> must
be explicitly quantified.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- -XTypeInType is on</span>
<span class="kr">data</span> <span class="kt">T1</span> <span class="ow">::</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span>            <span class="c1">-- No CUSK: `k` is not explicitly quantified</span>
<span class="kr">data</span> <span class="kt">T2</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">k</span><span class="o">.</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span>  <span class="c1">-- CUSK: `k` is bound explicitly</span>
<span class="kr">data</span> <span class="kt">T3</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">k</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span><span class="o">.</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span>   <span class="c1">-- still a CUSK</span>
</pre></div>
</div>
<p>Note that the first example would indeed have a CUSK without
<a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>.</p>
</li>
<li><p class="first">For a class, every type variable must be annotated with a kind.</p>
</li>
<li><p class="first">For a type synonym, every type variable and the result type must all
be annotated with kinds:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">S1</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span>    <span class="c1">-- Yes   S1 :: forall k. k -&gt; k</span>
<span class="kr">type</span> <span class="kt">S2</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>           <span class="c1">-- No    kind is inferred</span>
<span class="kr">type</span> <span class="kt">S3</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Proxy</span> <span class="n">a</span>     <span class="c1">-- No    kind is inferred</span>
</pre></div>
</div>
<p>Note that in <code class="docutils literal"><span class="pre">S2</span></code> and <code class="docutils literal"><span class="pre">S3</span></code>, the kind of the right-hand side is
rather apparent, but it is still not considered to have a complete
signature &#8211; no inference can be done before detecting the signature.</p>
</li>
<li><p class="first">An un-associated open type or data family declaration <em>always</em> has a CUSK;
un-annotated type variables default to
kind <code class="docutils literal"><span class="pre">*</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">family</span> <span class="kt">D1</span> <span class="n">a</span>               <span class="c1">-- D1 :: * -&gt; *</span>
<span class="kr">data</span> <span class="n">family</span> <span class="kt">D2</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span>        <span class="c1">-- D2 :: forall k. k -&gt; *</span>
<span class="kr">data</span> <span class="n">family</span> <span class="kt">D3</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>   <span class="c1">-- D3 :: forall k. k -&gt; *</span>
<span class="kr">type</span> <span class="n">family</span> <span class="kt">S1</span> <span class="n">a</span> <span class="ow">::</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span>     <span class="c1">-- S1 :: forall k. * -&gt; k -&gt; *</span>
</pre></div>
</div>
</li>
<li><p class="first">An associated type or data family declaration has a CUSK precisely if
its enclosing class has a CUSK.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>                <span class="c1">-- no CUSK</span>
  <span class="kr">type</span> <span class="kt">AT</span> <span class="n">a</span> <span class="n">b</span>                  <span class="c1">-- no CUSK, b is defaulted</span>

<span class="kr">class</span> <span class="kt">D</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="kr">where</span>         <span class="c1">-- yes CUSK</span>
  <span class="kr">type</span> <span class="kt">AT2</span> <span class="n">a</span> <span class="n">b</span>                 <span class="c1">-- yes CUSK, b is defaulted</span>
</pre></div>
</div>
</li>
<li><p class="first">A closed type family has a complete signature when all of its type
variables are annotated and a return kind (with a top-level <code class="docutils literal"><span class="pre">::</span></code>)
is supplied.</p>
</li>
</ul>
<p>With <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a> enabled, it is possible to write a datatype
that syntactically has a CUSK (according to the rules above)
but actually requires some inference. As a very contrived example, consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Proxy</span> <span class="n">a</span>           <span class="c1">-- Proxy :: forall k. k -&gt; *</span>
<span class="kr">data</span> <span class="kt">X</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="kt">Proxy</span> <span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>According to the rules above <code class="docutils literal"><span class="pre">X</span></code> has a CUSK. Yet, what is the kind of <code class="docutils literal"><span class="pre">k</span></code>?
It is impossible to know. This code is thus rejected as masquerading as having
a CUSK, but not really. If you wish <code class="docutils literal"><span class="pre">k</span></code> to be polykinded, it is straightforward
to specify this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">X</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="kt">Proxy</span> <span class="p">(</span><span class="n">k1</span> <span class="ow">::</span> <span class="n">k2</span><span class="p">))</span>
</pre></div>
</div>
<p>The above definition is indeed fully fixed, with no masquerade.</p>
</div>
<div class="section" id="kind-inference-in-closed-type-families">
<h2>10.11.6. Kind inference in closed type families<a class="headerlink" href="#kind-inference-in-closed-type-families" title="Permalink to this headline">¶</a></h2>
<p>Although all open type families are considered to have a complete
user-supplied kind signature, we can relax this condition for closed
type families, where we have equations on which to perform kind
inference. GHC will infer kinds for the arguments and result types of a
closed type family.</p>
<p>GHC supports <em>kind-indexed</em> type families, where the family matches both
on the kind and type. GHC will <em>not</em> infer this behaviour without a
complete user-supplied kind signature, as doing so would sometimes infer
non-principal types. Indeed, we can see kind-indexing as a form
of polymorphic recursion, where a type is used at a kind other than
its most general in its own definition.</p>
<p>For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">F1</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">F1</span> <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">False</span>
  <span class="kt">F1</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="kt">F1</span> <span class="n">x</span>     <span class="ow">=</span> <span class="n">x</span>
<span class="c1">-- F1 fails to compile: kind-indexing is not inferred</span>

<span class="kr">type</span> <span class="n">family</span> <span class="kt">F2</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">F2</span> <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">False</span>
  <span class="kt">F2</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="kt">F2</span> <span class="n">x</span>     <span class="ow">=</span> <span class="n">x</span>
<span class="c1">-- F2 fails to compile: no complete signature</span>

<span class="kr">type</span> <span class="n">family</span> <span class="kt">F3</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="ow">::</span> <span class="n">k</span> <span class="kr">where</span>
  <span class="kt">F3</span> <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">False</span>
  <span class="kt">F3</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="kt">F3</span> <span class="n">x</span>     <span class="ow">=</span> <span class="n">x</span>
<span class="c1">-- OK</span>
</pre></div>
</div>
</div>
<div class="section" id="kind-inference-in-class-instance-declarations">
<h2>10.11.7. Kind inference in class instance declarations<a class="headerlink" href="#kind-inference-in-class-instance-declarations" title="Permalink to this headline">¶</a></h2>
<p>Consider the following example of a poly-kinded class and an instance
for it:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">F</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">C</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">F</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>In the class declaration, nothing constrains the kind of the type <code class="docutils literal"><span class="pre">a</span></code>,
so it becomes a poly-kinded type variable <code class="docutils literal"><span class="pre">(a</span> <span class="pre">::</span> <span class="pre">k)</span></code>. Yet, in the
instance declaration, the right-hand side of the associated type
instance <code class="docutils literal"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> says that <code class="docutils literal"><span class="pre">b</span></code> must be of kind <code class="docutils literal"><span class="pre">*</span></code>. GHC could
theoretically propagate this information back into the instance head,
and make that instance declaration apply only to type of kind <code class="docutils literal"><span class="pre">*</span></code>, as
opposed to types of any kind. However, GHC does <em>not</em> do this.</p>
<p>In short: GHC does <em>not</em> propagate kind information from the members of
a class instance declaration into the instance declaration head.</p>
<p>This lack of kind inference is simply an engineering problem within GHC,
but getting it to work would make a substantial change to the inference
infrastructure, and it&#8217;s not clear the payoff is worth it. If you want
to restrict <code class="docutils literal"><span class="pre">b</span></code>&#8216;s kind in the instance above, just use a kind
signature in the instance head.</p>
</div>
<div class="section" id="kind-inference-in-type-signatures">
<h2>10.11.8. Kind inference in type signatures<a class="headerlink" href="#kind-inference-in-type-signatures" title="Permalink to this headline">¶</a></h2>
<p>When kind-checking a type, GHC considers only what is written in that
type when figuring out how to generalise the type&#8217;s kind.</p>
<p>For example,
consider these definitions (with <a class="reference internal" href="#ghc-flag--XScopedTypeVariables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XScopedTypeVariables</span></code></a>):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Proxy</span> <span class="n">a</span>    <span class="c1">-- Proxy :: forall k. k -&gt; *</span>
<span class="nf">p</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Proxy</span> <span class="n">a</span>
<span class="nf">p</span> <span class="ow">=</span> <span class="kt">Proxy</span> <span class="ow">::</span> <span class="kt">Proxy</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>GHC reports an error, saying that the kind of <code class="docutils literal"><span class="pre">a</span></code> should be a kind variable
<code class="docutils literal"><span class="pre">k</span></code>, not <code class="docutils literal"><span class="pre">*</span></code>. This is because, by looking at the type signature
<code class="docutils literal"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">Proxy</span> <span class="pre">a</span></code>, GHC assumes <code class="docutils literal"><span class="pre">a</span></code>&#8216;s kind should be generalised, not
restricted to be <code class="docutils literal"><span class="pre">*</span></code>. The function definition is then rejected for being
more specific than its type signature.</p>
</div>
<div class="section" id="explicit-kind-quantification">
<h2>10.11.9. Explicit kind quantification<a class="headerlink" href="#explicit-kind-quantification" title="Permalink to this headline">¶</a></h2>
<p>Enabled by <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>, GHC now supports explicit kind quantification,
as in these examples:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Proxy</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">k</span><span class="o">.</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">k</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span> <span class="kt">Proxy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>Note that the second example has a <code class="docutils literal"><span class="pre">forall</span></code> that binds both a kind <code class="docutils literal"><span class="pre">k</span></code> and
a type variable <code class="docutils literal"><span class="pre">a</span></code> of kind <code class="docutils literal"><span class="pre">k</span></code>. In general, there is no limit to how
deeply nested this sort of dependency can work. However, the dependency must
be well-scoped: <code class="docutils literal"><span class="pre">forall</span> <span class="pre">(a</span> <span class="pre">::</span> <span class="pre">k)</span> <span class="pre">k.</span> <span class="pre">...</span></code> is an error.</p>
<p>For backward compatibility, kind variables <em>do not</em> need to be bound explicitly,
even if the type starts with <code class="docutils literal"><span class="pre">forall</span></code>.</p>
<p>Accordingly, the rule for kind quantification in higher-rank contexts has
changed slightly. In GHC 7, if a kind variable was mentioned for the first
time in the kind of a variable bound in a non-top-level <code class="docutils literal"><span class="pre">forall</span></code>, the kind
variable was bound there, too.
That is, in <code class="docutils literal"><span class="pre">f</span> <span class="pre">::</span> <span class="pre">(forall</span> <span class="pre">(a</span> <span class="pre">::</span> <span class="pre">k).</span> <span class="pre">...)</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code>, the <code class="docutils literal"><span class="pre">k</span></code> was bound
by the same <code class="docutils literal"><span class="pre">forall</span></code> as the <code class="docutils literal"><span class="pre">a</span></code>. In GHC 8, however, all kind variables
mentioned in a type are bound at the outermost level. If you want one bound
in a higher-rank <code class="docutils literal"><span class="pre">forall</span></code>, include it explicitly.</p>
</div>
<div class="section" id="kind-indexed-gadts">
<h2>10.11.10. Kind-indexed GADTs<a class="headerlink" href="#kind-indexed-gadts" title="Permalink to this headline">¶</a></h2>
<p>Consider the type</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">G</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">GInt</span>    <span class="ow">::</span> <span class="kt">G</span> <span class="kt">Int</span>
  <span class="kt">GMaybe</span>  <span class="ow">::</span> <span class="kt">G</span> <span class="kt">Maybe</span>
</pre></div>
</div>
<p>This datatype <code class="docutils literal"><span class="pre">G</span></code> is GADT-like in both its kind and its type. Suppose you
have <code class="docutils literal"><span class="pre">g</span> <span class="pre">::</span> <span class="pre">G</span> <span class="pre">a</span></code>, where <code class="docutils literal"><span class="pre">a</span> <span class="pre">::</span> <span class="pre">k</span></code>. Then pattern matching to discover that
<code class="docutils literal"><span class="pre">g</span></code> is in fact <code class="docutils literal"><span class="pre">`GMaybe</span></code> tells you both that <code class="docutils literal"><span class="pre">k</span> <span class="pre">~</span> <span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span></code> and
<code class="docutils literal"><span class="pre">a</span> <span class="pre">~</span> <span class="pre">Maybe</span></code>. The definition for <code class="docutils literal"><span class="pre">G</span></code> requires that <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>
be in effect, but pattern-matching on <code class="docutils literal"><span class="pre">G</span></code> requires no extension beyond
<a class="reference internal" href="#ghc-flag--XGADTs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGADTs</span></code></a>. That this works is actually a straightforward extension
of regular GADTs and a consequence of the fact that kinds and types are the
same.</p>
<p>Note that the datatype <code class="docutils literal"><span class="pre">G</span></code> is used at different kinds in its body, and
therefore that kind-indexed GADTs use a form of polymorphic recursion.
It is thus only possible to use this feature if you have provided a
complete user-supplied kind signature
for the datatype (<a class="reference internal" href="#complete-kind-signatures"><span>Complete user-supplied kind signatures and polymorphic recursion</span></a>).</p>
</div>
<div class="section" id="constraints-in-kinds">
<h2>10.11.11. Constraints in kinds<a class="headerlink" href="#constraints-in-kinds" title="Permalink to this headline">¶</a></h2>
<p>As kinds and types are the same, kinds can now (with <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>)
contain type constraints. Only equality constraints are currently supported,
however. We expect this to extend to other constraints in the future.</p>
<p>Here is an example of a constrained kind:</p>
<div class="highlight-haskell"><div class="highlight"><pre>type family IsTypeLit a where
  IsTypeLit Nat    = &#39;True
  IsTypeLit Symbol = &#39;True
  IsTypeLit a      = &#39;False

data T :: forall a. (IsTypeLit a ~ &#39;True) =&gt; a -&gt; * where
  MkNat    :: T 42
  MkSymbol :: T &quot;Don&#39;t panic!&quot;
</pre></div>
</div>
<p>The declarations above are accepted. However, if we add <code class="docutils literal"><span class="pre">MkOther</span> <span class="pre">::</span> <span class="pre">T</span> <span class="pre">Int</span></code>,
we get an error that the equality constraint is not satisfied; <code class="docutils literal"><span class="pre">Int</span></code> is
not a type literal. Note that explicitly quantifying with <code class="docutils literal"><span class="pre">forall</span> <span class="pre">a</span></code> is
not necessary here.</p>
</div>
<div class="section" id="the-kind">
<h2>10.11.12. The kind <code class="docutils literal"><span class="pre">*</span></code><a class="headerlink" href="#the-kind" title="Permalink to this headline">¶</a></h2>
<p>The kind <code class="docutils literal"><span class="pre">*</span></code> classifies ordinary types. Without <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>,
this identifier is always in scope when writing a kind. However, with
<a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>, a user may wish to use <code class="docutils literal"><span class="pre">*</span></code> in a type or a
type operator <code class="docutils literal"><span class="pre">*</span></code> in a kind. To make this all more manageable, <code class="docutils literal"><span class="pre">*</span></code>
becomes an (almost) ordinary name with <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a> enabled.
So as not to cause naming collisions, it is not imported by default;
you must <code class="docutils literal"><span class="pre">import</span> <span class="pre">Data.Kind</span></code> to get <code class="docutils literal"><span class="pre">*</span></code> (but only with <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a>
enabled).</p>
<p>The only way <code class="docutils literal"><span class="pre">*</span></code> is unordinary is in its parsing. In order to be backward
compatible, <code class="docutils literal"><span class="pre">*</span></code> is parsed as if it were an alphanumeric idenfifier; note
that we do not write <code class="docutils literal"><span class="pre">Int</span> <span class="pre">::</span> <span class="pre">(*)</span></code> but just plain <code class="docutils literal"><span class="pre">Int</span> <span class="pre">::</span> <span class="pre">*</span></code>. Due to the
bizarreness with which <code class="docutils literal"><span class="pre">*</span></code> is parsed&#8211;and the fact that it is the only such
operator in GHC&#8211;there are some corner cases that are
not handled. We are aware of three:</p>
<ul>
<li><p class="first">In a Haskell-98-style data constructor, you must put parentheses around
<code class="docutils literal"><span class="pre">*</span></code>, like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Universe</span> <span class="ow">=</span> <span class="kt">Ty</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Num</span> <span class="kt">Int</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first">In an import/export list, you must put parentheses around <code class="docutils literal"><span class="pre">*</span></code>, like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.Kind</span> <span class="p">(</span> <span class="nf">type</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Note that the keyword <code class="docutils literal"><span class="pre">type</span></code> there is just to disambiguate the import
from a term-level <code class="docutils literal"><span class="pre">(*)</span></code>. (<a class="reference internal" href="#explicit-namespaces"><span>Explicit namespaces in import/export</span></a>)</p>
</li>
<li><p class="first">In an instance declaration head (the part after the word <code class="docutils literal"><span class="pre">instance</span></code>), you
must parenthesize <code class="docutils literal"><span class="pre">*</span></code>. This applies to all manners of instances, including
the left-hand sides of individual equations of a closed type family.</p>
</li>
</ul>
<p>The <code class="docutils literal"><span class="pre">Data.Kind</span></code> module also exports <code class="docutils literal"><span class="pre">Type</span></code> as a synonym for <code class="docutils literal"><span class="pre">*</span></code>.
Now that type synonyms work in kinds, it is conceivable that we will deprecate
<code class="docutils literal"><span class="pre">*</span></code> when there is a good migration story for everyone to use <code class="docutils literal"><span class="pre">Type</span></code>.
If you like neither of these names, feel free to write your own synonym:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Set</span> <span class="ow">=</span> <span class="o">*</span>   <span class="c1">-- silly Agda programmers...</span>
</pre></div>
</div>
<p>All the affordances for <code class="docutils literal"><span class="pre">*</span></code> also apply to <code class="docutils literal"><span class="pre">★</span></code>, the Unicode variant
of <code class="docutils literal"><span class="pre">*</span></code>.</p>
</div>
<div class="section" id="inferring-dependency-in-datatype-declarations">
<h2>10.11.13. Inferring dependency in datatype declarations<a class="headerlink" href="#inferring-dependency-in-datatype-declarations" title="Permalink to this headline">¶</a></h2>
<p>If a type variable <code class="docutils literal"><span class="pre">a</span></code> in a datatype, class, or type family declaration
depends on another such variable <code class="docutils literal"><span class="pre">k</span></code> in the same declaration, two properties
must hold:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">a</span></code> must appear after <code class="docutils literal"><span class="pre">k</span></code> in the declaration, and</li>
<li><code class="docutils literal"><span class="pre">k</span></code> must appear explicitly in the kind of <em>some</em> type variable in that
declaration.</li>
</ul>
<p>The first bullet simply means that the dependency must be well-scoped. The
second bullet concerns GHC&#8217;s ability to infer dependency. Inferring this
dependency is difficult, and GHC currently requires the dependency to be
made explicit, meaning that <code class="docutils literal"><span class="pre">k</span></code> must appear in the kind of a type variable,
making it obvious to GHC that dependency is intended. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Proxy</span> <span class="n">k</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span>            <span class="c1">-- OK: dependency is &quot;obvious&quot;</span>
<span class="kr">data</span> <span class="kt">Proxy2</span> <span class="n">k</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">P</span> <span class="p">(</span><span class="kt">Proxy</span> <span class="n">k</span> <span class="n">a</span><span class="p">)</span>  <span class="c1">-- ERROR: dependency is unclear</span>
</pre></div>
</div>
<p>In the second declaration, GHC cannot immediately tell that <code class="docutils literal"><span class="pre">k</span></code> should
be a dependent variable, and so the declaration is rejected.</p>
<p>It is conceivable that this restriction will be relaxed in the future,
but it is (at the time of writing) unclear if the difficulties around this
scenario are theoretical (inferring this dependency would mean our type
system does not have principal types) or merely practical (inferring this
dependency is hard, given GHC&#8217;s implementation). So, GHC takes the easy
way out and requires a little help from the user.</p>
</div>
<div class="section" id="kind-defaulting-without-xpolykinds">
<h2>10.11.14. Kind defaulting without <a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a><a class="headerlink" href="#kind-defaulting-without-xpolykinds" title="Permalink to this headline">¶</a></h2>
<p>Without <a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a> or <a class="reference internal" href="#ghc-flag--XTypeInType"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeInType</span></code></a> enabled, GHC
refuses to generalise over kind variables. It thus defaults kind variables
to <code class="docutils literal"><span class="pre">*</span></code> when possible; when this is not possible, an error is issued.</p>
<p>Here is an example of this in action:</p>
<div class="highlight-haskell"><div class="highlight"><pre>{-# LANGUAGE TypeInType #-}
data Proxy a = P   -- inferred kind: Proxy :: k -&gt; *
data Compose f g x = MkCompose (f (g x))
  -- inferred kind: Compose :: (b -&gt; *) -&gt; (a -&gt; b) -&gt; a -&gt; *

-- separate module having imported the first
{-# LANGUAGE NoPolyKinds, DataKinds #-}
z = Proxy :: Proxy &#39;MkCompose
</pre></div>
</div>
<p>In the last line, we use the promoted constructor <code class="docutils literal"><span class="pre">'MkCompose</span></code>, which has
kind</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">forall</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">g</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span>
  <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Compose</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span>
</pre></div>
</div>
<p>Now we must infer a type for <code class="docutils literal"><span class="pre">z</span></code>. To do so without generalising over kind
variables, we must default the kind variables of <code class="docutils literal"><span class="pre">'MkCompose</span></code>. We can
easily default <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> to <code class="docutils literal"><span class="pre">*</span></code>, but <code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">g</span></code> would be ill-kinded
if defaulted. The definition for <code class="docutils literal"><span class="pre">z</span></code> is thus an error.</p>
</div>
<div class="section" id="pretty-printing-in-the-presence-of-kind-polymorphism">
<h2>10.11.15. Pretty-printing in the presence of kind polymorphism<a class="headerlink" href="#pretty-printing-in-the-presence-of-kind-polymorphism" title="Permalink to this headline">¶</a></h2>
<p>With kind polymorphism, there is quite a bit going on behind the scenes that
may be invisible to a Haskell programmer. GHC supports several flags that
control how types are printed in error messages and at the GHCi prompt.
See the <a class="reference internal" href="using.html#pretty-printing-types"><span>discussion of type pretty-printing options</span></a>
for further details. If you are using kind polymorphism and are confused as to
why GHC is rejecting (or accepting) your program, we encourage you to turn on
these flags, especially <a class="reference internal" href="using.html#ghc-flag--fprint-explicit-kinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fprint-explicit-kinds</span></code></a>.</p>
</div>
</div>
<div class="section" id="levity-polymorphism">
<span id="runtime-rep"></span><span id="index-16"></span><h1>10.12. Levity polymorphism<a class="headerlink" href="#levity-polymorphism" title="Permalink to this headline">¶</a></h1>
<p>In order to allow full flexibility in how kinds are used, it is necessary
to use the kind system to differentiate between boxed, lifted types
(normal, everyday types like <code class="docutils literal"><span class="pre">Int</span></code> and <code class="docutils literal"><span class="pre">[Bool]</span></code>) and unboxed, primitive
types (<a class="reference internal" href="#primitives"><span>Unboxed types and primitive operations</span></a>) like <code class="docutils literal"><span class="pre">Int#</span></code>. We thus have so-called levity
polymorphism.</p>
<p>Here are the key definitions, all available from <code class="docutils literal"><span class="pre">GHC.Exts</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">TYPE</span> <span class="ow">::</span> <span class="kt">RuntimeRep</span> <span class="ow">-&gt;</span> <span class="o">*</span>   <span class="c1">-- highly magical, built into GHC</span>

<span class="kr">data</span> <span class="kt">RuntimeRep</span> <span class="ow">=</span> <span class="kt">LiftedRep</span>     <span class="c1">-- for things like `Int`</span>
                <span class="o">|</span> <span class="kt">UnliftedRep</span>   <span class="c1">-- for things like `Array#`</span>
                <span class="o">|</span> <span class="kt">IntRep</span>        <span class="c1">-- for `Int#`</span>
                <span class="o">|</span> <span class="kt">TupleRep</span> <span class="p">[</span><span class="kt">RuntimeRep</span><span class="p">]</span>  <span class="c1">-- unboxed tuples, indexed by the representations of the elements</span>
                <span class="o">|</span> <span class="kt">SumRep</span> <span class="p">[</span><span class="kt">RuntimeRep</span><span class="p">]</span>    <span class="c1">-- unboxed sums, indexed by the representations of the disjuncts</span>
                <span class="o">|</span> <span class="o">...</span>

<span class="kr">type</span> <span class="o">*</span> <span class="ow">=</span> <span class="kt">TYPE</span> <span class="kt">LiftedRep</span>    <span class="c1">-- * is just an ordinary type synonym</span>
</pre></div>
</div>
<p>The idea is that we have a new fundamental type constant <code class="docutils literal"><span class="pre">TYPE</span></code>, which
is parameterised by a <code class="docutils literal"><span class="pre">RuntimeRep</span></code>. We thus get <code class="docutils literal"><span class="pre">Int#</span> <span class="pre">::</span> <span class="pre">TYPE</span> <span class="pre">'IntRep</span></code>
and <code class="docutils literal"><span class="pre">Bool</span> <span class="pre">::</span> <span class="pre">TYPE</span> <span class="pre">'LiftedRep</span></code>. Anything with a type of the form
<code class="docutils literal"><span class="pre">TYPE</span> <span class="pre">x</span></code> can appear to either side of a function arrow <code class="docutils literal"><span class="pre">-&gt;</span></code>. We can
thus say that <code class="docutils literal"><span class="pre">-&gt;</span></code> has type
<code class="docutils literal"><span class="pre">TYPE</span> <span class="pre">r1</span> <span class="pre">-&gt;</span> <span class="pre">TYPE</span> <span class="pre">r2</span> <span class="pre">-&gt;</span> <span class="pre">TYPE</span> <span class="pre">'LiftedRep</span></code>. The result is always lifted
because all functions are lifted in GHC.</p>
<div class="section" id="no-levity-polymorphic-variables-or-arguments">
<h2>10.12.1. No levity-polymorphic variables or arguments<a class="headerlink" href="#no-levity-polymorphic-variables-or-arguments" title="Permalink to this headline">¶</a></h2>
<p>If GHC didn&#8217;t have to compile programs that run in the real world, that
would be the end of the story. But representation polymorphism can cause
quite a bit of trouble for GHC&#8217;s code generator. Consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bad</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">r1</span> <span class="ow">::</span> <span class="kt">RuntimeRep</span><span class="p">)</span> <span class="p">(</span><span class="n">r2</span> <span class="ow">::</span> <span class="kt">RuntimeRep</span><span class="p">)</span>
              <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="kt">TYPE</span> <span class="n">r1</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="ow">::</span> <span class="kt">TYPE</span> <span class="n">r2</span><span class="p">)</span><span class="o">.</span>
       <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">bad</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
<p>This seems like a generalisation of the standard <code class="docutils literal"><span class="pre">$</span></code> operator. If we
think about compiling this to runnable code, though, problems appear.
In particular, when we call <code class="docutils literal"><span class="pre">bad</span></code>, we must somehow pass <code class="docutils literal"><span class="pre">x</span></code> into
<code class="docutils literal"><span class="pre">bad</span></code>. How wide (that is, how many bits) is <code class="docutils literal"><span class="pre">x</span></code>? Is it a pointer?
What kind of register (floating-point or integral) should <code class="docutils literal"><span class="pre">x</span></code> go in?
It&#8217;s all impossible to say, because <code class="docutils literal"><span class="pre">x</span></code>&#8216;s type, <code class="docutils literal"><span class="pre">a</span> <span class="pre">::</span> <span class="pre">TYPE</span> <span class="pre">r1</span></code> is
levity polymorphic. We thus forbid such constructions, via the
following straightforward rule:</p>
<blockquote>
<div>No variable may have a levity-polymorphic type.</div></blockquote>
<p>This eliminates <code class="docutils literal"><span class="pre">bad</span></code> because the variable <code class="docutils literal"><span class="pre">x</span></code> would have a
representation-polymorphic type.</p>
<p>However, not all is lost. We can still do this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">r</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="ow">::</span> <span class="kt">TYPE</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span>
       <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">f</span> <span class="o">$</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
<p>Here, only <code class="docutils literal"><span class="pre">b</span></code> is levity polymorphic. There are no variables
with a levity-polymorphic type. And the code generator has no
trouble with this. Indeed, this is the true type of GHC&#8217;s <code class="docutils literal"><span class="pre">$</span></code> operator,
slightly more general than the Haskell 98 version.</p>
<p>Because the code generator must store and move arguments as well
as variables, the logic above applies equally well to function arguments,
which may not be levity-polymorphic.</p>
</div>
<div class="section" id="levity-polymorphic-bottoms">
<h2>10.12.2. Levity-polymorphic bottoms<a class="headerlink" href="#levity-polymorphic-bottoms" title="Permalink to this headline">¶</a></h2>
<p>We can use levity polymorphism to good effect with <code class="docutils literal"><span class="pre">error</span></code>
and <code class="docutils literal"><span class="pre">undefined</span></code>, whose types are given here:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">undefined</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">r</span> <span class="ow">::</span> <span class="kt">RuntimeRep</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="kt">TYPE</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span>
             <span class="kt">HasCallStack</span> <span class="ow">=&gt;</span> <span class="n">a</span>
<span class="ne">error</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">r</span> <span class="ow">::</span> <span class="kt">RuntimeRep</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="kt">TYPE</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span>
         <span class="kt">HasCallStack</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>These functions do not bind a levity-polymorphic variable, and
so are accepted. Their polymorphism allows users to use these to conveniently
stub out functions that return unboxed types.</p>
</div>
<div class="section" id="printing-levity-polymorphic-types">
<h2>10.12.3. Printing levity-polymorphic types<a class="headerlink" href="#printing-levity-polymorphic-types" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--Wprint-explicit-runtime-rep">
<code class="descname">-Wprint-explicit-runtime-rep</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--Wprint-explicit-runtime-rep" title="Permalink to this definition">¶</a></dt>
<dd><p>Print <code class="docutils literal"><span class="pre">RuntimeRep</span></code> parameters as they appear; otherwise, they are
defaulted to <code class="docutils literal"><span class="pre">'LiftedRep</span></code>.</p>
</dd></dl>

<p>Most GHC users will not need to worry about levity polymorphism
or unboxed types. For these users, seeing the levity polymorphism
in the type of <code class="docutils literal"><span class="pre">$</span></code> is unhelpful. And thus, by default, it is suppressed,
by supposing all type variables of type <code class="docutils literal"><span class="pre">RuntimeRep</span></code> to be <code class="docutils literal"><span class="pre">'LiftedRep</span></code>
when printing, and printing <code class="docutils literal"><span class="pre">TYPE</span> <span class="pre">'LiftedRep</span></code> as <code class="docutils literal"><span class="pre">*</span></code>.</p>
<p>Should you wish to see levity polymorphism in your types, enable
the flag <a class="reference internal" href="using.html#ghc-flag--fprint-explicit-runtime-reps"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fprint-explicit-runtime-reps</span></code></a>.</p>
</div>
</div>
<div class="section" id="type-level-literals">
<span id="id45"></span><h1>10.13. Type-Level Literals<a class="headerlink" href="#type-level-literals" title="Permalink to this headline">¶</a></h1>
<p>GHC supports numeric and string literals at the type level, giving
convenient access to a large number of predefined type-level constants.
Numeric literals are of kind <code class="docutils literal"><span class="pre">Nat</span></code>, while string literals are of kind
<code class="docutils literal"><span class="pre">Symbol</span></code>. This feature is enabled by the <a class="reference internal" href="#ghc-flag--XDataKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDataKinds</span></code></a> language
extension.</p>
<p>The kinds of the literals and all other low-level operations for this
feature are defined in module <code class="docutils literal"><span class="pre">GHC.TypeLits</span></code>. Note that the module
defines some type-level operators that clash with their value-level
counterparts (e.g. <code class="docutils literal"><span class="pre">(+)</span></code>). Import and export declarations referring to
these operators require an explicit namespace annotation (see
<a class="reference internal" href="#explicit-namespaces"><span>Explicit namespaces in import/export</span></a>).</p>
<p>Here is an example of using type-level numeric literals to provide a
safe interface to a low-level function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">GHC.TypeLits</span>
<span class="kr">import</span> <span class="nn">Data.Word</span>
<span class="kr">import</span> <span class="nn">Foreign</span>

<span class="kr">newtype</span> <span class="kt">ArrPtr</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ArrPtr</span> <span class="p">(</span><span class="kt">Ptr</span> <span class="n">a</span><span class="p">)</span>

<span class="nf">clearPage</span> <span class="ow">::</span> <span class="kt">ArrPtr</span> <span class="mi">4096</span> <span class="kt">Word8</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">clearPage</span> <span class="p">(</span><span class="kt">ArrPtr</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Here is an example of using type-level string literals to simulate
simple record operations:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Label</span> <span class="p">(</span><span class="n">l</span> <span class="ow">::</span> <span class="kt">Symbol</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Get</span>

<span class="kr">class</span> <span class="kt">Has</span> <span class="n">a</span> <span class="n">l</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="n">l</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="n">from</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Label</span> <span class="n">l</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">instance</span> <span class="kt">Has</span> <span class="kt">Point</span> <span class="s">&quot;x&quot;</span> <span class="kt">Int</span> <span class="kr">where</span> <span class="n">from</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="kr">_</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">x</span>
<span class="kr">instance</span> <span class="kt">Has</span> <span class="kt">Point</span> <span class="s">&quot;y&quot;</span> <span class="kt">Int</span> <span class="kr">where</span> <span class="n">from</span> <span class="p">(</span><span class="kt">Point</span> <span class="kr">_</span> <span class="n">y</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">y</span>

<span class="nf">example</span> <span class="ow">=</span> <span class="n">from</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Get</span> <span class="ow">::</span> <span class="kt">Label</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="runtime-values-for-type-level-literals">
<span id="typelit-runtime"></span><h2>10.13.1. Runtime Values for Type-Level Literals<a class="headerlink" href="#runtime-values-for-type-level-literals" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it is useful to access the value-level literal associated with
a type-level literal. This is done with the functions <code class="docutils literal"><span class="pre">natVal</span></code> and
<code class="docutils literal"><span class="pre">symbolVal</span></code>. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">GHC</span><span class="o">.</span><span class="kt">TypeLits</span><span class="o">&gt;</span> <span class="n">natVal</span> <span class="p">(</span><span class="kt">Proxy</span> <span class="ow">::</span> <span class="kt">Proxy</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
</pre></div>
</div>
<p>These functions are overloaded because they need to return a different
result, depending on the type at which they are instantiated.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">natVal</span> <span class="ow">::</span> <span class="kt">KnownNat</span> <span class="n">n</span> <span class="ow">=&gt;</span> <span class="n">proxy</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>

<span class="c1">-- instance KnownNat 0</span>
<span class="c1">-- instance KnownNat 1</span>
<span class="c1">-- instance KnownNat 2</span>
<span class="c1">-- ...</span>
</pre></div>
</div>
<p>GHC discharges the constraint as soon as it knows what concrete
type-level literal is being used in the program. Note that this works
only for <em>literals</em> and not arbitrary type expressions. For example, a
constraint of the form <code class="docutils literal"><span class="pre">KnownNat</span> <span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span></code> will <em>not</em> be simplified to
<code class="docutils literal"><span class="pre">(KnownNat</span> <span class="pre">a,</span> <span class="pre">KnownNat</span> <span class="pre">b)</span></code>; instead, GHC will keep the constraint as
is, until it can simplify <code class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> to a constant value.</p>
<p>It is also possible to convert a run-time integer or string value to the
corresponding type-level literal. Of course, the resulting type literal
will be unknown at compile-time, so it is hidden in an existential type.
The conversion may be performed using <code class="docutils literal"><span class="pre">someNatVal</span></code> for integers and
<code class="docutils literal"><span class="pre">someSymbolVal</span></code> for strings:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">someNatVal</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">SomeNat</span>
<span class="kt">SomeNat</span>    <span class="ow">::</span> <span class="kt">KnownNat</span> <span class="n">n</span> <span class="ow">=&gt;</span> <span class="kt">Proxy</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">SomeNat</span>
</pre></div>
</div>
<p>The operations on strings are similar.</p>
</div>
<div class="section" id="computing-with-type-level-naturals">
<span id="typelit-tyfuns"></span><h2>10.13.2. Computing With Type-Level Naturals<a class="headerlink" href="#computing-with-type-level-naturals" title="Permalink to this headline">¶</a></h2>
<p>GHC 7.8 can evaluate arithmetic expressions involving type-level natural
numbers. Such expressions may be constructed using the type-families
<code class="docutils literal"><span class="pre">(+),</span> <span class="pre">(*),</span> <span class="pre">(^)</span></code> for addition, multiplication, and exponentiation.
Numbers may be compared using <code class="docutils literal"><span class="pre">(&lt;=?)</span></code>, which returns a promoted
boolean value, or <code class="docutils literal"><span class="pre">(&lt;=)</span></code>, which compares numbers as a constraint. For
example:</p>
<div class="highlight-none"><div class="highlight"><pre>GHC.TypeLits&gt; natVal (Proxy :: Proxy (2 + 3))
5
</pre></div>
</div>
<p>At present, GHC is quite limited in its reasoning about arithmetic: it
will only evaluate the arithmetic type functions and compare the
results&#8212; in the same way that it does for any other type function. In
particular, it does not know more general facts about arithmetic, such
as the commutativity and associativity of <code class="docutils literal"><span class="pre">(+)</span></code>, for example.</p>
<p>However, it is possible to perform a bit of &#8220;backwards&#8221; evaluation. For
example, here is how we could get GHC to compute arbitrary logarithms at
the type level:</p>
<div class="highlight-none"><div class="highlight"><pre>lg :: Proxy base -&gt; Proxy (base ^ pow) -&gt; Proxy pow
lg _ _ = Proxy

GHC.TypeLits&gt; natVal (lg (Proxy :: Proxy 2) (Proxy :: Proxy 8))
3
</pre></div>
</div>
</div>
</div>
<div class="section" id="constraints-in-types">
<h1>10.14. Constraints in types<a class="headerlink" href="#constraints-in-types" title="Permalink to this headline">¶</a></h1>
<div class="section" id="equality-constraints">
<span id="id46"></span><h2>10.14.1. Equality constraints<a class="headerlink" href="#equality-constraints" title="Permalink to this headline">¶</a></h2>
<p>A type context can include equality constraints of the form <code class="docutils literal"><span class="pre">t1</span> <span class="pre">~</span> <span class="pre">t2</span></code>,
which denote that the types <code class="docutils literal"><span class="pre">t1</span></code> and <code class="docutils literal"><span class="pre">t2</span></code> need to be the same. In
the presence of type families, whether two types are equal cannot
generally be decided locally. Hence, the contexts of function signatures
may include equality constraints, as in the following example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">sumCollects</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Collects</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">Collects</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">Elem</span> <span class="n">c1</span> <span class="o">~</span> <span class="kt">Elem</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">c1</span> <span class="ow">-&gt;</span> <span class="n">c2</span> <span class="ow">-&gt;</span> <span class="n">c2</span>
</pre></div>
</div>
<p>where we require that the element type of <code class="docutils literal"><span class="pre">c1</span></code> and <code class="docutils literal"><span class="pre">c2</span></code> are the
same. In general, the types <code class="docutils literal"><span class="pre">t1</span></code> and <code class="docutils literal"><span class="pre">t2</span></code> of an equality constraint
may be arbitrary monotypes; i.e., they may not contain any quantifiers,
independent of whether higher-rank types are otherwise enabled.</p>
<p>Equality constraints can also appear in class and instance contexts. The
former enable a simple translation of programs using functional
dependencies into programs using family synonyms instead. The general
idea is to rewrite a class declaration of the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>to</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="p">(</span><span class="kt">F</span> <span class="n">a</span> <span class="o">~</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">F</span> <span class="n">a</span>
</pre></div>
</div>
<p>That is, we represent every functional dependency (FD) <code class="docutils literal"><span class="pre">a1</span> <span class="pre">..</span> <span class="pre">an</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>
by an FD type family <code class="docutils literal"><span class="pre">F</span> <span class="pre">a1</span> <span class="pre">..</span> <span class="pre">an</span></code> and a superclass context equality
<code class="docutils literal"><span class="pre">F</span> <span class="pre">a1</span> <span class="pre">..</span> <span class="pre">an</span> <span class="pre">~</span> <span class="pre">b</span></code>, essentially giving a name to the functional
dependency. In class instances, we define the type instances of FD
families in accordance with the class head. Method signatures are not
affected by that process.</p>
</div>
<div class="section" id="heterogeneous-equality">
<span id="index-17"></span><h2>10.14.2. Heterogeneous equality<a class="headerlink" href="#heterogeneous-equality" title="Permalink to this headline">¶</a></h2>
<p>GHC also supports <em>kind-heterogeneous</em> equality, which relates two types of
potentially different kinds. Heterogeneous equality is spelled <code class="docutils literal"><span class="pre">~~</span></code>. Here
are the kinds of <code class="docutils literal"><span class="pre">~</span></code> and <code class="docutils literal"><span class="pre">~~</span></code> to better understand their difference:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">~</span><span class="p">)</span>  <span class="ow">::</span> <span class="n">forall</span> <span class="n">k</span><span class="o">.</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="p">(</span><span class="o">~~</span><span class="p">)</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">k1</span> <span class="n">k2</span><span class="o">.</span> <span class="n">k1</span> <span class="ow">-&gt;</span> <span class="n">k2</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
</pre></div>
</div>
<p>Users will most likely want <code class="docutils literal"><span class="pre">~</span></code>, but <code class="docutils literal"><span class="pre">~~</span></code> is available if GHC cannot know,
a priori, that the two types of interest have the same kind. Evidence that
<code class="docutils literal"><span class="pre">(a</span> <span class="pre">::</span> <span class="pre">k1)</span> <span class="pre">~~</span> <span class="pre">(b</span> <span class="pre">::</span> <span class="pre">k2)</span></code> tells GHC both that <code class="docutils literal"><span class="pre">k1</span></code> and <code class="docutils literal"><span class="pre">k2</span></code> are the same
and that <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> are the same.</p>
<p>Because <code class="docutils literal"><span class="pre">~</span></code> is the more common equality relation, GHC prints out <code class="docutils literal"><span class="pre">~~</span></code> like
<code class="docutils literal"><span class="pre">~</span></code> unless <a class="reference internal" href="using.html#ghc-flag--fprint-equality-relations"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fprint-equality-relations</span></code></a> is set.</p>
</div>
<div class="section" id="unlifted-heterogeneous-equality">
<h2>10.14.3. Unlifted heterogeneous equality<a class="headerlink" href="#unlifted-heterogeneous-equality" title="Permalink to this headline">¶</a></h2>
<p>Internal to GHC is yet a third equality relation <code class="docutils literal"><span class="pre">(~#)</span></code>. It is heterogeneous
(like <code class="docutils literal"><span class="pre">~~</span></code>) and is used only internally. It may appear in error messages
and other output only when <a class="reference internal" href="using.html#ghc-flag--fprint-equality-relations"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fprint-equality-relations</span></code></a> is enabled.</p>
</div>
<div class="section" id="the-coercible-constraint">
<span id="coercible"></span><h2>10.14.4. The <code class="docutils literal"><span class="pre">Coercible</span></code> constraint<a class="headerlink" href="#the-coercible-constraint" title="Permalink to this headline">¶</a></h2>
<p>The constraint <code class="docutils literal"><span class="pre">Coercible</span> <span class="pre">t1</span> <span class="pre">t2</span></code> is similar to <code class="docutils literal"><span class="pre">t1</span> <span class="pre">~</span> <span class="pre">t2</span></code>, but
denotes representational equality between <code class="docutils literal"><span class="pre">t1</span></code> and <code class="docutils literal"><span class="pre">t2</span></code> in the sense
of Roles (<a class="reference internal" href="#roles"><span>Roles</span></a>). It is exported by
<a class="reference external" href="../libraries/base-4.10.1.0/Data-Coerce.html">Data.Coerce</a>, which also
contains the documentation. More details and discussion can be found in
the paper
<a class="reference external" href="http://www.cis.upenn.edu/~eir/papers/2014/coercible/coercible.pdf">&#8220;Safe Coercions&#8221;</a>.</p>
</div>
<div class="section" id="the-constraint-kind">
<span id="constraint-kind"></span><h2>10.14.5. The <code class="docutils literal"><span class="pre">Constraint</span></code> kind<a class="headerlink" href="#the-constraint-kind" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XConstraintKinds">
<code class="descname">-XConstraintKinds</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XConstraintKinds" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.4.1</td>
</tr>
</tbody>
</table>
<p>Allow types of kind <code class="docutils literal"><span class="pre">Constraint</span></code> to be used in contexts.</p>
</dd></dl>

<p>Normally, <em>constraints</em> (which appear in types to the left of the <code class="docutils literal"><span class="pre">=&gt;</span></code>
arrow) have a very restricted syntax. They can only be:</p>
<ul class="simple">
<li>Class constraints, e.g. <code class="docutils literal"><span class="pre">Show</span> <span class="pre">a</span></code></li>
<li><a class="reference internal" href="#ghc-flag--XImplicitParams"><code class="xref std std-ghc-flag docutils literal"><span class="pre">Implicit</span> <span class="pre">parameter</span></code></a> constraints, e.g.
<code class="docutils literal"><span class="pre">?x::Int</span></code> (with the <a class="reference internal" href="#ghc-flag--XImplicitParams"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XImplicitParams</span></code></a> flag)</li>
<li><a class="reference internal" href="#equality-constraints"><span>Equality constraints</span></a>, e.g. <code class="docutils literal"><span class="pre">a</span> <span class="pre">~</span> <span class="pre">Int</span></code>
(with the <a class="reference internal" href="#ghc-flag--XTypeFamilies"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeFamilies</span></code></a> or <a class="reference internal" href="#ghc-flag--XGADTs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGADTs</span></code></a> flag)</li>
</ul>
<p>With the <a class="reference internal" href="#ghc-flag--XConstraintKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XConstraintKinds</span></code></a> flag, GHC becomes more liberal in what it
accepts as constraints in your program. To be precise, with this flag
any <em>type</em> of the new kind <code class="docutils literal"><span class="pre">Constraint</span></code> can be used as a constraint.
The following things have kind <code class="docutils literal"><span class="pre">Constraint</span></code>:</p>
<ul>
<li><p class="first">Anything which is already valid as a constraint without the flag:
saturated applications to type classes, implicit parameter and
equality constraints.</p>
</li>
<li><p class="first">Tuples, all of whose component types have kind <code class="docutils literal"><span class="pre">Constraint</span></code>. So for example
the type <code class="docutils literal"><span class="pre">(Show</span> <span class="pre">a,</span> <span class="pre">Ord</span> <span class="pre">a)</span></code> is of kind <code class="docutils literal"><span class="pre">Constraint</span></code>.</p>
</li>
<li><p class="first">Anything whose form is not yet known, but the user has declared to
have kind <code class="docutils literal"><span class="pre">Constraint</span></code> (for which they need to import it from
<code class="docutils literal"><span class="pre">GHC.Exts</span></code>). So for example
<code class="docutils literal"><span class="pre">type</span> <span class="pre">Foo</span> <span class="pre">(f</span> <span class="pre">::</span> <span class="pre">\*</span> <span class="pre">-&gt;</span> <span class="pre">Constraint)</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">b.</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">=&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>
is allowed, as well as examples involving type families:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">Typ</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">::</span> <span class="kt">Constraint</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Typ</span> <span class="kt">Int</span>  <span class="n">b</span> <span class="ow">=</span> <span class="kt">Show</span> <span class="n">b</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Typ</span> <span class="kt">Bool</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Num</span> <span class="n">b</span>

<span class="nf">func</span> <span class="ow">::</span> <span class="kt">Typ</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">func</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<p>Note that because constraints are just handled as types of a particular
kind, this extension allows type constraint synonyms:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Stringy</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Stringy</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">show</span> <span class="n">x</span><span class="p">,</span> <span class="n">read</span><span class="p">)</span>
</pre></div>
</div>
<p>Presently, only standard constraints, tuples and type synonyms for those
two sorts of constraint are permitted in instance contexts and
superclasses (without extra flags). The reason is that permitting more
general constraints can cause type checking to loop, as it would with
these two programs:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">Clsish</span> <span class="n">u</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Clsish</span> <span class="nb">()</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Cls</span> <span class="n">a</span>
<span class="kr">class</span> <span class="kt">Clsish</span> <span class="nb">()</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Cls</span> <span class="n">a</span> <span class="kr">where</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">OkCls</span> <span class="n">a</span> <span class="kr">where</span>

<span class="kr">type</span> <span class="n">family</span> <span class="kt">OkClsish</span> <span class="n">u</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">OkClsish</span> <span class="nb">()</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">OkCls</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">OkClsish</span> <span class="nb">()</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">OkCls</span> <span class="n">a</span> <span class="kr">where</span>
</pre></div>
</div>
<p>You may write programs that use exotic sorts of constraints in instance
contexts and superclasses, but to do so you must use
<a class="reference internal" href="#ghc-flag--XUndecidableInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XUndecidableInstances</span></code></a> to signal that you don&#8217;t mind if the type
checker fails to terminate.</p>
</div>
</div>
<div class="section" id="extensions-to-type-signatures">
<span id="id47"></span><h1>10.15. Extensions to type signatures<a class="headerlink" href="#extensions-to-type-signatures" title="Permalink to this headline">¶</a></h1>
<div class="section" id="explicit-universal-quantification-forall">
<span id="explicit-foralls"></span><h2>10.15.1. Explicit universal quantification (forall)<a class="headerlink" href="#explicit-universal-quantification-forall" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XExplicitForAll">
<code class="descname">-XExplicitForAll</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XExplicitForAll" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">6.12</td>
</tr>
</tbody>
</table>
<p>Allow use of the <code class="docutils literal"><span class="pre">forall</span></code> keyword in places where universal quantification
is implicit.</p>
</dd></dl>

<p>Haskell type signatures are implicitly quantified. When the language
option <a class="reference internal" href="#ghc-flag--XExplicitForAll"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitForAll</span></code></a> is used, the keyword <code class="docutils literal"><span class="pre">forall</span></code> allows us to
say exactly what this means. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">g</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>means this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">g</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The two are treated identically, except that the latter may bring type variables
into scope (see <a class="reference internal" href="#scoped-type-variables"><span>Lexically scoped type variables</span></a>).</p>
<p>Notes:</p>
<ul>
<li><p class="first">With <a class="reference internal" href="#ghc-flag--XExplicitForAll"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitForAll</span></code></a>, <code class="docutils literal"><span class="pre">forall</span></code> becomes a keyword; you can&#8217;t use <code class="docutils literal"><span class="pre">forall</span></code> as a
type variable any more!</p>
</li>
<li><p class="first">As well in type signatures, you can also use an explicit <code class="docutils literal"><span class="pre">forall</span></code>
in an instance declaration:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first">If the <a class="reference internal" href="using-warnings.html#ghc-flag--Wunused-foralls"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wunused-foralls</span></code></a> flag is enabled, a warning will be emitted
when you write a type variable in an explicit <code class="docutils literal"><span class="pre">forall</span></code> statement that is
otherwise unused. For instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">g</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>would warn about the unused type variable <cite>a</cite>.</p>
</li>
</ul>
</div>
<div class="section" id="the-context-of-a-type-signature">
<span id="flexible-contexts"></span><h2>10.15.2. The context of a type signature<a class="headerlink" href="#the-context-of-a-type-signature" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#ghc-flag--XFlexibleContexts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleContexts</span></code></a> flag lifts the Haskell 98 restriction that
the type-class constraints in a type signature must have the form <em>(class
type-variable)</em> or <em>(class (type-variable type1 type2 ... typen))</em>. With
<a class="reference internal" href="#ghc-flag--XFlexibleContexts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleContexts</span></code></a> these type signatures are perfectly okay</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">g</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">=&gt;</span> <span class="o">...</span>
<span class="nf">g</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a</span> <span class="nb">()</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="o">...</span>
</pre></div>
</div>
<p>The flag <a class="reference internal" href="#ghc-flag--XFlexibleContexts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XFlexibleContexts</span></code></a> also lifts the corresponding restriction
on class declarations (<a class="reference internal" href="#superclass-rules"><span>The superclasses of a class declaration</span></a>) and instance
declarations (<a class="reference internal" href="#instance-rules"><span>Relaxed rules for instance contexts</span></a>).</p>
</div>
<div class="section" id="ambiguous-types-and-the-ambiguity-check">
<span id="ambiguity"></span><h2>10.15.3. Ambiguous types and the ambiguity check<a class="headerlink" href="#ambiguous-types-and-the-ambiguity-check" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XAllowAmbiguousTypes">
<code class="descname">-XAllowAmbiguousTypes</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XAllowAmbiguousTypes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.8.1</td>
</tr>
</tbody>
</table>
<p>Allow type signatures which appear that they would result in
an unusable binding.</p>
</dd></dl>

<p>Each user-written type signature is subjected to an <em>ambiguity check</em>.
The ambiguity check rejects functions that can never be called; for
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>The idea is there can be no legal calls to <code class="docutils literal"><span class="pre">f</span></code> because every call will
give rise to an ambiguous constraint. Indeed, the <em>only</em> purpose of the
ambiguity check is to report functions that cannot possibly be called.
We could soundly omit the ambiguity check on type signatures entirely,
at the expense of delaying ambiguity errors to call sites. Indeed, the
language extension <a class="reference internal" href="#ghc-flag--XAllowAmbiguousTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XAllowAmbiguousTypes</span></code></a> switches off the ambiguity
check.</p>
<p>Ambiguity can be subtle. Consider this example which uses functional
dependencies:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">D</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span> <span class="o">..</span>
<span class="nf">h</span> <span class="ow">::</span> <span class="kt">D</span> <span class="kt">Int</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">Int</span></code> may well fix <code class="docutils literal"><span class="pre">b</span></code> at the call site, so that signature
should not be rejected. Moreover, the dependencies might be hidden.
Consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">X</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">class</span> <span class="kt">D</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="kt">D</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">X</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="n">b</span> <span class="kr">where</span><span class="o">...</span>
<span class="nf">h</span> <span class="ow">::</span> <span class="kt">X</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">h</span></code>&#8216;s type looks ambiguous in <code class="docutils literal"><span class="pre">b</span></code>, but here&#8217;s a legal call:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">...</span><span class="p">(</span><span class="n">h</span> <span class="p">[</span><span class="kt">True</span><span class="p">])</span><span class="o">...</span>
</pre></div>
</div>
<p>That gives rise to a <code class="docutils literal"><span class="pre">(X</span> <span class="pre">[Bool]</span> <span class="pre">beta)</span></code> constraint, and using the
instance means we need <code class="docutils literal"><span class="pre">(D</span> <span class="pre">Bool</span> <span class="pre">beta)</span></code> and that fixes <code class="docutils literal"><span class="pre">beta</span></code> via
<code class="docutils literal"><span class="pre">D</span></code>&#8216;s fundep!</p>
<p>Behind all these special cases there is a simple guiding principle.
Consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kr">type</span>
<span class="nf">f</span> <span class="ow">=</span> <span class="o">...</span><span class="n">blah</span><span class="o">...</span>

<span class="nf">g</span> <span class="ow">::</span> <span class="kr">type</span>
<span class="nf">g</span> <span class="ow">=</span> <span class="n">f</span>
</pre></div>
</div>
<p>You would think that the definition of <code class="docutils literal"><span class="pre">g</span></code> would surely typecheck!
After all <code class="docutils literal"><span class="pre">f</span></code> has exactly the same type, and <code class="docutils literal"><span class="pre">g=f</span></code>. But in fact
<code class="docutils literal"><span class="pre">f</span></code>&#8216;s type is instantiated and the instantiated constraints are solved
against the constraints bound by <code class="docutils literal"><span class="pre">g</span></code>&#8216;s signature. So, in the case an
ambiguous type, solving will fail. For example, consider the earlier
definition <code class="docutils literal"><span class="pre">f</span> <span class="pre">::</span> <span class="pre">C</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Int</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span>
<span class="nf">f</span> <span class="ow">=</span> <span class="o">...</span><span class="n">blah</span><span class="o">...</span>

<span class="nf">g</span> <span class="ow">::</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span>
<span class="nf">g</span> <span class="ow">=</span> <span class="n">f</span>
</pre></div>
</div>
<p>In <code class="docutils literal"><span class="pre">g</span></code>&#8216;s definition, we&#8217;ll instantiate to <code class="docutils literal"><span class="pre">(C</span> <span class="pre">alpha)</span></code> and try to
deduce <code class="docutils literal"><span class="pre">(C</span> <span class="pre">alpha)</span></code> from <code class="docutils literal"><span class="pre">(C</span> <span class="pre">a)</span></code>, and fail.</p>
<p>So in fact we use this as our <em>definition</em> of ambiguity: a type <code class="docutils literal"><span class="pre">ty</span></code>
is ambiguous if and only if <code class="docutils literal"><span class="pre">((undefined</span> <span class="pre">::</span> <span class="pre">ty)</span> <span class="pre">::</span> <span class="pre">ty)</span></code> would fail to
typecheck. We use a very similar test for <em>inferred</em> types, to ensure
that they too are unambiguous.</p>
<p><em>Switching off the ambiguity check.</em> Even if a function has an
ambiguous type according the &#8220;guiding principle&#8221;, it is possible that
the function is callable. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">D</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="kt">D</span> <span class="kt">Bool</span> <span class="n">b</span> <span class="kr">where</span> <span class="o">...</span>

<span class="nf">strange</span> <span class="ow">::</span> <span class="kt">D</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">strange</span> <span class="ow">=</span> <span class="o">...</span><span class="n">blah</span><span class="o">...</span>

<span class="nf">foo</span> <span class="ow">=</span> <span class="n">strange</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">strange</span></code>&#8216;s type is ambiguous, but the call in <code class="docutils literal"><span class="pre">foo</span></code> is OK
because it gives rise to a constraint <code class="docutils literal"><span class="pre">(D</span> <span class="pre">Bool</span> <span class="pre">beta)</span></code>, which is
soluble by the <code class="docutils literal"><span class="pre">(D</span> <span class="pre">Bool</span> <span class="pre">b)</span></code> instance.</p>
<p>Another way of getting rid of the ambiguity at the call site is to use
the <a class="reference internal" href="#ghc-flag--XTypeApplications"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeApplications</span></code></a> flag to specify the types. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">D</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="n">h</span> <span class="ow">::</span> <span class="n">b</span>
<span class="kr">instance</span> <span class="kt">D</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kr">where</span> <span class="o">...</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">h</span> <span class="o">@</span><span class="kt">Int</span> <span class="o">@</span><span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">a</span></code> is ambiguous in the definition of <code class="docutils literal"><span class="pre">D</span></code> but later specified
to be <cite>Int</cite> using type applications.</p>
<p><a class="reference internal" href="#ghc-flag--XAllowAmbiguousTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XAllowAmbiguousTypes</span></code></a> allows you to switch off the ambiguity check.
However, even with ambiguity checking switched off, GHC will complain about a
function that can <em>never</em> be called, such as this one:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">~</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><em>A historical note.</em> GHC used to impose some more restrictive and less
principled conditions on type signatures. For type
<code class="docutils literal"><span class="pre">forall</span> <span class="pre">tv1..tvn</span> <span class="pre">(c1,</span> <span class="pre">...,cn)</span> <span class="pre">=&gt;</span> <span class="pre">type</span></code> GHC used to require</p>
<blockquote class="last">
<div><ol class="loweralpha simple">
<li>that each universally quantified type variable <code class="docutils literal"><span class="pre">tvi</span></code> must be &#8220;reachable&#8221;
from <code class="docutils literal"><span class="pre">type</span></code>, and</li>
<li>that every constraint <code class="docutils literal"><span class="pre">ci</span></code> mentions at least one of the universally
quantified type variables <code class="docutils literal"><span class="pre">tvi</span></code>. These ad-hoc restrictions are
completely subsumed by the new ambiguity check.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="explicitly-kinded-quantification">
<span id="kinding"></span><h2>10.15.4. Explicitly-kinded quantification<a class="headerlink" href="#explicitly-kinded-quantification" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XKindSignatures">
<code class="descname">-XKindSignatures</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XKindSignatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow explicit kind signatures on type variables.</p>
</dd></dl>

<p>Haskell infers the kind of each type variable. Sometimes it is nice to
be able to give the kind explicitly as (machine-checked) documentation,
just as it is nice to give a type signature for a function. On some
occasions, it is essential to do so. For example, in his paper
&#8220;Restricted Data Types in Haskell&#8221; (Haskell Workshop 1999) John Hughes
had to define the data type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Set</span> <span class="n">cxt</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Set</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
               <span class="o">|</span> <span class="kt">Unused</span> <span class="p">(</span><span class="n">cxt</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span><span class="p">)</span>
</pre></div>
</div>
<p>The only use for the <code class="docutils literal"><span class="pre">Unused</span></code> constructor was to force the correct
kind for the type variable <code class="docutils literal"><span class="pre">cxt</span></code>.</p>
<p>GHC now instead allows you to specify the kind of a type variable
directly, wherever a type variable is explicitly bound, with the flag
<a class="reference internal" href="#ghc-flag--XKindSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XKindSignatures</span></code></a>.</p>
<p>This flag enables kind signatures in the following places:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">data</span></code> declarations:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Set</span> <span class="p">(</span><span class="n">cxt</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Set</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">type</span></code> declarations:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">T</span> <span class="p">(</span><span class="n">f</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="kt">Int</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">class</span></code> declarations:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="p">(</span><span class="n">f</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">forall</span></code>&#8216;s in type signatures:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">cxt</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span><span class="o">.</span> <span class="kt">Set</span> <span class="n">cxt</span> <span class="kt">Int</span>
</pre></div>
</div>
</li>
</ul>
<p>The parentheses are required. Some of the spaces are required too, to
separate the lexemes. If you write <code class="docutils literal"><span class="pre">(f::*-&gt;*)</span></code> you will get a parse
error, because <code class="docutils literal"><span class="pre">::*-&gt;*</span></code> is a single lexeme in Haskell.</p>
<p>As part of the same extension, you can put kind annotations in types as
well. Thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">g</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>The syntax is</p>
<div class="highlight-none"><div class="highlight"><pre>atype ::= &#39;(&#39; ctype &#39;::&#39; kind &#39;)
</pre></div>
</div>
<p>The parentheses are required.</p>
</div>
</div>
<div class="section" id="lexically-scoped-type-variables">
<span id="scoped-type-variables"></span><span id="universal-quantification"></span><h1>10.16. Lexically scoped type variables<a class="headerlink" href="#lexically-scoped-type-variables" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XScopedTypeVariables">
<code class="descname">-XScopedTypeVariables</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XScopedTypeVariables" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XExplicitForAll"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitForAll</span></code></a></td>
</tr>
</tbody>
</table>
<p>Enable lexical scoping of type variables explicitly introduced with
<code class="docutils literal"><span class="pre">forall</span></code>.</p>
</dd></dl>

<p>GHC supports <em>lexically scoped type variables</em>, without which some type
signatures are simply impossible to write. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">ys</span> <span class="o">++</span> <span class="n">ys</span>
     <span class="kr">where</span>
       <span class="n">ys</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
       <span class="n">ys</span> <span class="ow">=</span> <span class="n">reverse</span> <span class="n">xs</span>
</pre></div>
</div>
<p>The type signature for <code class="docutils literal"><span class="pre">f</span></code> brings the type variable <code class="docutils literal"><span class="pre">a</span></code> into scope,
because of the explicit <code class="docutils literal"><span class="pre">forall</span></code> (<a class="reference internal" href="#decl-type-sigs"><span>Declaration type signatures</span></a>). The type
variables bound by a <code class="docutils literal"><span class="pre">forall</span></code> scope over the entire definition of the
accompanying value declaration. In this example, the type variable <code class="docutils literal"><span class="pre">a</span></code>
scopes over the whole definition of <code class="docutils literal"><span class="pre">f</span></code>, including over the type
signature for <code class="docutils literal"><span class="pre">ys</span></code>. In Haskell 98 it is not possible to declare a type
for <code class="docutils literal"><span class="pre">ys</span></code>; a major benefit of scoped type variables is that it becomes
possible to do so.</p>
<div class="section" id="id48">
<h2>10.16.1. Overview<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h2>
<p>The design follows the following principles</p>
<ul class="simple">
<li>A scoped type variable stands for a type <em>variable</em>, and not for a
<em>type</em>. (This is a change from GHC&#8217;s earlier design.)</li>
<li>Furthermore, distinct lexical type variables stand for distinct type
variables. This means that every programmer-written type signature
(including one that contains free scoped type variables) denotes a
<em>rigid</em> type; that is, the type is fully known to the type checker,
and no inference is involved.</li>
<li>Lexical type variables may be alpha-renamed freely, without changing
the program.</li>
</ul>
<p>A <em>lexically scoped type variable</em> can be bound by:</p>
<ul class="simple">
<li>A declaration type signature (<a class="reference internal" href="#decl-type-sigs"><span>Declaration type signatures</span></a>)</li>
<li>An expression type signature (<a class="reference internal" href="#exp-type-sigs"><span>Expression type signatures</span></a>)</li>
<li>A pattern type signature (<a class="reference internal" href="#pattern-type-sigs"><span>Pattern type signatures</span></a>)</li>
<li>Class and instance declarations (<a class="reference internal" href="#cls-inst-scoped-tyvars"><span>Class and instance declarations</span></a>)</li>
</ul>
<p>In Haskell, a programmer-written type signature is implicitly quantified
over its free type variables (<a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.1.2">Section
4.1.2</a> of
the Haskell Report). Lexically scoped type variables affect this
implicit quantification rules as follows: any type variable that is in
scope is <em>not</em> universally quantified. For example, if type variable
<code class="docutils literal"><span class="pre">a</span></code> is in scope, then</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="n">e</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>     <span class="n">means</span>     <span class="p">(</span><span class="n">e</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">(</span><span class="n">e</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span>     <span class="n">means</span>     <span class="p">(</span><span class="n">e</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span>
<span class="p">(</span><span class="n">e</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span>     <span class="n">means</span>     <span class="p">(</span><span class="n">e</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="declaration-type-signatures">
<span id="decl-type-sigs"></span><h2>10.16.2. Declaration type signatures<a class="headerlink" href="#declaration-type-signatures" title="Permalink to this headline">¶</a></h2>
<p>A declaration type signature that has <em>explicit</em> quantification (using
<code class="docutils literal"><span class="pre">forall</span></code>) brings into scope the explicitly-quantified type variables,
in the definition of the named function. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span> <span class="n">x</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">]</span>
</pre></div>
</div>
<p>The &#8220;<code class="docutils literal"><span class="pre">forall</span> <span class="pre">a</span></code>&#8221; brings &#8220;<code class="docutils literal"><span class="pre">a</span></code>&#8221; into scope in the definition of
&#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221;.</p>
<p>This only happens if:</p>
<ul>
<li><p class="first">The quantification in <code class="docutils literal"><span class="pre">f</span></code>&#8216;s type signature is explicit. For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">g</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">g</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span> <span class="n">x</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">]</span>
</pre></div>
</div>
<p>This program will be rejected, because &#8220;<code class="docutils literal"><span class="pre">a</span></code>&#8221; does not scope over
the definition of &#8220;<code class="docutils literal"><span class="pre">g</span></code>&#8221;, so &#8220;<code class="docutils literal"><span class="pre">x::a</span></code>&#8221; means &#8220;<code class="docutils literal"><span class="pre">x::forall</span> <span class="pre">a.</span> <span class="pre">a</span></code>&#8221;
by Haskell&#8217;s usual implicit quantification rules.</p>
</li>
<li><p class="first">The signature gives a type for a function binding or a bare variable
binding, not a pattern binding. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f1</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">f1</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span> <span class="n">x</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">]</span>   <span class="c1">-- OK</span>

<span class="nf">f2</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">f2</span> <span class="ow">=</span> <span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span> <span class="n">x</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">]</span>   <span class="c1">-- OK</span>

<span class="nf">f3</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kt">Just</span> <span class="n">f3</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span> <span class="n">x</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">])</span>   <span class="c1">-- Not OK!</span>
</pre></div>
</div>
<p>The binding for <code class="docutils literal"><span class="pre">f3</span></code> is a pattern binding, and so its type
signature does not bring <code class="docutils literal"><span class="pre">a</span></code> into scope. However <code class="docutils literal"><span class="pre">f1</span></code> is a
function binding, and <code class="docutils literal"><span class="pre">f2</span></code> binds a bare variable; in both cases the
type signature brings <code class="docutils literal"><span class="pre">a</span></code> into scope.</p>
</li>
</ul>
</div>
<div class="section" id="expression-type-signatures">
<span id="exp-type-sigs"></span><h2>10.16.3. Expression type signatures<a class="headerlink" href="#expression-type-signatures" title="Permalink to this headline">¶</a></h2>
<p>An expression type signature that has <em>explicit</em> quantification (using
<code class="docutils literal"><span class="pre">forall</span></code>) brings into scope the explicitly-quantified type variables,
in the annotated expression. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">=</span> <span class="n">runST</span> <span class="p">(</span> <span class="p">(</span><span class="n">op</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="kt">STRef</span> <span class="n">s</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">s</span><span class="o">.</span> <span class="kt">ST</span> <span class="n">s</span> <span class="kt">Bool</span> <span class="p">)</span>
</pre></div>
</div>
<p>Here, the type signature <code class="docutils literal"><span class="pre">forall</span> <span class="pre">s.</span> <span class="pre">ST</span> <span class="pre">s</span> <span class="pre">Bool</span></code> brings the type
variable <code class="docutils literal"><span class="pre">s</span></code> into scope, in the annotated expression
<code class="docutils literal"><span class="pre">(op</span> <span class="pre">&gt;&gt;=</span> <span class="pre">\(x</span> <span class="pre">::</span> <span class="pre">STRef</span> <span class="pre">s</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">g</span> <span class="pre">x)</span></code>.</p>
</div>
<div class="section" id="pattern-type-signatures">
<span id="pattern-type-sigs"></span><h2>10.16.4. Pattern type signatures<a class="headerlink" href="#pattern-type-signatures" title="Permalink to this headline">¶</a></h2>
<p>A type signature may occur in any pattern; this is a <em>pattern type
signature</em>. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- f and g assume that &#39;a&#39; is already in scope</span>
<span class="nf">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="ow">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">y</span><span class="ow">::</span><span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">x</span>

<span class="nf">g</span> <span class="p">(</span><span class="n">x</span><span class="ow">::</span><span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>

<span class="nf">h</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Bool</span><span class="p">))</span> <span class="ow">=</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>In the case where all the type variables in the pattern type signature
are already in scope (i.e. bound by the enclosing context), matters are
simple: the signature simply constrains the type of the pattern in the
obvious way.</p>
<p>Unlike expression and declaration type signatures, pattern type
signatures are not implicitly generalised. The pattern in a <em>pattern
binding</em> may only mention type variables that are already in scope. For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>
<span class="nf">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">zs</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="p">(</span><span class="n">ys</span><span class="ow">::</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">xs</span><span class="p">,</span> <span class="n">length</span> <span class="n">xs</span><span class="p">)</span> <span class="c1">-- OK</span>
    <span class="n">zs</span><span class="ow">::</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">=</span> <span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span>                     <span class="c1">-- OK</span>

    <span class="kt">Just</span> <span class="p">(</span><span class="n">v</span><span class="ow">::</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="o">...</span>  <span class="c1">-- Not OK; b is not in scope</span>
</pre></div>
</div>
<p>Here, the pattern signatures for <code class="docutils literal"><span class="pre">ys</span></code> and <code class="docutils literal"><span class="pre">zs</span></code> are fine, but the one
for <code class="docutils literal"><span class="pre">v</span></code> is not because <code class="docutils literal"><span class="pre">b</span></code> is not in scope.</p>
<p>However, in all patterns <em>other</em> than pattern bindings, a pattern type
signature may mention a type variable that is not in scope; in this
case, <em>the signature brings that type variable into scope</em>. This is
particularly important for existential data constructors. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">MkT</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="nf">k</span> <span class="ow">::</span> <span class="kt">T</span> <span class="ow">-&gt;</span> <span class="kt">T</span>
<span class="nf">k</span> <span class="p">(</span><span class="kt">MkT</span> <span class="p">[</span><span class="n">t</span><span class="ow">::</span><span class="n">a</span><span class="p">])</span> <span class="ow">=</span>
    <span class="kt">MkT</span> <span class="n">t3</span>
  <span class="kr">where</span>
    <span class="n">t3</span><span class="ow">::</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">=</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">]</span>
</pre></div>
</div>
<p>Here, the pattern type signature <code class="docutils literal"><span class="pre">(t::a)</span></code> mentions a lexical type
variable that is not already in scope. Indeed, it <em>cannot</em> already be in
scope, because it is bound by the pattern match. GHC&#8217;s rule is that in
this situation (and only then), a pattern type signature can mention a
type variable that is not already in scope; the effect is to bring it
into scope, standing for the existentially-bound type variable.</p>
<p>When a pattern type signature binds a type variable in this way, GHC
insists that the type variable is bound to a <em>rigid</em>, or fully-known,
type variable. This means that any user-written type signature always
stands for a completely known type.</p>
<p>If all this seems a little odd, we think so too. But we must have <em>some</em>
way to bring such type variables into scope, else we could not name
existentially-bound type variables in subsequent type signatures.</p>
<p>This is (now) the <em>only</em> situation in which a pattern type signature is
allowed to mention a lexical variable that is not already in scope. For
example, both <code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">g</span></code> would be illegal if <code class="docutils literal"><span class="pre">a</span></code> was not already
in scope.</p>
</div>
<div class="section" id="class-and-instance-declarations">
<span id="cls-inst-scoped-tyvars"></span><h2>10.16.5. Class and instance declarations<a class="headerlink" href="#class-and-instance-declarations" title="Permalink to this headline">¶</a></h2>
<p>The type variables in the head of a <code class="docutils literal"><span class="pre">class</span></code> or <code class="docutils literal"><span class="pre">instance</span></code>
declaration scope over the methods defined in the <code class="docutils literal"><span class="pre">where</span></code> part. You do
not even need an explicit <code class="docutils literal"><span class="pre">forall</span></code> (although you are allowed an explicit
<code class="docutils literal"><span class="pre">forall</span></code> in an <code class="docutils literal"><span class="pre">instance</span></code> declaration; see <a class="reference internal" href="#explicit-foralls"><span>Explicit universal quantification (forall)</span></a>).
For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">op</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>

  <span class="n">op</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">ys</span><span class="ow">::</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
              <span class="n">ys</span> <span class="ow">=</span> <span class="n">reverse</span> <span class="n">xs</span>
          <span class="kr">in</span>
          <span class="n">head</span> <span class="n">ys</span>

<span class="kr">instance</span> <span class="kt">C</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="kr">where</span>
  <span class="n">op</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">reverse</span> <span class="p">(</span><span class="n">head</span> <span class="p">(</span><span class="n">xs</span> <span class="ow">::</span> <span class="p">[[</span><span class="n">b</span><span class="p">]]))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bindings-and-generalisation">
<h1>10.17. Bindings and generalisation<a class="headerlink" href="#bindings-and-generalisation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="switching-off-the-dreaded-monomorphism-restriction">
<span id="monomorphism"></span><h2>10.17.1. Switching off the dreaded Monomorphism Restriction<a class="headerlink" href="#switching-off-the-dreaded-monomorphism-restriction" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XNoMonomorphismRestriction">
<code class="descname">-XNoMonomorphismRestriction</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XNoMonomorphismRestriction" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Prevents the compiler from applying the monomorphism restriction to
bindings lacking explicit type signatures.</p>
</dd></dl>

<p>Haskell&#8217;s monomorphism restriction (see <a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.5.5">Section
4.5.5</a> of
the Haskell Report) can be completely switched off by
<a class="reference internal" href="#ghc-flag--XNoMonomorphismRestriction"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNoMonomorphismRestriction</span></code></a>. Since GHC 7.8.1, the monomorphism
restriction is switched off by default in GHCi&#8217;s interactive options
(see <a class="reference internal" href="ghci.html#ghci-interactive-options"><span>Setting options for interactive evaluation only</span></a>).</p>
</div>
<div class="section" id="let-generalisation">
<span id="mono-local-binds"></span><h2>10.17.2. Let-generalisation<a class="headerlink" href="#let-generalisation" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XMonoLocalBinds">
<code class="descname">-XMonoLocalBinds</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XMonoLocalBinds" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">6.12</td>
</tr>
</tbody>
</table>
<p>Infer less polymorphic types for local bindings by default.</p>
</dd></dl>

<p>An ML-style language usually generalises the type of any <code class="docutils literal"><span class="pre">let</span></code>-bound or
<code class="docutils literal"><span class="pre">where</span></code>-bound variable, so that it is as polymorphic as possible. With the
flag <a class="reference internal" href="#ghc-flag--XMonoLocalBinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonoLocalBinds</span></code></a> GHC implements a slightly more conservative
policy, using the following rules:</p>
<ul class="simple">
<li>A variable is <em>closed</em> if and only if<ul>
<li>the variable is let-bound</li>
<li>one of the following holds:<ul>
<li>the variable has an explicit type signature that has no free
type variables, or</li>
<li>its binding group is fully generalised (see next bullet)</li>
</ul>
</li>
</ul>
</li>
<li>A binding group is <em>fully generalised</em> if and only if<ul>
<li>each of its free variables is either imported or closed, and</li>
<li>the binding is not affected by the monomorphism restriction
(<a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.5.5">Haskell Report, Section
4.5.5</a>)</li>
</ul>
</li>
</ul>
<p>For example, consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="nf">g</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">h</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">2</span>
          <span class="n">k</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">z</span><span class="o">+</span><span class="n">x</span>
      <span class="kr">in</span>  <span class="n">h</span> <span class="n">x</span> <span class="o">+</span> <span class="n">k</span> <span class="n">x</span>
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">f</span></code> is generalised because it has no free variables; and its
binding group is unaffected by the monomorphism restriction; and hence
<code class="docutils literal"><span class="pre">f</span></code> is closed. The same reasoning applies to <code class="docutils literal"><span class="pre">g</span></code>, except that it has
one closed free variable, namely <code class="docutils literal"><span class="pre">f</span></code>. Similarly <code class="docutils literal"><span class="pre">h</span></code> is closed, <em>even
though it is not bound at top level</em>, because its only free variable
<code class="docutils literal"><span class="pre">f</span></code> is closed. But <code class="docutils literal"><span class="pre">k</span></code> is not closed, because it mentions <code class="docutils literal"><span class="pre">x</span></code>
which is not closed (because it is not let-bound).</p>
<p>Notice that a top-level binding that is affected by the monomorphism
restriction is not closed, and hence may in turn prevent generalisation
of bindings that mention it.</p>
<p>The rationale for this more conservative strategy is given in <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf">the
papers</a>
&#8220;Let should not be generalised&#8221; and &#8220;Modular type inference with local
assumptions&#8221;, and a related <a class="reference external" href="http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7">blog post</a>.</p>
<p>The flag <a class="reference internal" href="#ghc-flag--XMonoLocalBinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonoLocalBinds</span></code></a> is implied by <a class="reference internal" href="#ghc-flag--XTypeFamilies"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeFamilies</span></code></a>
and <a class="reference internal" href="#ghc-flag--XGADTs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGADTs</span></code></a>. You can switch it off again with
<a class="reference internal" href="#ghc-flag--XMonoLocalBinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNoMonoLocalBinds</span></code></a> but type inference becomes
less predicatable if you do so. (Read the papers!)</p>
</div>
<div class="section" id="kind-generalisation">
<span id="id49"></span><h2>10.17.3. Kind generalisation<a class="headerlink" href="#kind-generalisation" title="Permalink to this headline">¶</a></h2>
<p>Just as <a class="reference internal" href="#ghc-flag--XMonoLocalBinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonoLocalBinds</span></code></a> places limitations on when the <em>type</em> of a
<em>term</em> is generalised (see <a class="reference internal" href="#mono-local-binds"><span>Let-generalisation</span></a>), it also limits when the
<em>kind</em> of a <em>type signature</em> is generalised. Here is an example involving
<a class="reference internal" href="#instance-sigs"><span>type signatures on instance declarations</span></a>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Proxy</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Proxy</span>
<span class="kr">newtype</span> <span class="kt">Tagged</span> <span class="n">s</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Tagged</span> <span class="n">b</span>

<span class="kr">class</span> <span class="kt">C</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="n">c</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">s</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span> <span class="kt">Tagged</span> <span class="n">s</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="kt">C</span> <span class="p">(</span><span class="kt">Proxy</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">c</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">s</span><span class="o">.</span> <span class="kt">Tagged</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Proxy</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">c</span> <span class="ow">=</span> <span class="kt">Tagged</span> <span class="kt">Proxy</span>
</pre></div>
</div>
<p>With <a class="reference internal" href="#ghc-flag--XMonoLocalBinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonoLocalBinds</span></code></a> enabled, this <code class="docutils literal"><span class="pre">C</span> <span class="pre">(Proxy</span> <span class="pre">a)</span></code> instance will
fail to typecheck. The reason is that the type signature for <code class="docutils literal"><span class="pre">c</span></code> captures
<code class="docutils literal"><span class="pre">a</span></code>, an outer-scoped type variable, which means the type signature is not
closed. Therefore, the inferred kind for <code class="docutils literal"><span class="pre">s</span></code> will <em>not</em> be generalised, and
as a result, it will fail to unify with the kind variable <code class="docutils literal"><span class="pre">k</span></code> which is
specified in the declaration of <code class="docutils literal"><span class="pre">c</span></code>. This can be worked around by specifying
an explicit kind variable for <code class="docutils literal"><span class="pre">s</span></code>, e.g.,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="p">(</span><span class="kt">Proxy</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">c</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">s</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span> <span class="kt">Tagged</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Proxy</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">c</span> <span class="ow">=</span> <span class="kt">Tagged</span> <span class="kt">Proxy</span>
</pre></div>
</div>
<p>or, alternatively:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="p">(</span><span class="kt">Proxy</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">c</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">k</span> <span class="p">(</span><span class="n">s</span> <span class="ow">::</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span> <span class="kt">Tagged</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Proxy</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">c</span> <span class="ow">=</span> <span class="kt">Tagged</span> <span class="kt">Proxy</span>
</pre></div>
</div>
<p>This declarations are equivalent using Haskell&#8217;s implicit &#8220;add implicit
foralls&#8221; rules (see <a class="reference internal" href="#implicit-quantification"><span>Implicit quantification</span></a>). The implicit foralls rules
are purely syntactic and are quite separate from the kind generalisation
described here.</p>
</div>
</div>
<div class="section" id="visible-type-application">
<span id="id50"></span><h1>10.18. Visible type application<a class="headerlink" href="#visible-type-application" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XTypeApplications">
<code class="descname">-XTypeApplications</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XTypeApplications" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Allow the use of type application syntax.</p>
</dd></dl>

<p>The <a class="reference internal" href="#ghc-flag--XTypeApplications"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTypeApplications</span></code></a> extension allows you to use
<em>visible type application</em> in expressions. Here is an
example: <code class="docutils literal"><span class="pre">show</span> <span class="pre">(read</span> <span class="pre">&#64;Int</span> <span class="pre">&quot;5&quot;)</span></code>. The <code class="docutils literal"><span class="pre">&#64;Int</span></code>
is the visible type application; it specifies the value of the type variable
in <code class="docutils literal"><span class="pre">read</span></code>&#8216;s type.</p>
<p>A visible type application is preceded with an <code class="docutils literal"><span class="pre">&#64;</span></code>
sign. (To disambiguate the syntax, the <code class="docutils literal"><span class="pre">&#64;</span></code> must be
preceded with a non-identifier letter, usually a space. For example,
<code class="docutils literal"><span class="pre">read&#64;Int</span> <span class="pre">5</span></code> would not parse.) It can be used whenever
the full polymorphic type of the function is known. If the function
is an identifier (the common case), its type is considered known only when
the identifier has been given a type signature. If the identifier does
not have a type signature, visible type application cannot be used.</p>
<p>Here are the details:</p>
<ul>
<li><p class="first">If an identifier&#8217;s type signature does not include an
explicit <code class="docutils literal"><span class="pre">forall</span></code>, the type variable arguments appear
in the left-to-right order in which the variables appear in the type.
So, <code class="docutils literal"><span class="pre">foo</span> <span class="pre">::</span> <span class="pre">Monad</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">(a</span> <span class="pre">c)</span></code>
will have its type variables
ordered as <code class="docutils literal"><span class="pre">m,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></code>.</p>
</li>
<li><p class="first">If any of the variables depend on other variables (that is, if some
of the variables are <em>kind</em> variables), the variables are reordered
so that kind variables come before type variables, preserving the
left-to-right order as much as possible. That is, GHC performs a
stable topological sort on the variables.</p>
<p>For example: if we have <code class="docutils literal"><span class="pre">bar</span> <span class="pre">::</span> <span class="pre">Proxy</span> <span class="pre">(a</span> <span class="pre">::</span> <span class="pre">(j,</span> <span class="pre">k))</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>, then
the variables are ordered <code class="docutils literal"><span class="pre">j</span></code>, <code class="docutils literal"><span class="pre">k</span></code>, <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code>.</p>
</li>
<li><p class="first">Visible type application is available to instantiate only user-specified
type variables. This means that in <code class="docutils literal"><span class="pre">data</span> <span class="pre">Proxy</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Proxy</span></code>, the unmentioned
kind variable used in <code class="docutils literal"><span class="pre">a</span></code>&#8216;s kind is <em>not</em> available for visible type
application.</p>
</li>
<li><p class="first">Class methods&#8217; type arguments include the class type
variables, followed by any variables an individual method is polymorphic
in. So, <code class="docutils literal"><span class="pre">class</span> <span class="pre">Monad</span> <span class="pre">m</span> <span class="pre">where</span> <span class="pre">return</span> <span class="pre">::</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code> means
that <code class="docutils literal"><span class="pre">return</span></code>&#8216;s type arguments are <code class="docutils literal"><span class="pre">m,</span> <span class="pre">a</span></code>.</p>
</li>
<li><p class="first">With the <a class="reference internal" href="#ghc-flag--XRankNTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRankNTypes</span></code></a> extension
(<a class="reference internal" href="#universal-quantification"><span>Lexically scoped type variables</span></a>), it is possible to declare
type arguments somewhere other than the beginning of a type. For example,
we can have <code class="docutils literal"><span class="pre">pair</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">forall</span> <span class="pre">b.</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">(a,</span> <span class="pre">b)</span></code>
and then say <code class="docutils literal"><span class="pre">pair</span> <span class="pre">&#64;Bool</span> <span class="pre">True</span> <span class="pre">&#64;Char</span></code> which would have
type <code class="docutils literal"><span class="pre">Char</span> <span class="pre">-&gt;</span> <span class="pre">(Bool,</span> <span class="pre">Char)</span></code>.</p>
</li>
<li><p class="first">Partial type signatures (<a class="reference internal" href="#partial-type-signatures"><span>Partial Type Signatures</span></a>)
work nicely with visible type
application. If you want to specify only the second type argument to
<code class="docutils literal"><span class="pre">wurble</span></code>, then you can say <code class="docutils literal"><span class="pre">wurble</span> <span class="pre">&#64;_</span> <span class="pre">&#64;Int</span></code>.
The first argument is a wildcard, just like in a partial type signature.
However, if used in a visible type application, it is <em>not</em>
necessary to specify <a class="reference internal" href="#ghc-flag--XPartialTypeSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPartialTypeSignatures</span></code></a> and your
code will not generate a warning informing you of the omitted type.</p>
</li>
<li><p class="first">When printing types with <a class="reference internal" href="using.html#ghc-flag--fprint-explicit-foralls"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fprint-explicit-foralls</span></code></a> enabled,
type variables not available for visible type application are printed
in braces. We can observe this behavior in a GHCi session:</p>
<div class="highlight-haskell"><div class="highlight"><pre>&gt; :set -XTypeApplications -fprint-explicit-foralls
&gt; let myLength1 :: Foldable f =&gt; f a -&gt; Int; myLength1 = length
&gt; :type +v myLength1
myLength1 :: forall (f :: * -&gt; *) a. Foldable f =&gt; f a -&gt; Int
&gt; let myLength2 = length
&gt; :type +v myLength2
myLength2 :: forall {a} {t :: * -&gt; *}. Foldable t =&gt; t a -&gt; Int
&gt; :type +v myLength2 @[]

&lt;interactive&gt;:1:1: error:
    • Cannot apply expression of type ‘t0 a0 -&gt; Int’
      to a visible type argument ‘[]’
    • In the expression: myLength2 @[]
</pre></div>
</div>
<p>Notice that since <code class="docutils literal"><span class="pre">myLength1</span></code> was defined with an explicit type signature,
<a class="reference internal" href="ghci.html#ghci-cmd-:type +v"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span> <span class="pre">+v</span></code></a> reports that all of its type variables are available
for type application. On the other hand, <code class="docutils literal"><span class="pre">myLength2</span></code> was not given a type
signature. As a result, all of its type variables are surrounded with braces,
and trying to use visible type application with <code class="docutils literal"><span class="pre">myLength2</span></code> fails.</p>
<p>Also note the use of <a class="reference internal" href="ghci.html#ghci-cmd-:type +v"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span> <span class="pre">+v</span></code></a> in the GHCi session above instead
of <a class="reference internal" href="ghci.html#ghci-cmd-:type"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span></code></a>. This is because <a class="reference internal" href="ghci.html#ghci-cmd-:type"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span></code></a> gives you the type
that would be inferred for a variable assigned to the expression provided
(that is, the type of <code class="docutils literal"><span class="pre">x</span></code> in <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">&lt;expr&gt;</span></code>). As we saw above with
<code class="docutils literal"><span class="pre">myLength2</span></code>, this type will have no variables available to visible type
application. On the other hand, <a class="reference internal" href="ghci.html#ghci-cmd-:type +v"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span> <span class="pre">+v</span></code></a> gives you the actual
type of the expression provided. To illustrate this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">myLength1</span>
<span class="nf">myLength1</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">{</span><span class="n">a</span><span class="p">}</span> <span class="p">{</span><span class="n">f</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">}</span><span class="o">.</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">myLength2</span>
<span class="nf">myLength2</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">{</span><span class="n">a</span><span class="p">}</span> <span class="p">{</span><span class="n">t</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">}</span><span class="o">.</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>Using <a class="reference internal" href="ghci.html#ghci-cmd-:type"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span></code></a> might lead one to conclude that none of the type
variables in <code class="docutils literal"><span class="pre">myLength1</span></code>&#8216;s type signature are available for type
application. This isn&#8217;t true, however! Be sure to use <a class="reference internal" href="ghci.html#ghci-cmd-:type +v"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span> <span class="pre">+v</span></code></a>
if you want the most accurate information with respect to visible type
application properties.</p>
</li>
<li><p class="first">Data constructors declared with GADT syntax follow different rules
for the time being; it is expected that these will be brought in line
with other declarations in the future. The rules for GADT
data constructors are as follows:</p>
<blockquote>
<div><ul class="simple">
<li>All kind and type variables are considered specified and available for
visible type application.</li>
<li>Universal variables always come first, in precisely the order they
appear in the type delcaration. Universal variables that are
constrained by a GADT return type are not included in the data constructor.</li>
<li>Existential variables come next. Their order is determined by a user-
written <cite>forall</cite>; or, if there is none, by taking the left-to-right order
in the data constructor&#8217;s type and doing a stable topological sort.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="implicit-parameters">
<span id="id51"></span><h1>10.19. Implicit parameters<a class="headerlink" href="#implicit-parameters" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XImplicitParams">
<code class="descname">-XImplicitParams</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XImplicitParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow definition of functions expecting implicit parameters.</p>
</dd></dl>

<p>Implicit parameters are implemented as described in <a class="reference internal" href="#lewis2000" id="id52">[Lewis2000]</a> and enabled
with the option <a class="reference internal" href="#ghc-flag--XImplicitParams"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XImplicitParams</span></code></a>. (Most of the following, still rather
incomplete, documentation is due to Jeff Lewis.)</p>
<table class="docutils citation" frame="void" id="lewis2000" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id52">[Lewis2000]</a></td><td>&#8220;Implicit parameters: dynamic scoping with static types&#8221;,
J Lewis, MB Shields, E Meijer, J Launchbury,
<em>27th ACM Symposium on Principles of Programming Languages (POPL&#8216;00)</em>,
Boston, Jan 2000.</td></tr>
</tbody>
</table>
<p>A variable is called <em>dynamically bound</em> when it is bound by the calling
context of a function and <em>statically bound</em> when bound by the callee&#8217;s
context. In Haskell, all variables are statically bound. Dynamic binding
of variables is a notion that goes back to Lisp, but was later discarded
in more modern incarnations, such as Scheme. Dynamic binding can be very
confusing in an untyped language, and unfortunately, typed languages, in
particular Hindley-Milner typed languages like Haskell, only support
static scoping of variables.</p>
<p>However, by a simple extension to the type class system of Haskell, we
can support dynamic binding. Basically, we express the use of a
dynamically bound variable as a constraint on the type. These
constraints lead to types of the form <code class="docutils literal"><span class="pre">(?x::t')</span> <span class="pre">=&gt;</span> <span class="pre">t</span></code>, which says
&#8220;this function uses a dynamically-bound variable <code class="docutils literal"><span class="pre">?x</span></code> of type <code class="docutils literal"><span class="pre">t'</span></code>&#8221;.
For example, the following expresses the type of a sort function,
implicitly parameterised by a comparison function named <code class="docutils literal"><span class="pre">cmp</span></code>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">sort</span> <span class="ow">::</span> <span class="p">(</span><span class="o">?</span><span class="n">cmp</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>The dynamic binding constraints are just a new form of predicate in the
type class system.</p>
<p>An implicit parameter occurs in an expression using the special form
<code class="docutils literal"><span class="pre">?x</span></code>, where <code class="docutils literal"><span class="pre">x</span></code> is any valid identifier (e.g. <code class="docutils literal"><span class="pre">ord</span> <span class="pre">?x</span></code> is a valid
expression). Use of this construct also introduces a new dynamic-binding
constraint in the type of the expression. For example, the following
definition shows how we can define an implicitly parameterised sort
function in terms of an explicitly parameterised <code class="docutils literal"><span class="pre">sortBy</span></code> function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">sortBy</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="nf">sort</span>   <span class="ow">::</span> <span class="p">(</span><span class="o">?</span><span class="n">cmp</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">sort</span>    <span class="ow">=</span> <span class="n">sortBy</span> <span class="o">?</span><span class="n">cmp</span>
</pre></div>
</div>
<div class="section" id="implicit-parameter-type-constraints">
<h2>10.19.1. Implicit-parameter type constraints<a class="headerlink" href="#implicit-parameter-type-constraints" title="Permalink to this headline">¶</a></h2>
<p>Dynamic binding constraints behave just like other type class
constraints in that they are automatically propagated. Thus, when a
function is used, its implicit parameters are inherited by the function
that called it. For example, our <code class="docutils literal"><span class="pre">sort</span></code> function might be used to pick
out the least value in a list:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">least</span>   <span class="ow">::</span> <span class="p">(</span><span class="o">?</span><span class="n">cmp</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">least</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">head</span> <span class="p">(</span><span class="n">sort</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>Without lifting a finger, the <code class="docutils literal"><span class="pre">?cmp</span></code> parameter is propagated to become
a parameter of <code class="docutils literal"><span class="pre">least</span></code> as well. With explicit parameters, the default
is that parameters must always be explicit propagated. With implicit
parameters, the default is to always propagate them.</p>
<p>An implicit-parameter type constraint differs from other type class
constraints in the following way: All uses of a particular implicit
parameter must have the same type. This means that the type of
<code class="docutils literal"><span class="pre">(?x,</span> <span class="pre">?x)</span></code> is <code class="docutils literal"><span class="pre">(?x::a)</span> <span class="pre">=&gt;</span> <span class="pre">(a,a)</span></code>, and not
<code class="docutils literal"><span class="pre">(?x::a,</span> <span class="pre">?x::b)</span> <span class="pre">=&gt;</span> <span class="pre">(a,</span> <span class="pre">b)</span></code>, as would be the case for type class
constraints.</p>
<p>You can&#8217;t have an implicit parameter in the context of a class or
instance declaration. For example, both these declarations are illegal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="p">(</span><span class="o">?</span><span class="n">x</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">...</span>
<span class="kr">instance</span> <span class="p">(</span><span class="o">?</span><span class="n">x</span><span class="ow">::</span><span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Foo</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>Reason: exactly which implicit parameter you pick up depends on exactly
where you invoke a function. But the &#8220;invocation&#8221; of instance
declarations is done behind the scenes by the compiler, so it&#8217;s hard to
figure out exactly where it is done. Easiest thing is to outlaw the
offending types.</p>
<p>Implicit-parameter constraints do not cause ambiguity. For example,
consider:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="o">?</span><span class="n">x</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">f</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">length</span> <span class="o">?</span><span class="n">x</span>

<span class="nf">g</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">g</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">show</span> <span class="p">(</span><span class="n">read</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">g</span></code> has an ambiguous type, and is rejected, but <code class="docutils literal"><span class="pre">f</span></code> is fine.
The binding for <code class="docutils literal"><span class="pre">?x</span></code> at <code class="docutils literal"><span class="pre">f</span></code>&#8216;s call site is quite unambiguous, and
fixes the type <code class="docutils literal"><span class="pre">a</span></code>.</p>
</div>
<div class="section" id="implicit-parameter-bindings">
<h2>10.19.2. Implicit-parameter bindings<a class="headerlink" href="#implicit-parameter-bindings" title="Permalink to this headline">¶</a></h2>
<p>An implicit parameter is <em>bound</em> using the standard <code class="docutils literal"><span class="pre">let</span></code> or <code class="docutils literal"><span class="pre">where</span></code>
binding forms. For example, we define the <code class="docutils literal"><span class="pre">min</span></code> function by binding
<code class="docutils literal"><span class="pre">cmp</span></code>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">min</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">min</span>  <span class="ow">=</span> <span class="kr">let</span> <span class="o">?</span><span class="n">cmp</span> <span class="ow">=</span> <span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span> <span class="kr">in</span> <span class="n">least</span>
</pre></div>
</div>
<p>A group of implicit-parameter bindings may occur anywhere a normal group
of Haskell bindings can occur, except at top level. That is, they can
occur in a <code class="docutils literal"><span class="pre">let</span></code> (including in a list comprehension, or do-notation,
or pattern guards), or a <code class="docutils literal"><span class="pre">where</span></code> clause. Note the following points:</p>
<ul>
<li><p class="first">An implicit-parameter binding group must be a collection of simple
bindings to implicit-style variables (no function-style bindings, and
no type signatures); these bindings are neither polymorphic or
recursive.</p>
</li>
<li><p class="first">You may not mix implicit-parameter bindings with ordinary bindings in
a single <code class="docutils literal"><span class="pre">let</span></code> expression; use two nested <code class="docutils literal"><span class="pre">let</span></code>s instead. (In
the case of <code class="docutils literal"><span class="pre">where</span></code> you are stuck, since you can&#8217;t nest <code class="docutils literal"><span class="pre">where</span></code>
clauses.)</p>
</li>
<li><p class="first">You may put multiple implicit-parameter bindings in a single binding
group; but they are <em>not</em> treated as a mutually recursive group (as
ordinary <code class="docutils literal"><span class="pre">let</span></code> bindings are). Instead they are treated as a
non-recursive group, simultaneously binding all the implicit
parameter. The bindings are not nested, and may be re-ordered without
changing the meaning of the program. For example, consider:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">t</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">{</span> <span class="o">?</span><span class="n">x</span> <span class="ow">=</span> <span class="n">t</span><span class="p">;</span> <span class="o">?</span><span class="n">y</span> <span class="ow">=</span> <span class="o">?</span><span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span> <span class="p">}</span> <span class="kr">in</span> <span class="o">?</span><span class="n">x</span> <span class="o">+</span> <span class="o">?</span><span class="n">y</span>
</pre></div>
</div>
<p>The use of <code class="docutils literal"><span class="pre">?x</span></code> in the binding for <code class="docutils literal"><span class="pre">?y</span></code> does not &#8220;see&#8221; the
binding for <code class="docutils literal"><span class="pre">?x</span></code>, so the type of <code class="docutils literal"><span class="pre">f</span></code> is</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="o">?</span><span class="n">x</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="implicit-parameters-and-polymorphic-recursion">
<h2>10.19.3. Implicit parameters and polymorphic recursion<a class="headerlink" href="#implicit-parameters-and-polymorphic-recursion" title="Permalink to this headline">¶</a></h2>
<p>Consider these two definitions:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">len1</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">len1</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">let</span> <span class="o">?</span><span class="n">acc</span> <span class="ow">=</span> <span class="mi">0</span> <span class="kr">in</span> <span class="n">len_acc1</span> <span class="n">xs</span>

<span class="nf">len_acc1</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="o">?</span><span class="n">acc</span>
<span class="nf">len_acc1</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="o">?</span><span class="n">acc</span> <span class="ow">=</span> <span class="o">?</span><span class="n">acc</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span> <span class="kr">in</span> <span class="n">len_acc1</span> <span class="n">xs</span>

<span class="c1">------------</span>

<span class="nf">len2</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">len2</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">let</span> <span class="o">?</span><span class="n">acc</span> <span class="ow">=</span> <span class="mi">0</span> <span class="kr">in</span> <span class="n">len_acc2</span> <span class="n">xs</span>

<span class="nf">len_acc2</span> <span class="ow">::</span> <span class="p">(</span><span class="o">?</span><span class="n">acc</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">len_acc2</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="o">?</span><span class="n">acc</span>
<span class="nf">len_acc2</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="o">?</span><span class="n">acc</span> <span class="ow">=</span> <span class="o">?</span><span class="n">acc</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span> <span class="kr">in</span> <span class="n">len_acc2</span> <span class="n">xs</span>
</pre></div>
</div>
<p>The only difference between the two groups is that in the second group
<code class="docutils literal"><span class="pre">len_acc</span></code> is given a type signature. In the former case, <code class="docutils literal"><span class="pre">len_acc1</span></code>
is monomorphic in its own right-hand side, so the implicit parameter
<code class="docutils literal"><span class="pre">?acc</span></code> is not passed to the recursive call. In the latter case,
because <code class="docutils literal"><span class="pre">len_acc2</span></code> has a type signature, the recursive call is made to
the <em>polymorphic</em> version, which takes <code class="docutils literal"><span class="pre">?acc</span></code> as an implicit
parameter. So we get the following results in GHCi:</p>
<div class="highlight-none"><div class="highlight"><pre>Prog&gt; len1 &quot;hello&quot;
0
Prog&gt; len2 &quot;hello&quot;
5
</pre></div>
</div>
<p>Adding a type signature dramatically changes the result! This is a
rather counter-intuitive phenomenon, worth watching out for.</p>
</div>
<div class="section" id="implicit-parameters-and-monomorphism">
<h2>10.19.4. Implicit parameters and monomorphism<a class="headerlink" href="#implicit-parameters-and-monomorphism" title="Permalink to this headline">¶</a></h2>
<p>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the
Haskell Report) to implicit parameters. For example, consider:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">f</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">let</span> <span class="o">?</span><span class="n">x</span> <span class="ow">=</span> <span class="mi">0</span>     <span class="kr">in</span>
      <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="o">?</span><span class="n">x</span> <span class="o">+</span> <span class="n">v</span> <span class="kr">in</span>
      <span class="kr">let</span> <span class="o">?</span><span class="n">x</span> <span class="ow">=</span> <span class="mi">5</span>     <span class="kr">in</span>
      <span class="n">y</span>
</pre></div>
</div>
<p>Since the binding for <code class="docutils literal"><span class="pre">y</span></code> falls under the Monomorphism Restriction it
is not generalised, so the type of <code class="docutils literal"><span class="pre">y</span></code> is simply <code class="docutils literal"><span class="pre">Int</span></code>, not
<code class="docutils literal"><span class="pre">(?x::Int)</span> <span class="pre">=&gt;</span> <span class="pre">Int</span></code>. Hence, <code class="docutils literal"><span class="pre">(f</span> <span class="pre">9)</span></code> returns result <code class="docutils literal"><span class="pre">9</span></code>. If you add
a type signature for <code class="docutils literal"><span class="pre">y</span></code>, then <code class="docutils literal"><span class="pre">y</span></code> will get type
<code class="docutils literal"><span class="pre">(?x::Int)</span> <span class="pre">=&gt;</span> <span class="pre">Int</span></code>, so the occurrence of <code class="docutils literal"><span class="pre">y</span></code> in the body of the
<code class="docutils literal"><span class="pre">let</span></code> will see the inner binding of <code class="docutils literal"><span class="pre">?x</span></code>, so <code class="docutils literal"><span class="pre">(f</span> <span class="pre">9)</span></code> will return
<code class="docutils literal"><span class="pre">14</span></code>.</p>
</div>
</div>
<div class="section" id="arbitrary-rank-polymorphism">
<h1>10.20. Arbitrary-rank polymorphism<a class="headerlink" href="#arbitrary-rank-polymorphism" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XRankNTypes">
<code class="descname">-XRankNTypes</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XRankNTypes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XExplicitForAll"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitForAll</span></code></a></td>
</tr>
</tbody>
</table>
<p>Allow types of arbitrary rank.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--XRank2Types">
<code class="descname">-XRank2Types</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XRank2Types" title="Permalink to this definition">¶</a></dt>
<dd><p>A deprecated alias of <a class="reference internal" href="#ghc-flag--XRankNTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRankNTypes</span></code></a>.</p>
</dd></dl>

<p>GHC&#8217;s type system supports <em>arbitrary-rank</em> explicit universal
quantification in types. For example, all the following types are legal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f1</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">g1</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span>  <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">f2</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">g2</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>

<span class="nf">f3</span> <span class="ow">::</span> <span class="p">((</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>

<span class="nf">f4</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">f1</span></code> and <code class="docutils literal"><span class="pre">g1</span></code> are rank-1 types, and can be written in standard
Haskell (e.g. <code class="docutils literal"><span class="pre">f1</span> <span class="pre">::</span> <span class="pre">a-&gt;b-&gt;a</span></code>). The <code class="docutils literal"><span class="pre">forall</span></code> makes explicit the
universal quantification that is implicitly added by Haskell.</p>
<p>The functions <code class="docutils literal"><span class="pre">f2</span></code> and <code class="docutils literal"><span class="pre">g2</span></code> have rank-2 types; the <code class="docutils literal"><span class="pre">forall</span></code> is on
the left of a function arrow. As <code class="docutils literal"><span class="pre">g2</span></code> shows, the polymorphic type on
the left of the function arrow can be overloaded.</p>
<p>The function <code class="docutils literal"><span class="pre">f3</span></code> has a rank-3 type; it has rank-2 types on the left
of a function arrow.</p>
<p>The language option <a class="reference internal" href="#ghc-flag--XRankNTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRankNTypes</span></code></a> (which implies
<a class="reference internal" href="#ghc-flag--XExplicitForAll"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExplicitForAll</span></code></a>) enables higher-rank
types. That is, you can nest <code class="docutils literal"><span class="pre">forall</span></code>s arbitrarily deep in function
arrows. For example, a forall-type (also called a &#8220;type scheme&#8221;),
including a type-class context, is legal:</p>
<ul class="simple">
<li>On the left or right (see <code class="docutils literal"><span class="pre">f4</span></code>, for example) of a function arrow</li>
<li>As the argument of a constructor, or type of a field, in a data type
declaration. For example, any of the <code class="docutils literal"><span class="pre">f1,</span> <span class="pre">f2,</span> <span class="pre">f3,</span> <span class="pre">g1,</span> <span class="pre">g2</span></code> above would
be valid field type signatures.</li>
<li>As the type of an implicit parameter</li>
<li>In a pattern type signature (see <a class="reference internal" href="#scoped-type-variables"><span>Lexically scoped type variables</span></a>)</li>
</ul>
<p>The <a class="reference internal" href="#ghc-flag--XRankNTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRankNTypes</span></code></a> option is also required for any type with a
<code class="docutils literal"><span class="pre">forall</span></code> or context to the right of an arrow (e.g.
<code class="docutils literal"><span class="pre">f</span> <span class="pre">::</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">a-&gt;a</span></code>, or <code class="docutils literal"><span class="pre">g</span> <span class="pre">::</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Ord</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>).
Such types are technically rank 1, but are clearly not Haskell-98, and
an extra flag did not seem worth the bother.</p>
<p>In particular, in <code class="docutils literal"><span class="pre">data</span></code> and <code class="docutils literal"><span class="pre">newtype</span></code> declarations the constructor
arguments may be polymorphic types of any rank; see examples in
<a class="reference internal" href="#univ"><span>Examples</span></a>. Note that the declared types are nevertheless always
monomorphic. This is important because by default GHC will not
instantiate type variables to a polymorphic type
(<a class="reference internal" href="#impredicative-polymorphism"><span>Impredicative polymorphism</span></a>).</p>
<p>The obsolete language options <code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolymorphicComponents</span></code> and
<a class="reference internal" href="#ghc-flag--XRank2Types"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRank2Types</span></code></a> are synonyms for <a class="reference internal" href="#ghc-flag--XRankNTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRankNTypes</span></code></a>. They used to
specify finer distinctions that GHC no longer makes. (They should really elicit
a deprecation warning, but they don&#8217;t, purely to avoid the need to library
authors to change their old flags specifications.)</p>
<div class="section" id="univ">
<span id="id53"></span><h2>10.20.1. Examples<a class="headerlink" href="#univ" title="Permalink to this headline">¶</a></h2>
<p>These are examples of <code class="docutils literal"><span class="pre">data</span></code> and <code class="docutils literal"><span class="pre">newtype</span></code> declarations whose data
constructors have polymorphic argument types:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">T1</span> <span class="p">(</span><span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span>

<span class="kr">data</span> <span class="kt">MonadT</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">MkMonad</span> <span class="p">{</span> <span class="n">return</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">,</span>
                          <span class="n">bind</span>   <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
                        <span class="p">}</span>

<span class="kr">newtype</span> <span class="kt">Swizzle</span> <span class="ow">=</span> <span class="kt">MkSwizzle</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
<p>The constructors have rank-2 types:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">T1</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span><span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">a</span>

<span class="kt">MkMonad</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">m</span><span class="o">.</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span>
                  <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span>
                  <span class="ow">-&gt;</span> <span class="kt">MonadT</span> <span class="n">m</span>

<span class="kt">MkSwizzle</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="kt">Swizzle</span>
</pre></div>
</div>
<p>In earlier versions of GHC, it was possible to omit the <code class="docutils literal"><span class="pre">forall</span></code> in
the type of the constructor if there was an explicit context. For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Swizzle&#39;</span> <span class="ow">=</span> <span class="kt">MkSwizzle&#39;</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
<p>Since GHC 8.0 declarations such as <code class="docutils literal"><span class="pre">MkSwizzle'</span></code> will cause an out-of-scope
error.</p>
<p>As for type signatures, implicit quantification happens for
non-overloaded types too. So if you write this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>it&#8217;s just as if you had written this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>That is, since the type variable <code class="docutils literal"><span class="pre">a</span></code> isn&#8217;t in scope, it&#8217;s implicitly
universally quantified.</p>
<p>You construct values of types <code class="docutils literal"><span class="pre">T1,</span> <span class="pre">MonadT,</span> <span class="pre">Swizzle</span></code> by applying the
constructor to suitable values, just as usual. For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">a1</span> <span class="ow">::</span> <span class="kt">T</span> <span class="kt">Int</span>
<span class="nf">a1</span> <span class="ow">=</span> <span class="kt">T1</span> <span class="p">(</span><span class="nf">\</span><span class="n">xy</span><span class="ow">-&gt;</span><span class="n">x</span><span class="p">)</span> <span class="mi">3</span>

<span class="nf">a2</span><span class="p">,</span> <span class="n">a3</span> <span class="ow">::</span> <span class="kt">Swizzle</span>
<span class="nf">a2</span> <span class="ow">=</span> <span class="kt">MkSwizzle</span> <span class="n">sort</span>
<span class="nf">a3</span> <span class="ow">=</span> <span class="kt">MkSwizzle</span> <span class="n">reverse</span>

<span class="nf">a4</span> <span class="ow">::</span> <span class="kt">MonadT</span> <span class="kt">Maybe</span>
<span class="nf">a4</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">x</span>
     <span class="n">b</span> <span class="n">m</span> <span class="n">k</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
           <span class="kt">Just</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="n">y</span>
           <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
     <span class="kr">in</span>
     <span class="kt">MkMonad</span> <span class="n">r</span> <span class="n">b</span>

<span class="nf">mkTs</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">T</span> <span class="n">a</span><span class="p">]</span>
<span class="nf">mkTs</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">T1</span> <span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="kt">T1</span> <span class="n">f</span> <span class="n">y</span><span class="p">]</span>
</pre></div>
</div>
<p>The type of the argument can, as usual, be more general than the type
required, as <code class="docutils literal"><span class="pre">(MkSwizzle</span> <span class="pre">reverse)</span></code> shows. (<code class="docutils literal"><span class="pre">reverse</span></code> does not need
the <code class="docutils literal"><span class="pre">Ord</span></code> constraint.)</p>
<p>When you use pattern matching, the bound variables may now have
polymorphic types. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">T1</span> <span class="n">w</span> <span class="n">k</span><span class="p">)</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">w</span> <span class="n">k</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="sc">&#39;c&#39;</span> <span class="sc">&#39;d&#39;</span><span class="p">)</span>

<span class="nf">g</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Swizzle</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">g</span> <span class="p">(</span><span class="kt">MkSwizzle</span> <span class="n">s</span><span class="p">)</span> <span class="n">xs</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">s</span> <span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">s</span> <span class="n">xs</span><span class="p">))</span>

<span class="nf">h</span> <span class="ow">::</span> <span class="kt">MonadT</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">m</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">h</span> <span class="n">m</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">m</span> <span class="kt">[]</span>
<span class="nf">h</span> <span class="n">m</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bind</span> <span class="n">m</span> <span class="n">x</span>          <span class="o">$</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span>
             <span class="n">bind</span> <span class="n">m</span> <span class="p">(</span><span class="n">h</span> <span class="n">m</span> <span class="n">xs</span><span class="p">)</span>   <span class="o">$</span> <span class="nf">\</span><span class="n">ys</span> <span class="ow">-&gt;</span>
             <span class="n">return</span> <span class="n">m</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
<p>In the function <code class="docutils literal"><span class="pre">h</span></code> we use the record selectors <code class="docutils literal"><span class="pre">return</span></code> and
<code class="docutils literal"><span class="pre">bind</span></code> to extract the polymorphic bind and return functions from the
<code class="docutils literal"><span class="pre">MonadT</span></code> data structure, rather than using pattern matching.</p>
</div>
<div class="section" id="type-inference">
<span id="higher-rank-type-inference"></span><h2>10.20.2. Type inference<a class="headerlink" href="#type-inference" title="Permalink to this headline">¶</a></h2>
<p>In general, type inference for arbitrary-rank types is undecidable. GHC
uses an algorithm proposed by Odersky and Laufer (&#8220;Putting type
annotations to work&#8221;, POPL&#8216;96) to get a decidable algorithm by requiring
some help from the programmer. We do not yet have a formal specification
of &#8220;some help&#8221; but the rule is this:</p>
<blockquote>
<div>For a lambda-bound or case-bound variable, x, either the programmer
provides an explicit polymorphic type for x, or GHC&#8217;s type inference
will assume that x&#8217;s type has no foralls in it.</div></blockquote>
<p>What does it mean to &#8220;provide&#8221; an explicit type for x? You can do that
by giving a type signature for x directly, using a pattern type
signature (<a class="reference internal" href="#scoped-type-variables"><span>Lexically scoped type variables</span></a>), thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">\</span> <span class="n">f</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="kt">True</span><span class="p">,</span> <span class="n">f</span> <span class="sc">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, you can give a type signature to the enclosing context,
which GHC can &#8220;push down&#8221; to find the type for the variable:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="nf">\</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="kt">True</span><span class="p">,</span> <span class="n">f</span> <span class="sc">&#39;c&#39;</span><span class="p">))</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span><span class="kt">Char</span><span class="p">)</span>
</pre></div>
</div>
<p>Here the type signature on the expression can be pushed inwards to give
a type signature for f. Similarly, and more commonly, one can give a
type signature for the function itself:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">h</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span><span class="kt">Char</span><span class="p">)</span>
<span class="nf">h</span> <span class="n">f</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="kt">True</span><span class="p">,</span> <span class="n">f</span> <span class="sc">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>You don&#8217;t need to give a type signature if the lambda bound variable is
a constructor argument. Here is an example we saw earlier:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">T1</span> <span class="n">w</span> <span class="n">k</span><span class="p">)</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">w</span> <span class="n">k</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="sc">&#39;c&#39;</span> <span class="sc">&#39;d&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we do not need to give a type signature to <code class="docutils literal"><span class="pre">w</span></code>, because it is an
argument of constructor <code class="docutils literal"><span class="pre">T1</span></code> and that tells GHC all it needs to know.</p>
</div>
<div class="section" id="implicit-quantification">
<span id="id54"></span><h2>10.20.3. Implicit quantification<a class="headerlink" href="#implicit-quantification" title="Permalink to this headline">¶</a></h2>
<p>GHC performs implicit quantification as follows. At the outermost level
(only) of user-written types, if and only if there is no explicit
<code class="docutils literal"><span class="pre">forall</span></code>, GHC finds all the type variables mentioned in the type that
are not already in scope, and universally quantifies them. For example,
the following pairs are equivalent:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">f</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">g</span> <span class="p">(</span><span class="n">x</span><span class="ow">::</span><span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span>
              <span class="n">h</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
              <span class="n">h</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">y</span>
           <span class="kr">in</span> <span class="o">...</span>
<span class="nf">g</span> <span class="p">(</span><span class="n">x</span><span class="ow">::</span><span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span>
              <span class="n">h</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
              <span class="n">h</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">y</span>
           <span class="kr">in</span> <span class="o">...</span>
</pre></div>
</div>
<p>Notice that GHC always adds implicit quantfiers <em>at the outermost level</em>
of a user-written type; it
does <em>not</em> find the inner-most possible quantification
point. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
         <span class="c1">-- MEANS</span>
<span class="nf">f</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
         <span class="c1">-- NOT</span>
<span class="nf">f</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>


<span class="nf">g</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
         <span class="c1">-- MEANS</span>
<span class="nf">g</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
         <span class="c1">-- NOT</span>
<span class="nf">g</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>If you want the latter type, you can write
your <code class="docutils literal"><span class="pre">forall</span></code>s explicitly. Indeed, doing so is strongly advised for
rank-2 types.</p>
<p>Sometimes there <em>is</em> no &#8220;outermost level&#8221;, in which case no
implicit quantification happens:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">PackMap</span> <span class="n">a</span> <span class="n">b</span> <span class="n">s</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">PackMap</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>This is rejected because there is no &#8220;outermost level&#8221; for the types on the RHS
(it would obviously be terrible to add extra parameters to <code class="docutils literal"><span class="pre">PackMap</span></code>),
so no implicit quantification happens, and the declaration is rejected
(with &#8220;<code class="docutils literal"><span class="pre">f</span></code> is out of scope&#8221;).  Solution: use an explicit <code class="docutils literal"><span class="pre">forall</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">PackMap</span> <span class="n">a</span> <span class="n">b</span> <span class="n">s</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">PackMap</span> <span class="p">(</span><span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="kt">Monad</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="impredicative-polymorphism">
<span id="id55"></span><h1>10.21. Impredicative polymorphism<a class="headerlink" href="#impredicative-polymorphism" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XImpredicativeTypes">
<code class="descname">-XImpredicativeTypes</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XImpredicativeTypes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XRankNTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRankNTypes</span></code></a></td>
</tr>
</tbody>
</table>
<p>Allow impredicative polymorphic types.</p>
</dd></dl>

<p>In general, GHC will only instantiate a polymorphic function at a
monomorphic type (one with no foralls). For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">runST</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">s</span><span class="o">.</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">id</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="nf">foo</span> <span class="ow">=</span> <span class="n">id</span> <span class="n">runST</span>   <span class="c1">-- Rejected</span>
</pre></div>
</div>
<p>The definition of <code class="docutils literal"><span class="pre">foo</span></code> is rejected because one would have to
instantiate <code class="docutils literal"><span class="pre">id</span></code>&#8216;s type with <code class="docutils literal"><span class="pre">b</span> <span class="pre">:=</span> <span class="pre">(forall</span> <span class="pre">s.</span> <span class="pre">ST</span> <span class="pre">s</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, and
that is not allowed. Instantiating polymorphic type variables with
polymorphic types is called <em>impredicative polymorphism</em>.</p>
<p>GHC has extremely flaky support for <em>impredicative polymorphism</em>,
enabled with <a class="reference internal" href="#ghc-flag--XImpredicativeTypes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XImpredicativeTypes</span></code></a>. If it worked, this would mean
that you <em>could</em> call a polymorphic function at a polymorphic type, and
parameterise data structures over polymorphic types. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">([</span><span class="kt">Int</span><span class="p">],</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">g</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">g</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="nf">f</span> <span class="kt">Nothing</span>  <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>Notice here that the <code class="docutils literal"><span class="pre">Maybe</span></code> type is parameterised by the
<em>polymorphic</em> type <code class="docutils literal"><span class="pre">(forall</span> <span class="pre">a.</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a])</span></code>. However <em>the extension
should be considered highly experimental, and certainly un-supported</em>.
You are welcome to try it, but please don&#8217;t rely on it working
consistently, or working the same in subsequent releases. See
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/wiki/ImpredicativePolymorphism">this wiki page</a> for more details.</p>
<p>If you want impredicative polymorphism, the main workaround is to use a
newtype wrapper. The <code class="docutils literal"><span class="pre">id</span> <span class="pre">runST</span></code> example can be written using theis
workaround like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">runST</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">s</span><span class="o">.</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">id</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="nf">nwetype</span> <span class="kt">Wrap</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Wrap</span> <span class="p">{</span> <span class="n">unWrap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">s</span><span class="o">.</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">}</span>

<span class="nf">foo</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">s</span><span class="o">.</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="n">unWrap</span> <span class="p">(</span><span class="n">id</span> <span class="p">(</span><span class="kt">Wrap</span> <span class="n">runST</span><span class="p">))</span>
      <span class="c1">-- Here id is called at monomorphic type (Wrap a)</span>
</pre></div>
</div>
</div>
<div class="section" id="typed-holes">
<span id="id56"></span><h1>10.22. Typed Holes<a class="headerlink" href="#typed-holes" title="Permalink to this headline">¶</a></h1>
<p>Typed holes are a feature of GHC that allows special placeholders
written with a leading underscore (e.g., &#8220;<code class="docutils literal"><span class="pre">_</span></code>&#8221;, &#8220;<code class="docutils literal"><span class="pre">_foo</span></code>&#8221;,
&#8220;<code class="docutils literal"><span class="pre">_bar</span></code>&#8221;), to be used as expressions. During compilation these holes
will generate an error message that describes which type is expected at
the hole&#8217;s location, information about the origin of any free type
variables, and a list of local bindings that might help fill the hole
with actual code. Typed holes are always enabled in GHC.</p>
<p>The goal of typed holes is to help with writing Haskell code rather than
to change the type system. Typed holes can be used to obtain extra
information from the type checker, which might otherwise be hard to get.
Normally, using GHCi, users can inspect the (inferred) type signatures
of all top-level bindings. However, this method is less convenient with
terms that are not defined on top-level or inside complex expressions.
Holes allow the user to check the type of the term they are about to
write.</p>
<p>For example, compiling the following module with GHC:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">_</span>
</pre></div>
</div>
<p>will fail with the following error:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">hole</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">2</span><span class="kt">:</span><span class="mi">7</span><span class="kt">:</span>
    <span class="kt">Found</span> <span class="n">hole</span> <span class="p">`</span><span class="n">_&#39;</span> <span class="n">with</span> <span class="kr">type</span><span class="kt">:</span> <span class="n">a</span>
    <span class="kt">Where:</span> <span class="p">`</span><span class="n">a&#39;</span> <span class="n">is</span> <span class="n">a</span> <span class="n">rigid</span> <span class="kr">type</span> <span class="n">variable</span> <span class="n">bound</span> <span class="n">by</span>
               <span class="n">the</span> <span class="kr">type</span> <span class="n">signature</span> <span class="n">for</span> <span class="n">f</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="n">at</span> <span class="n">hole</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">6</span>
    <span class="kt">Relevant</span> <span class="n">bindings</span> <span class="n">include</span>
      <span class="n">f</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">bound</span> <span class="n">at</span> <span class="n">hole</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">2</span><span class="kt">:</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">x</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">(</span><span class="n">bound</span> <span class="n">at</span> <span class="n">hole</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">2</span><span class="kt">:</span><span class="mi">3</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="kr">_</span>
    <span class="kt">In</span> <span class="n">an</span> <span class="n">equation</span> <span class="n">for</span> <span class="p">`</span><span class="n">f&#39;</span><span class="kt">:</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">_</span>
</pre></div>
</div>
<p>Here are some more details:</p>
<ul>
<li><p class="first">A &#8220;<code class="docutils literal"><span class="pre">Found</span> <span class="pre">hole</span></code>&#8221; error usually terminates compilation, like any
other type error. After all, you have omitted some code from your
program. Nevertheless, you can run and test a piece of code
containing holes, by using the <a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-typed-holes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-typed-holes</span></code></a> flag. This
flag defers errors produced by typed holes until runtime, and
converts them into compile-time warnings. These warnings can in turn
be suppressed entirely by <a class="reference internal" href="using-warnings.html#ghc-flag--Wtyped-holes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wno-typed-holes</span></code></a>.</p>
<p>The same behaviour for &#8220;<code class="docutils literal"><span class="pre">Variable</span> <span class="pre">out</span> <span class="pre">of</span> <span class="pre">scope</span></code>&#8221; errors, it terminates
compilation by default. You can defer such errors by using the
<a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-out-of-scope-variables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-out-of-scope-variables</span></code></a> flag. This flag defers errors
produced by out of scope variables until runtime, and
converts them into compile-time warnings. These warnings can in turn
be suppressed entirely by <a class="reference internal" href="using-warnings.html#ghc-flag--Wdeferred-out-of-scope-variables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wno-deferred-out-of-scope-variables</span></code></a>.</p>
<p>The result is that a hole or a variable will behave like <code class="docutils literal"><span class="pre">undefined</span></code>, but with
the added benefits that it shows a warning at compile time, and will
show the same message if it gets evaluated at runtime. This behaviour
follows that of the <a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-type-errors"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-type-errors</span></code></a> option, which implies
<a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-typed-holes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-typed-holes</span></code></a> and <a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-out-of-scope-variables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-out-of-scope-variables</span></code></a>.
See <a class="reference internal" href="#defer-type-errors"><span>Deferring type errors to runtime</span></a>.</p>
</li>
<li><p class="first">All unbound identifiers are treated as typed holes, <em>whether or not
they start with an underscore</em>. The only difference is in the error
message:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">cons</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">z</span> <span class="kt">:</span> <span class="kt">True</span> <span class="kt">:</span> <span class="n">_x</span> <span class="kt">:</span> <span class="n">y</span>
</pre></div>
</div>
<p>yields the errors</p>
<div class="highlight-none"><div class="highlight"><pre>Foo.hs:5:15: error:
    Found hole: _x :: Bool
    Relevant bindings include
      p :: Bool (bound at Foo.hs:3:6)
      cons :: Bool -&gt; [Bool] (bound at Foo.hs:3:1)

Foo.hs:5:20: error:
    Variable not in scope: y :: [Bool]
</pre></div>
</div>
<p>More information is given for explicit holes (i.e. ones that start
with an underscore), than for out-of-scope variables, because the
latter are often unintended typos, so the extra information is
distracting. If you want the detailed information, use a leading
underscore to make explicit your intent to use a hole.</p>
</li>
<li><p class="first">Unbound identifiers with the same name are never unified, even within
the same function, but shown individually. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">cons</span> <span class="ow">=</span> <span class="n">_x</span> <span class="kt">:</span> <span class="n">_x</span>
</pre></div>
</div>
<p>results in the following errors:</p>
<div class="highlight-none"><div class="highlight"><pre>unbound.hs:1:8:
    Found hole &#39;_x&#39; with type: a
    Where: `a&#39; is a rigid type variable bound by
               the inferred type of cons :: [a] at unbound.hs:1:1
    Relevant bindings include cons :: [a] (bound at unbound.hs:1:1)
    In the first argument of `(:)&#39;, namely `_x&#39;
    In the expression: _x : _x
    In an equation for `cons&#39;: cons = _x : _x

unbound.hs:1:13:
    Found hole &#39;_x&#39; with type: [a]
    Arising from: an undeclared identifier `_x&#39; at unbound.hs:1:13-14
    Where: `a&#39; is a rigid type variable bound by
               the inferred type of cons :: [a] at unbound.hs:1:1
    Relevant bindings include cons :: [a] (bound at unbound.hs:1:1)
    In the second argument of `(:)&#39;, namely `_x&#39;
    In the expression: _x : _x
    In an equation for `cons&#39;: cons = _x : _x
</pre></div>
</div>
<p>Notice the two different types reported for the two different
occurrences of <code class="docutils literal"><span class="pre">_x</span></code>.</p>
</li>
<li><p class="first">No language extension is required to use typed holes. The lexeme
&#8220;<code class="docutils literal"><span class="pre">_</span></code>&#8221; was previously illegal in Haskell, but now has a more
informative error message. The lexeme &#8220;<code class="docutils literal"><span class="pre">_x</span></code>&#8221; is a perfectly legal
variable, and its behaviour is unchanged when it is in scope. For
example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">_x</span> <span class="ow">=</span> <span class="n">_x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>does not elict any errors. Only a variable <em>that is not in scope</em>
(whether or not it starts with an underscore) is treated as an error
(which it always was), albeit now with a more informative error
message.</p>
</li>
<li><p class="first">Unbound data constructors used in expressions behave exactly as
above. However, unbound data constructors used in <em>patterns</em> cannot
be deferred, and instead bring compilation to a halt. (In
implementation terms, they are reported by the renamer rather than
the type checker.)</p>
</li>
</ul>
<p>There&#8217;s a flag for controlling the amount of context information shown for
typed holes:</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fshow-hole-constraints">
<code class="descname">-fshow-hole-constraints</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fshow-hole-constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>When reporting typed holes, also print constraints that are in scope.
Example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">_</span>
</pre></div>
</div>
<p>results in the following message:</p>
<div class="highlight-none"><div class="highlight"><pre>show_constraints.hs:4:7: error:
    • Found hole: _ :: Bool
    • In the expression: _
      In an equation for ‘f’: f x = _
    • Relevant bindings include
        x :: a (bound at show_constraints.hs:4:3)
        f :: a -&gt; Bool (bound at show_constraints.hs:4:1)
      Constraints include
        Eq a (from the type signature for:
                     f :: Eq a =&gt; a -&gt; Bool
              at show_constraints.hs:3:1-22)
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="partial-type-signatures">
<span id="id57"></span><h1>10.23. Partial Type Signatures<a class="headerlink" href="#partial-type-signatures" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XPartialTypeSignatures">
<code class="descname">-XPartialTypeSignatures</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XPartialTypeSignatures" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.10.1</td>
</tr>
</tbody>
</table>
<p>Type checker will allow inferred types for holes.</p>
</dd></dl>

<p>A partial type signature is a type signature containing special
placeholders written with a leading underscore (e.g., &#8220;<code class="docutils literal"><span class="pre">_</span></code>&#8221;,
&#8220;<code class="docutils literal"><span class="pre">_foo</span></code>&#8221;, &#8220;<code class="docutils literal"><span class="pre">_bar</span></code>&#8221;) called <em>wildcards</em>. Partial type signatures are
to type signatures what <a class="reference internal" href="#typed-holes"><span>Typed Holes</span></a> are to expressions. During
compilation these wildcards or holes will generate an error message that
describes which type was inferred at the hole&#8217;s location, and
information about the origin of any free type variables. GHC reports
such error messages by default.</p>
<p>Unlike <a class="reference internal" href="#typed-holes"><span>Typed Holes</span></a>, which make the program incomplete and will
generate errors when they are evaluated, this needn&#8217;t be the case for
holes in type signatures. The type checker is capable (in most cases) of
type-checking a binding with or without a type signature. A partial type
signature bridges the gap between the two extremes, the programmer can
choose which parts of a type to annotate and which to leave over to the
type-checker to infer.</p>
<p>By default, the type-checker will report an error message for each hole
in a partial type signature, informing the programmer of the inferred
type. When the <a class="reference internal" href="#ghc-flag--XPartialTypeSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPartialTypeSignatures</span></code></a> flag is enabled, the
type-checker will accept the inferred type for each hole, generating
warnings instead of errors. Additionally, these warnings can be silenced
with the <a class="reference internal" href="using-warnings.html#ghc-flag--Wpartial-type-signatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wno-partial-type-signatures</span></code></a>
flag.</p>
<p>However, because GHC must <em>infer</em> the type when part of a type is left
out, it is unable to use polymorphic recursion. The same restriction
takes place when the type signature is omitted completely.</p>
<div class="section" id="syntax">
<span id="pts-syntax"></span><h2>10.23.1. Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h2>
<p>A (partial) type signature has the following form:
<code class="docutils literal"><span class="pre">forall</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">..</span> <span class="pre">.</span> <span class="pre">(C1,</span> <span class="pre">C2,</span> <span class="pre">..)</span> <span class="pre">=&gt;</span> <span class="pre">tau</span></code>. It consists of three parts:</p>
<ul class="simple">
<li>The type variables:
<code class="docutils literal"><span class="pre">a</span> <span class="pre">b</span> <span class="pre">..</span></code></li>
<li>The constraints:
<code class="docutils literal"><span class="pre">(C1,</span> <span class="pre">C2,</span> <span class="pre">..)</span></code></li>
<li>The (mono)type:
<code class="docutils literal"><span class="pre">tau</span></code></li>
</ul>
<p>We distinguish three kinds of wildcards.</p>
<div class="section" id="type-wildcards">
<span id="id58"></span><h3>10.23.1.1. Type Wildcards<a class="headerlink" href="#type-wildcards" title="Permalink to this headline">¶</a></h3>
<p>Wildcards occurring within the monotype (tau) part of the type signature
are <em>type wildcards</em> (&#8220;type&#8221; is often omitted as this is the default
kind of wildcard). Type wildcards can be instantiated to any monotype
like <code class="docutils literal"><span class="pre">Bool</span></code> or <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">[Bool]</span></code>, including functions and higher-kinded
types like <code class="docutils literal"><span class="pre">(Int</span> <span class="pre">-&gt;</span> <span class="pre">Bool)</span></code> or <code class="docutils literal"><span class="pre">Maybe</span></code>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">not&#39;</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kr">_</span>
<span class="nf">not&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">not</span> <span class="n">x</span>
<span class="c1">-- Inferred: Bool -&gt; Bool</span>

<span class="nf">maybools</span> <span class="ow">::</span> <span class="kr">_</span>
<span class="nf">maybools</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">[</span><span class="kt">True</span><span class="p">]</span>
<span class="c1">-- Inferred: Maybe [Bool]</span>

<span class="nf">just1</span> <span class="ow">::</span> <span class="kr">_</span> <span class="kt">Int</span>
<span class="nf">just1</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="mi">1</span>
<span class="c1">-- Inferred: Maybe Int</span>

<span class="nf">filterInt</span> <span class="ow">::</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">filterInt</span> <span class="ow">=</span> <span class="n">filter</span> <span class="c1">-- has type forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]</span>
<span class="c1">-- Inferred: (Int -&gt; Bool) -&gt; [Int] -&gt; [Int]</span>
</pre></div>
</div>
<p>For instance, the first wildcard in the type signature <code class="docutils literal"><span class="pre">not'</span></code> would
produce the following error message:</p>
<div class="highlight-none"><div class="highlight"><pre>Test.hs:4:17: error:
    • Found type wildcard ‘_’ standing for ‘Bool’
      To use the inferred type, enable PartialTypeSignatures
    • In the type signature:
        not&#39; :: Bool -&gt; _
    • Relevant bindings include
        not&#39; :: Bool -&gt; Bool (bound at Test.hs:5:1)
</pre></div>
</div>
<p>When a wildcard is not instantiated to a monotype, it will be
generalised over, i.e. replaced by a fresh type variable, e.g.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foo</span> <span class="ow">::</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kr">_</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
<span class="c1">-- Inferred: forall t. t -&gt; t</span>

<span class="nf">filter&#39;</span> <span class="ow">::</span> <span class="kr">_</span>
<span class="nf">filter&#39;</span> <span class="ow">=</span> <span class="n">filter</span> <span class="c1">-- has type forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]</span>
<span class="c1">-- Inferred: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span>
</pre></div>
</div>
</div>
<div class="section" id="named-wildcards">
<span id="id59"></span><h3>10.23.1.2. Named Wildcards<a class="headerlink" href="#named-wildcards" title="Permalink to this headline">¶</a></h3>
<dl class="ghc-flag">
<dt id="ghc-flag--XNamedWildCards">
<code class="descname">-XNamedWildCards</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XNamedWildCards" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.10.1</td>
</tr>
</tbody>
</table>
<p>Allow naming of wildcards (e.g. <code class="docutils literal"><span class="pre">_x</span></code>) in type signatures.</p>
</dd></dl>

<p>Type wildcards can also be named by giving the underscore an identifier
as suffix, i.e. <code class="docutils literal"><span class="pre">_a</span></code>. These are called <em>named wildcards</em>. All
occurrences of the same named wildcard within one type signature will
unify to the same type. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="n">_x</span> <span class="ow">-&gt;</span> <span class="n">_x</span>
<span class="nf">f</span> <span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="sc">&#39;d&#39;</span><span class="p">,</span> <span class="ne">error</span> <span class="s">&quot;Urk&quot;</span><span class="p">)</span>
<span class="c1">-- Inferred: forall t. (Char, t) -&gt; (Char, t)</span>
</pre></div>
</div>
<p>The named wildcard forces the argument and result types to be the same.
Lacking a signature, GHC would have inferred
<code class="docutils literal"><span class="pre">forall</span> <span class="pre">a</span> <span class="pre">b.</span> <span class="pre">(Char,</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">(Char,</span> <span class="pre">b)</span></code>. A named wildcard can be
mentioned in constraints, provided it also occurs in the monotype part
of the type signature to make sure that it unifies with something:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">somethingShowable</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">_x</span> <span class="ow">=&gt;</span> <span class="n">_x</span> <span class="ow">-&gt;</span> <span class="kr">_</span>
<span class="nf">somethingShowable</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">x</span>
<span class="c1">-- Inferred type: Show a =&gt; a -&gt; String</span>

<span class="nf">somethingShowable&#39;</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">_x</span> <span class="ow">=&gt;</span> <span class="n">_x</span> <span class="ow">-&gt;</span> <span class="kr">_</span>
<span class="nf">somethingShowable&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">show</span> <span class="p">(</span><span class="n">not</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">-- Inferred type: Bool -&gt; String</span>
</pre></div>
</div>
<p>Besides an extra-constraints wildcard (see
<a class="reference internal" href="#extra-constraints-wildcard"><span>Extra-Constraints Wildcard</span></a>), only named wildcards can occur in
the constraints, e.g. the <code class="docutils literal"><span class="pre">_x</span></code> in <code class="docutils literal"><span class="pre">Show</span> <span class="pre">_x</span></code>.</p>
<p>Named wildcards <em>should not be confused with type variables</em>. Even
though syntactically similar, named wildcards can unify with monotypes
as well as be generalised over (and behave as type variables).</p>
<p>In the first example above, <code class="docutils literal"><span class="pre">_x</span></code> is generalised over (and is
effectively replaced by a fresh type variable <code class="docutils literal"><span class="pre">a</span></code>). In the second
example, <code class="docutils literal"><span class="pre">_x</span></code> is unified with the <code class="docutils literal"><span class="pre">Bool</span></code> type, and as <code class="docutils literal"><span class="pre">Bool</span></code>
implements the <code class="docutils literal"><span class="pre">Show</span></code> type class, the constraint <code class="docutils literal"><span class="pre">Show</span> <span class="pre">Bool</span></code> can be
simplified away.</p>
<p>By default, GHC (as the Haskell 2010 standard prescribes) parses
identifiers starting with an underscore in a type as type variables. To
treat them as named wildcards, the <a class="reference internal" href="#ghc-flag--XNamedWildCards"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNamedWildCards</span></code></a> flag should be
enabled. The example below demonstrated the effect.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foo</span> <span class="ow">::</span> <span class="n">_a</span> <span class="ow">-&gt;</span> <span class="n">_a</span>
<span class="nf">foo</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Compiling this program without enabling <a class="reference internal" href="#ghc-flag--XNamedWildCards"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNamedWildCards</span></code></a> produces
the following error message complaining about the type variable <code class="docutils literal"><span class="pre">_a</span></code>
no matching the actual type <code class="docutils literal"><span class="pre">Bool</span></code>.</p>
<div class="highlight-none"><div class="highlight"><pre>Test.hs:5:9: error:
    • Couldn&#39;t match expected type ‘_a’ with actual type ‘Bool’
      ‘_a’ is a rigid type variable bound by
        the type signature for:
          foo :: forall _a. _a -&gt; _a
        at Test.hs:4:8
    • In the expression: False
      In an equation for ‘foo’: foo _ = False
    • Relevant bindings include foo :: _a -&gt; _a (bound at Test.hs:5:1)
</pre></div>
</div>
<p>Compiling this program with <a class="reference internal" href="#ghc-flag--XNamedWildCards"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XNamedWildCards</span></code></a> (as well as
<a class="reference internal" href="#ghc-flag--XPartialTypeSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPartialTypeSignatures</span></code></a>) enabled produces the following error
message reporting the inferred type of the named wildcard <code class="docutils literal"><span class="pre">_a</span></code>.</p>
<div class="highlight-none"><div class="highlight"><pre>Test.hs:4:8: warning: [-Wpartial-type-signatures]
    • Found type wildcard ‘_a’ standing for ‘Bool’
    • In the type signature:
        foo :: _a -&gt; _a
    • Relevant bindings include
        foo :: Bool -&gt; Bool (bound at Test.hs:5:1)
</pre></div>
</div>
</div>
<div class="section" id="extra-constraints-wildcard">
<span id="id60"></span><h3>10.23.1.3. Extra-Constraints Wildcard<a class="headerlink" href="#extra-constraints-wildcard" title="Permalink to this headline">¶</a></h3>
<p>The third kind of wildcard is the <em>extra-constraints wildcard</em>. The
presence of an extra-constraints wildcard indicates that an arbitrary
number of extra constraints may be inferred during type checking and
will be added to the type signature. In the example below, the
extra-constraints wildcard is used to infer three extra constraints.</p>
<div class="highlight-haskell"><div class="highlight"><pre>arbitCs :: _ =&gt; a -&gt; String
arbitCs x = show (succ x) ++ show (x == x)
-- Inferred:
--   forall a. (Enum a, Eq a, Show a) =&gt; a -&gt; String
-- Error:
Test.hs:5:12: error:
    Found constraint wildcard ‘_’ standing for ‘(Show a, Eq a, Enum a)’
    To use the inferred type, enable PartialTypeSignatures
    In the type signature:
      arbitCs :: _ =&gt; a -&gt; String
</pre></div>
</div>
<p>An extra-constraints wildcard shouldn&#8217;t prevent the programmer from
already listing the constraints he knows or wants to annotate, e.g.</p>
<div class="highlight-haskell"><div class="highlight"><pre>-- Also a correct partial type signature:
arbitCs&#39; :: (Enum a, _) =&gt; a -&gt; String
arbitCs&#39; x = arbitCs x
-- Inferred:
--   forall a. (Enum a, Show a, Eq a) =&gt; a -&gt; String
-- Error:
Test.hs:9:22: error:
    Found constraint wildcard ‘_’ standing for ‘()’
    To use the inferred type, enable PartialTypeSignatures
    In the type signature:
      arbitCs&#39; :: (Enum a, _) =&gt; a -&gt; String
</pre></div>
</div>
<p>An extra-constraints wildcard can also lead to zero extra constraints to
be inferred, e.g.</p>
<div class="highlight-haskell"><div class="highlight"><pre>noCs :: _ =&gt; String
noCs = &quot;noCs&quot;
-- Inferred: String
-- Error:
Test.hs:13:9: error:
    Found constraint wildcard ‘_’ standing for ‘()’
    To use the inferred type, enable PartialTypeSignatures
    In the type signature:
      noCs :: _ =&gt; String
</pre></div>
</div>
<p>As a single extra-constraints wildcard is enough to infer any number of
constraints, only one is allowed in a type signature and it should come
last in the list of constraints.</p>
<p>Extra-constraints wildcards cannot be named.</p>
</div>
</div>
<div class="section" id="where-can-they-occur">
<span id="pts-where"></span><h2>10.23.2. Where can they occur?<a class="headerlink" href="#where-can-they-occur" title="Permalink to this headline">¶</a></h2>
<p>Partial type signatures are allowed for bindings, pattern and expression
signatures, except that extra-constraints
wildcards are not supported in pattern or expression signatures.
In the following example a wildcard is used in each of the three possible contexts.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="kr">_</span>
<span class="nf">foo</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="kr">_</span><span class="p">)</span>
<span class="c1">-- Inferred: forall w_. w_ -&gt; w_</span>
</pre></div>
</div>
<p>Anonymous and named wildcards <em>can</em> occur on the left hand side of a
type or data instance declaration;
see <a class="reference internal" href="#type-wildcards-lhs"><span>Wildcards on the LHS of data and type family instances</span></a>.</p>
<p>Anonymous wildcards are also allowed in visible type applications
(<a class="reference internal" href="#visible-type-application"><span>Visible type application</span></a>). If you want to specify only the second type
argument to <code class="docutils literal"><span class="pre">wurble</span></code>, then you can say <code class="docutils literal"><span class="pre">wurble</span> <span class="pre">&#64;_</span> <span class="pre">&#64;Int</span></code> where the first
argument is a wildcard.</p>
<p>In all other contexts, type wildcards are disallowed, and a named wildcard is treated
as an ordinary type variable.  For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="kr">_</span> <span class="kr">where</span> <span class="o">...</span>          <span class="c1">-- Illegal</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">T</span> <span class="kr">_</span><span class="p">)</span>            <span class="c1">-- Illegal (currently; would actually make sense)</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">_a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">T</span> <span class="n">_a</span><span class="p">)</span>  <span class="c1">-- Perfectly fine, same as  Eq a =&gt; Eq (T a)</span>
</pre></div>
</div>
<p>Partial type signatures can also be used in <a class="reference internal" href="#template-haskell"><span>Template Haskell</span></a>
splices.</p>
<ul>
<li><p class="first">Declaration splices: partial type signature are fully supported.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE TemplateHaskell, NamedWildCards #-}</span>
<span class="o">$</span><span class="p">(</span> <span class="p">[</span><span class="n">d</span><span class="o">|</span> <span class="n">foo</span> <span class="ow">::</span> <span class="kr">_</span> <span class="ow">=&gt;</span> <span class="n">_a</span> <span class="ow">-&gt;</span> <span class="n">_a</span> <span class="ow">-&gt;</span> <span class="kr">_</span>
       <span class="n">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">|</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Expression splices: anonymous and named wildcards can be used in
expression signatures. Extra-constraints wildcards are not supported,
just like in regular expression signatures.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE TemplateHaskell, NamedWildCards #-}</span>
<span class="o">$</span><span class="p">(</span> <span class="p">[</span><span class="n">e</span><span class="o">|</span> <span class="n">foo</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Just</span> <span class="kt">True</span> <span class="ow">::</span> <span class="n">_m</span> <span class="kr">_</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Typed expression splices: the same wildcards as in (untyped)
expression splices are supported.</p>
</li>
<li><p class="first">Pattern splices: anonymous and named wildcards can be used in pattern
signatures. Note that <a class="reference internal" href="#ghc-flag--XScopedTypeVariables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XScopedTypeVariables</span></code></a> has to be enabled
to allow pattern signatures. Extra-constraints wildcards are not supported,
just like in regular pattern signatures.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE TemplateHaskell, ScopedTypeVariables #-}</span>
<span class="nf">foo</span> <span class="o">$</span><span class="p">(</span> <span class="p">[</span><span class="n">p</span><span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="kr">_</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span> <span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div>
</div>
</li>
<li><p class="first">Type splices: only anonymous wildcards are supported in type splices.
Named and extra-constraints wildcards are not.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="o">$</span><span class="p">(</span> <span class="p">[</span><span class="n">t</span><span class="o">|</span> <span class="kr">_</span> <span class="o">|</span><span class="p">]</span> <span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="custom-compile-time-errors">
<span id="custom-errors"></span><h1>10.24. Custom compile-time errors<a class="headerlink" href="#custom-compile-time-errors" title="Permalink to this headline">¶</a></h1>
<p>When designing embedded domain specific languages in Haskell, it is useful to
have something like <code class="docutils literal"><span class="pre">error</span></code> at the type level. In this way, the EDSL designer
may show a type error that is specific to the DSL, rather than the standard GHC
type error.</p>
<p>For example, consider a type class that is not intended to be used with
functions, but the user accidentally used it at a function type, perhaps
because they missed an argument to some function. Then, instead of getting the
standard GHC message about a missing instance, it would be nicer to emit a more
friendly message specific to the EDSL. Similarly, the reduction of a type-level
function may get stuck due to an error, at which point it would be nice to
report an EDSL specific error, rather than a generic error about an ambiguous
type.</p>
<p>To solve this, GHC provides a single type-level function,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">family</span> <span class="kt">TypeError</span> <span class="p">(</span><span class="n">msg</span> <span class="ow">::</span> <span class="kt">ErrorMessage</span><span class="p">)</span> <span class="ow">::</span> <span class="n">k</span>
</pre></div>
</div>
<p>along with a small type-level language (via <a class="reference internal" href="#ghc-flag--XDataKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDataKinds</span></code></a>)
for constructing pretty-printed error messages,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- ErrorMessage is intended to be used as a kind</span>
<span class="kr">data</span> <span class="kt">ErrorMessage</span> <span class="ow">=</span>
      <span class="kt">Text</span> <span class="kt">Symbol</span>                        <span class="c1">-- Show this text as is</span>
    <span class="o">|</span> <span class="n">forall</span> <span class="n">t</span><span class="o">.</span> <span class="kt">ShowType</span> <span class="n">t</span>               <span class="c1">-- Pretty print a type</span>
    <span class="o">|</span> <span class="kt">ErrorMessage</span> <span class="kt">:&lt;&gt;:</span> <span class="kt">ErrorMessage</span>     <span class="c1">-- Put two chunks of error message next to each other</span>
    <span class="o">|</span> <span class="kt">ErrorMessage</span> <span class="kt">:$$:</span> <span class="kt">ErrorMessage</span>     <span class="c1">-- Put two chunks of error message above each other</span>
</pre></div>
</div>
<p>in the <code class="docutils literal"><span class="pre">GHC.TypeLits</span></code> <a class="reference external" href="../libraries/base-4.10.1.0/GHC-TypeLits.html">module</a>.</p>
<p>For instance, we might use this interface to provide a more useful error
message for applications of <code class="docutils literal"><span class="pre">show</span></code> on unsaturated functions like this,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE DataKinds #-}</span>
<span class="cm">{-# LANGUAGE TypeOperators #-}</span>
<span class="cm">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kr">import</span> <span class="nn">GHC.TypeLits</span>

<span class="kr">instance</span> <span class="kt">TypeError</span> <span class="p">(</span><span class="kt">Text</span> <span class="s">&quot;Cannot &#39;Show&#39; functions.&quot;</span> <span class="kt">:$$:</span>
                    <span class="kt">Text</span> <span class="s">&quot;Perhaps there is a missing argument?&quot;</span><span class="p">)</span>
         <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
   <span class="n">showsPrec</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;unreachable&quot;</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="n">negate</span>
</pre></div>
</div>
<p>Which will produce the following compile-time error,</p>
<div class="highlight-none"><div class="highlight"><pre>Test.hs:12:8: error:
    • Cannot &#39;Show&#39; functions.
      Perhaps there is a missing argument?
    • In the expression: print negate
      In an equation for ‘main’: main = print negate
</pre></div>
</div>
</div>
<div class="section" id="deferring-type-errors-to-runtime">
<span id="defer-type-errors"></span><h1>10.25. Deferring type errors to runtime<a class="headerlink" href="#deferring-type-errors-to-runtime" title="Permalink to this headline">¶</a></h1>
<p>While developing, sometimes it is desirable to allow compilation to
succeed even if there are type errors in the code. Consider the
following case:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="nf">a</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">a</span> <span class="ow">=</span> <span class="sc">&#39;a&#39;</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="s">&quot;b&quot;</span>
</pre></div>
</div>
<p>Even though <code class="docutils literal"><span class="pre">a</span></code> is ill-typed, it is not used in the end, so if all
that we&#8217;re interested in is <code class="docutils literal"><span class="pre">main</span></code> it can be useful to be able to
ignore the problems in <code class="docutils literal"><span class="pre">a</span></code>.</p>
<p>For more motivation and details please refer to the
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/wiki/DeferErrorsToRuntime">Wiki</a> page or the <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2012/01/icfp12.pdf">original
paper</a>.</p>
<div class="section" id="enabling-deferring-of-type-errors">
<h2>10.25.1. Enabling deferring of type errors<a class="headerlink" href="#enabling-deferring-of-type-errors" title="Permalink to this headline">¶</a></h2>
<p>The flag <a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-type-errors"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-type-errors</span></code></a> controls whether type errors are
deferred to runtime. Type errors will still be emitted as warnings, but
will not prevent compilation. You can use <a class="reference internal" href="using-warnings.html#ghc-flag--Wtype-errors"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wno-type-errors</span></code></a> to suppress these warnings.</p>
<p>This flag implies the <a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-typed-holes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-typed-holes</span></code></a> and
<a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-out-of-scope-variables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-out-of-scope-variables</span></code></a> flags, which enables this behaviour
for <a class="reference external" href="#typed-holes">typed holes</a> and variables. Should you so wish, it is
possible to enable <a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-type-errors"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-type-errors</span></code></a> without enabling
<a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-typed-holes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-typed-holes</span></code></a> or <a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-out-of-scope-variables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-out-of-scope-variables</span></code></a>,
by explicitly specifying <a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-typed-holes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fno-defer-typed-holes</span></code></a> or <a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-out-of-scope-variables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fno-defer-out-of-scope-variables</span></code></a> on the command-line after the
<a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-type-errors"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-type-errors</span></code></a> flag.</p>
<p>At runtime, whenever a term containing a type error would need to be
evaluated, the error is converted into a runtime exception of type
<code class="docutils literal"><span class="pre">TypeError</span></code>. Note that type errors are deferred as much as possible
during runtime, but invalid coercions are never performed, even when
they would ultimately result in a value of the correct type. For
example, given the following code:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">x</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">x</span> <span class="ow">=</span> <span class="mi">0</span>

<span class="nf">y</span> <span class="ow">::</span> <span class="kt">Char</span>
<span class="nf">y</span> <span class="ow">=</span> <span class="n">x</span>

<span class="nf">z</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">z</span> <span class="ow">=</span> <span class="n">y</span>
</pre></div>
</div>
<p>evaluating <code class="docutils literal"><span class="pre">z</span></code> will result in a runtime <code class="docutils literal"><span class="pre">TypeError</span></code>.</p>
</div>
<div class="section" id="deferred-type-errors-in-ghci">
<h2>10.25.2. Deferred type errors in GHCi<a class="headerlink" href="#deferred-type-errors-in-ghci" title="Permalink to this headline">¶</a></h2>
<p>The flag <a class="reference internal" href="using-warnings.html#ghc-flag--fdefer-type-errors"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fdefer-type-errors</span></code></a> works in GHCi as well, with one
exception: for &#8220;naked&#8221; expressions typed at the prompt, type errors
don&#8217;t get delayed, so for example:</p>
<div class="highlight-haskell"><div class="highlight"><pre>Prelude&gt; fst (True, 1 == &#39;a&#39;)

&lt;interactive&gt;:2:12:
    No instance for (Num Char) arising from the literal `1&#39;
    Possible fix: add an instance declaration for (Num Char)
    In the first argument of `(==)&#39;, namely `1&#39;
    In the expression: 1 == &#39;a&#39;
    In the first argument of `fst&#39;, namely `(True, 1 == &#39;a&#39;)&#39;
</pre></div>
</div>
<p>Otherwise, in the common case of a simple type error such as typing
<code class="docutils literal"><span class="pre">reverse</span> <span class="pre">True</span></code> at the prompt, you would get a warning and then an
immediately-following type error when the expression is evaluated.</p>
<p>This exception doesn&#8217;t apply to statements, as the following example
demonstrates:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; let x = (True, 1 == &#39;a&#39;)

&lt;interactive&gt;:3:16: Warning:
    No instance for (Num Char) arising from the literal `1&#39;
    Possible fix: add an instance declaration for (Num Char)
    In the first argument of `(==)&#39;, namely `1&#39;
    In the expression: 1 == &#39;a&#39;
    In the expression: (True, 1 == &#39;a&#39;)
Prelude&gt; fst x
True
</pre></div>
</div>
</div>
</div>
<div class="section" id="template-haskell">
<span id="id61"></span><h1>10.26. Template Haskell<a class="headerlink" href="#template-haskell" title="Permalink to this headline">¶</a></h1>
<p>Template Haskell allows you to do compile-time meta-programming in
Haskell. The background to the main technical innovations is discussed
in &#8220;<a class="reference external" href="http://research.microsoft.com/~simonpj/papers/meta-haskell/">Template Meta-programming for
Haskell</a>&#8221;
(Proc Haskell Workshop 2002).</p>
<p>The <a class="reference external" href="http://www.haskell.org/haskellwiki/Template_Haskell">Template Haskell</a>
page on the GHC Wiki has a wealth of information. You may also consult the
<a class="reference external" href="../libraries/template-haskell-&#64;LIBRARY_template_haskell_VERSION&#64;/Language-Haskell-TH.html">Haddock reference documentation</a>.
Many changes to the original
design are described in <a class="reference external" href="http://research.microsoft.com/~simonpj/papers/meta-haskell/notes2.ps">Notes on Template Haskell version
2</a>.
Not all of these changes are in GHC, however.</p>
<p>The first example from that paper is set out below (<a class="reference internal" href="#th-example"><span>A Template Haskell Worked Example</span></a>)
as a worked example to help get you started.</p>
<p>The documentation here describes the realisation of Template Haskell in
GHC. It is not detailed enough to understand Template Haskell; see the
<a class="reference external" href="http://haskell.org/haskellwiki/Template_Haskell">Wiki page</a>.</p>
<div class="section" id="th-syntax">
<span id="id62"></span><h2>10.26.1. Syntax<a class="headerlink" href="#th-syntax" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XTemplateHaskell">
<code class="descname">-XTemplateHaskell</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XTemplateHaskell" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">6.0. Typed splices introduced in GHC 7.8.1.</td>
</tr>
<tr class="field-even field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XTemplateHaskellQuotes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTemplateHaskellQuotes</span></code></a></td>
</tr>
</tbody>
</table>
<p>Enable Template Haskell&#8217;s splice and quotation syntax.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--XTemplateHaskellQuotes">
<code class="descname">-XTemplateHaskellQuotes</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XTemplateHaskellQuotes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Enable only Template Haskell&#8217;s quotation syntax.</p>
</dd></dl>

<p>Template Haskell has the following new syntactic constructions. You need to use
the flag <a class="reference internal" href="#ghc-flag--XTemplateHaskell"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTemplateHaskell</span></code></a> to switch these syntactic extensions on.
Alternatively, the <a class="reference internal" href="#ghc-flag--XTemplateHaskellQuotes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTemplateHaskellQuotes</span></code></a> flag can be used to
enable the quotation subset of Template Haskell (i.e. without splice syntax).
The <a class="reference internal" href="#ghc-flag--XTemplateHaskellQuotes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTemplateHaskellQuotes</span></code></a> extension is considered safe under
<a class="reference internal" href="safe_haskell.html#safe-haskell"><span>Safe Haskell</span></a> while <a class="reference internal" href="#ghc-flag--XTemplateHaskell"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XTemplateHaskell</span></code></a> is not.</p>
<ul>
<li><p class="first">A splice is written <code class="docutils literal"><span class="pre">$x</span></code>, where <code class="docutils literal"><span class="pre">x</span></code> is an identifier, or
<code class="docutils literal"><span class="pre">$(...)</span></code>, where the &#8221;...&#8221; is an arbitrary expression. There must be
no space between the &#8220;$&#8221; and the identifier or parenthesis. This use
of &#8220;$&#8221; overrides its meaning as an infix operator, just as &#8220;M.x&#8221;
overrides the meaning of &#8221;.&#8221; as an infix operator. If you want the
infix operator, put spaces around it.</p>
<p>A splice can occur in place of</p>
<ul class="simple">
<li>an expression; the spliced expression must have type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">Exp</span></code></li>
<li>a pattern; the spliced pattern must have type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">Pat</span></code></li>
<li>a type; the spliced expression must have type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">Type</span></code></li>
<li>a list of declarations at top level; the spliced expression must
have type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">[Dec]</span></code></li>
</ul>
<p>Inside a splice you can only call functions defined in imported
modules, not functions defined elsewhere in the same module. Note
that declaration splices are not allowed anywhere except at top level
(outside any other declarations).</p>
</li>
<li><p class="first">A expression quotation is written in Oxford brackets, thus:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">[|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, or <code class="docutils literal"><span class="pre">[e|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, where the &#8221;...&#8221; is an
expression; the quotation has type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">Exp</span></code>.</li>
<li><code class="docutils literal"><span class="pre">[d|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, where the &#8221;...&#8221; is a list of top-level
declarations; the quotation has type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">[Dec]</span></code>.</li>
<li><code class="docutils literal"><span class="pre">[t|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, where the &#8221;...&#8221; is a type; the quotation has type
<code class="docutils literal"><span class="pre">Q</span> <span class="pre">Type</span></code>.</li>
<li><code class="docutils literal"><span class="pre">[p|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, where the &#8221;...&#8221; is a pattern; the quotation has
type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">Pat</span></code>.</li>
</ul>
<p>See <a class="reference internal" href="#pts-where"><span>Where can they occur?</span></a> for using partial type signatures in quotations.</p>
</li>
<li><p class="first">A <em>typed</em> expression splice is written <code class="docutils literal"><span class="pre">$$x</span></code>, where <code class="docutils literal"><span class="pre">x</span></code> is an
identifier, or <code class="docutils literal"><span class="pre">$$(...)</span></code>, where the &#8221;...&#8221; is an arbitrary
expression.</p>
<p>A typed expression splice can occur in place of an expression; the
spliced expression must have type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">(TExp</span> <span class="pre">a)</span></code></p>
</li>
<li><p class="first">A <em>typed</em> expression quotation is written as <code class="docutils literal"><span class="pre">[||</span> <span class="pre">...</span> <span class="pre">||]</span></code>, or
<code class="docutils literal"><span class="pre">[e||</span> <span class="pre">...</span> <span class="pre">||]</span></code>, where the &#8221;...&#8221; is an expression; if the &#8221;...&#8221;
expression has type <code class="docutils literal"><span class="pre">a</span></code>, then the quotation has type
<code class="docutils literal"><span class="pre">Q</span> <span class="pre">(TExp</span> <span class="pre">a)</span></code>.</p>
<p>Values of type <code class="docutils literal"><span class="pre">TExp</span> <span class="pre">a</span></code> may be converted to values of type <code class="docutils literal"><span class="pre">Exp</span></code>
using the function <code class="docutils literal"><span class="pre">unType</span> <span class="pre">::</span> <span class="pre">TExp</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Exp</span></code>.</p>
</li>
<li><p class="first">A quasi-quotation can appear in a pattern, type, expression, or
declaration context and is also written in Oxford brackets:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">[varid|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, where the &#8221;...&#8221; is an arbitrary string; a full
description of the quasi-quotation facility is given in
<a class="reference internal" href="#th-quasiquotation"><span>Template Haskell Quasi-quotation</span></a>.</li>
</ul>
</li>
<li><p class="first">A name can be quoted with either one or two prefix single quotes:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">'f</span></code> has type <code class="docutils literal"><span class="pre">Name</span></code>, and names the function <code class="docutils literal"><span class="pre">f</span></code>. Similarly
<code class="docutils literal"><span class="pre">'C</span></code> has type <code class="docutils literal"><span class="pre">Name</span></code> and names the data constructor <code class="docutils literal"><span class="pre">C</span></code>. In
general <code class="docutils literal"><span class="pre">'</span></code>⟨thing⟩ interprets ⟨thing⟩ in an expression
context.</p>
<p>A name whose second character is a single quote (sadly) cannot be
quoted in this way, because it will be parsed instead as a quoted
character. For example, if the function is called <code class="docutils literal"><span class="pre">f'7</span></code> (which
is a legal Haskell identifier), an attempt to quote it as <code class="docutils literal"><span class="pre">'f'7</span></code>
would be parsed as the character literal <code class="docutils literal"><span class="pre">'f'</span></code> followed by the
numeric literal <code class="docutils literal"><span class="pre">7</span></code>. There is no current escape mechanism in
this (unusual) situation.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">''T</span></code> has type <code class="docutils literal"><span class="pre">Name</span></code>, and names the type constructor <code class="docutils literal"><span class="pre">T</span></code>.
That is, <code class="docutils literal"><span class="pre">''</span></code>⟨thing⟩ interprets ⟨thing⟩ in a type context.</p>
</li>
</ul>
<p>These <code class="docutils literal"><span class="pre">Names</span></code> can be used to construct Template Haskell
expressions, patterns, declarations etc. They may also be given as an
argument to the <code class="docutils literal"><span class="pre">reify</span></code> function.</p>
</li>
<li><p class="first">It is possible for a splice to expand to an expression that contain
names which are not in scope at the site of the splice. As an
example, consider the following code:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Bar</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Language.Haskell.TH</span>

<span class="nf">add1</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="kt">Exp</span>
<span class="nf">add1</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">|</span><span class="p">]</span>
</pre></div>
</div>
<p>Now consider a splice using <code class="docutils literal"><span class="pre">add1</span></code> in a separate
module:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Foo</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Bar</span>

<span class="nf">two</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">two</span> <span class="ow">=</span> <span class="o">$</span><span class="p">(</span><span class="n">add1</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Template Haskell cannot know what the argument to <code class="docutils literal"><span class="pre">add1</span></code> will be at the
function&#8217;s definition site, so a lifting mechanism is used to promote
<code class="docutils literal"><span class="pre">x</span></code> into a value of type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">Exp</span></code>. This functionality is exposed to the
user as the <code class="docutils literal"><span class="pre">Lift</span></code> typeclass in the <code class="docutils literal"><span class="pre">Language.Haskell.TH.Syntax</span></code>
module. If a type has a <code class="docutils literal"><span class="pre">Lift</span></code> instance, then any of its values can be
lifted to a Template Haskell expression:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Lift</span> <span class="n">t</span> <span class="kr">where</span>
    <span class="n">lift</span> <span class="ow">::</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="kt">Exp</span>
</pre></div>
</div>
<p>In general, if GHC sees an expression within Oxford brackets (e.g., <code class="docutils literal"><span class="pre">[|</span>
<span class="pre">foo</span> <span class="pre">bar</span> <span class="pre">|]</span></code>, then GHC looks up each name within the brackets. If a name
is global (e.g., suppose <code class="docutils literal"><span class="pre">foo</span></code> comes from an import or a top-level
declaration), then the fully qualified name is used directly in the
quotation. If the name is local (e.g., suppose <code class="docutils literal"><span class="pre">bar</span></code> is bound locally in
the function definition <code class="docutils literal"><span class="pre">mkFoo</span> <span class="pre">bar</span> <span class="pre">=</span> <span class="pre">[|</span> <span class="pre">foo</span> <span class="pre">bar</span> <span class="pre">|]</span></code>), then GHC uses
<code class="docutils literal"><span class="pre">lift</span></code> on it (so GHC pretends <code class="docutils literal"><span class="pre">[|</span> <span class="pre">foo</span> <span class="pre">bar</span> <span class="pre">|]</span></code> actually contains <code class="docutils literal"><span class="pre">[|</span>
<span class="pre">foo</span> <span class="pre">$(lift</span> <span class="pre">bar)</span> <span class="pre">|]</span></code>). Local names, which are not in scope at splice
locations, are actually evaluated when the quotation is processed.</p>
<p>The <code class="docutils literal"><span class="pre">template-haskell</span></code> library provides <code class="docutils literal"><span class="pre">Lift</span></code> instances for many
common data types. Furthermore, it is possible to derive <code class="docutils literal"><span class="pre">Lift</span></code>
instances automatically by using the <a class="reference internal" href="#ghc-flag--XDeriveLift"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveLift</span></code></a> language extension.
See <a class="reference internal" href="#deriving-lift"><span>Deriving Lift instances</span></a> for more information.</p>
</li>
<li><p class="first">You may omit the <code class="docutils literal"><span class="pre">$(...)</span></code> in a top-level declaration splice. Simply
writing an expression (rather than a declaration) implies a splice.
For example, you can write</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Foo</span> <span class="kr">where</span>
<span class="kr">import</span> <span class="nn">Bar</span>

<span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>

<span class="o">$</span><span class="p">(</span><span class="n">deriveStuff</span> <span class="n">&#39;f</span><span class="p">)</span>   <span class="c1">-- Uses the $(...) notation</span>

<span class="nf">g</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span>

<span class="nf">deriveStuff</span> <span class="n">&#39;g</span>      <span class="c1">-- Omits the $(...)</span>

<span class="nf">h</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">z</span><span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>This abbreviation makes top-level declaration slices quieter and less
intimidating.</p>
</li>
<li><p class="first">Pattern splices introduce variable binders but scoping of variables in
expressions inside the pattern&#8217;s scope is only checked when a splice is
run.  Note that pattern splices that occur outside of any quotation
brackets are run at compile time.  Pattern splices occurring inside a
quotation bracket are <em>not</em> run at compile time; they are run when the
bracket is spliced in, sometime later.  For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">mkPat</span> <span class="ow">::</span> <span class="kt">Q</span> <span class="kt">Pat</span>
<span class="nf">mkPat</span> <span class="ow">=</span> <span class="p">[</span><span class="n">p</span><span class="o">|</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span>

<span class="c1">-- in another module:</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Char</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">foo</span> <span class="o">$</span><span class="p">(</span><span class="n">mkPat</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">z</span>

<span class="nf">bar</span> <span class="ow">::</span> <span class="kt">Q</span> <span class="kt">Exp</span>
<span class="nf">bar</span> <span class="ow">=</span> <span class="p">[</span><span class="o">|</span> <span class="nf">\</span> <span class="o">$</span><span class="p">(</span><span class="n">mkPat</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">w</span> <span class="o">|</span><span class="p">]</span>
</pre></div>
</div>
<p>will fail with <code class="docutils literal"><span class="pre">z</span></code> being out of scope in the definition of <code class="docutils literal"><span class="pre">foo</span></code> but it
will <em>not</em> fail with <code class="docutils literal"><span class="pre">w</span></code> being out of scope in the definition of <code class="docutils literal"><span class="pre">bar</span></code>.
That will only happen when <code class="docutils literal"><span class="pre">bar</span></code> is spliced.</p>
</li>
<li><p class="first">A pattern quasiquoter <em>may</em> generate binders that scope over the
right-hand side of a definition because these binders are in scope
lexically. For example, given a quasiquoter <code class="docutils literal"><span class="pre">haskell</span></code> that parses
Haskell, in the following code, the <code class="docutils literal"><span class="pre">y</span></code> in the right-hand side of
<code class="docutils literal"><span class="pre">f</span></code> refers to the <code class="docutils literal"><span class="pre">y</span></code> bound by the <code class="docutils literal"><span class="pre">haskell</span></code> pattern
quasiquoter, <em>not</em> the top-level <code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">7</span></code>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">y</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">y</span> <span class="ow">=</span> <span class="mi">7</span>

<span class="nf">f</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">f</span> <span class="n">n</span> <span class="ow">=</span> <span class="nf">\</span> <span class="p">[</span><span class="n">haskell</span><span class="o">|</span><span class="n">y</span><span class="o">|</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">y</span><span class="o">+</span><span class="n">n</span>
</pre></div>
</div>
</li>
<li><p class="first">Top-level declaration splices break up a source file into
<em>declaration groups</em>. A <em>declaration group</em> is the group of
declarations created by a top-level declaration splice, plus those
following it, down to but not including the next top-level
declaration splice. N.B. only top-level splices delimit declaration
groups, not expression splices. The first declaration group in a module
includes all top-level definitions down to but not including the first
top-level declaration splice.</p>
<p>Each declaration group is mutually recursive only within the group.
Declaration groups can refer to definitions within previous groups,
but not later ones.</p>
<p>Accordingly, the type environment seen by <code class="docutils literal"><span class="pre">reify</span></code> includes all the
top-level declarations up to the end of the immediately preceding
declaration group, but no more.</p>
<p>Unlike normal declaration splices, declaration quasiquoters do not
cause a break. These quasiquoters are expanded before the rest of the
declaration group is processed, and the declarations they generate
are merged into the surrounding declaration group. Consequently, the
type environment seen by <code class="docutils literal"><span class="pre">reify</span></code> from a declaration quasiquoter
will not include anything from the quasiquoter&#8217;s declaration group.</p>
<p>Concretely, consider the following code</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">M</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">...</span>

<span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>

<span class="o">$</span><span class="p">(</span><span class="n">th1</span> <span class="mi">4</span><span class="p">)</span>

<span class="nf">h</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">k</span> <span class="n">y</span> <span class="n">y</span> <span class="o">$</span><span class="p">(</span><span class="n">blah1</span><span class="p">)</span>

<span class="p">[</span><span class="n">qq</span><span class="o">|</span><span class="n">blah</span><span class="o">|</span><span class="p">]</span>

<span class="nf">k</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>

<span class="o">$</span><span class="p">(</span><span class="n">th2</span> <span class="mi">10</span><span class="p">)</span>

<span class="nf">w</span> <span class="n">z</span> <span class="ow">=</span> <span class="o">$</span><span class="p">(</span><span class="n">blah2</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, a <code class="docutils literal"><span class="pre">reify</span></code> inside...</p>
<ol class="arabic simple">
<li>The splice <code class="docutils literal"><span class="pre">$(th1</span> <span class="pre">...)</span></code> would see the definition of <code class="docutils literal"><span class="pre">f</span></code> - the
splice is top-level and thus all definitions in the previous
declaration group are visible (that is, all definitions in the module
up-to, but not including, the splice itself).</li>
<li>The splice <code class="docutils literal"><span class="pre">$(blah1)</span></code> cannot refer to the function <code class="docutils literal"><span class="pre">w</span></code> - <code class="docutils literal"><span class="pre">w</span></code> is
part of a later declaration group, and thus invisible, similarly,
<code class="docutils literal"><span class="pre">$(blah1)</span></code> cannot see the definition of <code class="docutils literal"><span class="pre">h</span></code> (since it is part of
the same declaration group as <code class="docutils literal"><span class="pre">$(blah1)</span></code>. However, the splice
<code class="docutils literal"><span class="pre">$(blah1)</span></code> can see the definition of <code class="docutils literal"><span class="pre">f</span></code> (since it is in the
immediately preceding declaration group).</li>
<li>The splice <code class="docutils literal"><span class="pre">$(th2</span> <span class="pre">...)</span></code> would see the definition of <code class="docutils literal"><span class="pre">f</span></code>, all the
bindings created by <code class="docutils literal"><span class="pre">$(th1</span> <span class="pre">...)</span></code>, the definition of <code class="docutils literal"><span class="pre">h</span></code> and all
bindings created by <code class="docutils literal"><span class="pre">[qq|blah|]</span></code> (they are all in previous
declaration groups).</li>
<li>The body of <code class="docutils literal"><span class="pre">h</span></code> <em>can</em> refer to the function <code class="docutils literal"><span class="pre">k</span></code> appearing on the
other side of the declaration quasiquoter, as quasiquoters do not
cause a declaration group to be broken up.</li>
<li>The <code class="docutils literal"><span class="pre">qq</span></code> quasiquoter would be able to see the definition of <code class="docutils literal"><span class="pre">f</span></code>
from the preceding declaration group, but not the definitions of
<code class="docutils literal"><span class="pre">h</span></code> or <code class="docutils literal"><span class="pre">k</span></code>, or any definitions from subsequent declaration
groups.</li>
<li>The splice <code class="docutils literal"><span class="pre">$(blah2)</span></code> would see the same definitions as the splice
<code class="docutils literal"><span class="pre">$(th2</span> <span class="pre">...)</span></code> (but <em>not</em> any bindings it creates).</li>
</ol>
<p>Note that since an expression splice is unable to refer to declarations
in the same declaration group, we can introduce a top-level (empty)
splice to break up the declaration group</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">M</span> <span class="kr">where</span>

<span class="kr">data</span> <span class="kt">D</span> <span class="ow">=</span> <span class="kt">C1</span> <span class="o">|</span> <span class="kt">C2</span>

<span class="nf">f1</span> <span class="ow">=</span> <span class="o">$</span><span class="p">(</span><span class="n">th1</span> <span class="o">...</span><span class="p">)</span>

<span class="o">$</span><span class="p">(</span><span class="n">return</span> <span class="kt">[]</span><span class="p">)</span>

<span class="nf">f2</span> <span class="ow">=</span> <span class="o">$</span><span class="p">(</span><span class="n">th2</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>Here</p>
<ol class="arabic simple">
<li>The splice <code class="docutils literal"><span class="pre">$(th1</span> <span class="pre">...)</span></code> <em>cannot</em> refer to <code class="docutils literal"><span class="pre">D</span></code> - it is in the same
declaration group.</li>
<li>The declaration group containing <code class="docutils literal"><span class="pre">D</span></code> is terminated by the empty
top-level declaration splice <code class="docutils literal"><span class="pre">$(return</span> <span class="pre">[])</span></code> (recall, <code class="docutils literal"><span class="pre">Q</span></code> is a
Monad, so we may simply <code class="docutils literal"><span class="pre">return</span></code> the empty list of declarations).</li>
<li>Since the declaration group containing <code class="docutils literal"><span class="pre">D</span></code> is in the previous
declaration group, the splice <code class="docutils literal"><span class="pre">$(th2</span> <span class="pre">...)</span></code> <em>can</em> refer to <code class="docutils literal"><span class="pre">D</span></code>.</li>
</ol>
</li>
<li><p class="first">Expression quotations accept most Haskell language constructs.
However, there are some GHC-specific extensions which expression
quotations currently do not support, including</p>
<ul class="simple">
<li>Recursive <code class="docutils literal"><span class="pre">do</span></code>-statements (see <a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/1262">Trac #1262</a>)</li>
<li>Type holes in typed splices (see <a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/10945">Trac #10945</a> and
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/10946">Trac #10946</a>)</li>
</ul>
</li>
</ul>
<p>(Compared to the original paper, there are many differences of detail.
The syntax for a declaration splice uses &#8220;<code class="docutils literal"><span class="pre">$</span></code>&#8221; not &#8220;<code class="docutils literal"><span class="pre">splice</span></code>&#8221;. The type of
the enclosed expression must be <code class="docutils literal"><span class="pre">Q</span> <span class="pre">[Dec]</span></code>, not <code class="docutils literal"><span class="pre">[Q</span> <span class="pre">Dec]</span></code>. Typed expression
splices and quotations are supported.)</p>
</div>
<div class="section" id="using-template-haskell">
<span id="th-usage"></span><h2>10.26.2. Using Template Haskell<a class="headerlink" href="#using-template-haskell" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">The data types and monadic constructor functions for Template Haskell
are in the library <code class="docutils literal"><span class="pre">Language.Haskell.TH.Syntax</span></code>.</p>
</li>
<li><p class="first">You can only run a function at compile time if it is imported from
another module. That is, you can&#8217;t define a function in a module, and
call it from within a splice in the same module. (It would make sense
to do so, but it&#8217;s hard to implement.)</p>
</li>
<li><p class="first">You can only run a function at compile time if it is imported from
another module <em>that is not part of a mutually-recursive group of
modules that includes the module currently being compiled</em>.
Furthermore, all of the modules of the mutually-recursive group must
be reachable by non-SOURCE imports from the module where the splice
is to be run.</p>
<p>For example, when compiling module A, you can only run Template
Haskell functions imported from B if B does not import A (directly or
indirectly). The reason should be clear: to run B we must compile and
run A, but we are currently type-checking A.</p>
</li>
<li><p class="first">If you are building GHC from source, you need at least a stage-2
bootstrap compiler to run Template Haskell splices and quasi-quotes.
A stage-1 compiler will only accept regular quotes of Haskell.
Reason: TH splices and quasi-quotes compile and run a program, and
then looks at the result. So it&#8217;s important that the program it
compiles produces results whose representations are identical to
those of the compiler itself.</p>
</li>
</ul>
<p>Template Haskell works in any mode (<a class="reference internal" href="using.html#ghc-flag---make"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--make</span></code></a>,
<a class="reference internal" href="using.html#ghc-flag---interactive"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--interactive</span></code></a>, or file-at-a-time). There used to be a restriction to
the former two, but that restriction has been lifted.</p>
</div>
<div class="section" id="viewing-template-haskell-generated-code">
<span id="th-view-gen-code"></span><h2>10.26.3. Viewing Template Haskell generated code<a class="headerlink" href="#viewing-template-haskell-generated-code" title="Permalink to this headline">¶</a></h2>
<p>The flag <a class="reference internal" href="debugging.html#ghc-flag--ddump-splices"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-splices</span></code></a> shows the expansion of all top-level
declaration splices, both typed and untyped, as they happen. As with all
dump flags, the default is for this output to be sent to stdout. For a
non-trivial program, you may be interested in combining this with the
<a class="reference internal" href="debugging.html#ghc-flag--ddump-to-file"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-to-file</span></code></a> flag (see <a class="reference internal" href="debugging.html#dumping-output"><span>Dumping out compiler intermediate structures</span></a>. For each file using
Template Haskell, this will show the output in a <code class="docutils literal"><span class="pre">.dump-splices</span></code> file.</p>
<p>The flag <a class="reference internal" href="debugging.html#ghc-flag--dth-dec-file=⟨file⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dth-dec-file=⟨file⟩</span></code></a> shows the expansions of all top-level
TH declaration splices, both typed and untyped, in the file <code class="file docutils literal"><span class="pre">M.th.hs</span></code>
where M is the name of the module being compiled. Note that other types of
splices (expressions, types, and patterns) are not shown. Application
developers can check this into their repository so that they can grep for
identifiers that were defined in Template Haskell. This is similar to using
<a class="reference internal" href="debugging.html#ghc-flag--ddump-to-file"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-to-file</span></code></a> with <a class="reference internal" href="debugging.html#ghc-flag--ddump-splices"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-splices</span></code></a> but it always
generates a file instead of being coupled to <a class="reference internal" href="debugging.html#ghc-flag--ddump-to-file"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-to-file</span></code></a>. The
format is also different: it does not show code from the original file, instead
it only shows generated code and has a comment for the splice location of the
original file.</p>
<p>Below is a sample output of <a class="reference internal" href="debugging.html#ghc-flag--ddump-splices"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-splices</span></code></a></p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">TH_pragma</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">26</span><span class="p">)</span><span class="kt">:</span> <span class="kt">Splicing</span> <span class="n">declarations</span>
  <span class="p">[</span><span class="n">d</span><span class="o">|</span> <span class="n">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
      <span class="n">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">|</span><span class="p">]</span>
<span class="o">======&gt;</span>
  <span class="n">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
  <span class="n">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Below is the output of the same sample using <a class="reference internal" href="debugging.html#ghc-flag--dth-dec-file=⟨file⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dth-dec-file=⟨file⟩</span></code></a></p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- TH_pragma.hs:(6,4)-(8,26): Splicing declarations</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="a-template-haskell-worked-example">
<span id="th-example"></span><h2>10.26.4. A Template Haskell Worked Example<a class="headerlink" href="#a-template-haskell-worked-example" title="Permalink to this headline">¶</a></h2>
<p>To help you get over the confidence barrier, try out this skeletal
worked example. First cut and paste the two modules below into <code class="file docutils literal"><span class="pre">Main.hs</span></code>
and <code class="file docutils literal"><span class="pre">Printf.hs</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{- Main.hs -}</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="c1">-- Import our template &quot;pr&quot;</span>
<span class="kr">import</span> <span class="nn">Printf</span> <span class="p">(</span> <span class="nf">pr</span> <span class="p">)</span>

<span class="c1">-- The splice operator $ takes the Haskell source code</span>
<span class="c1">-- generated at compile time by &quot;pr&quot; and splices it into</span>
<span class="c1">-- the argument of &quot;putStrLn&quot;.</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="p">(</span> <span class="o">$</span><span class="p">(</span><span class="n">pr</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span> <span class="p">)</span>


<span class="cm">{- Printf.hs -}</span>
<span class="kr">module</span> <span class="nn">Printf</span> <span class="kr">where</span>

<span class="c1">-- Skeletal printf from the paper.</span>
<span class="c1">-- It needs to be in a separate module to the one where</span>
<span class="c1">-- you intend to use it.</span>

<span class="c1">-- Import some Template Haskell syntax</span>
<span class="kr">import</span> <span class="nn">Language.Haskell.TH</span>

<span class="c1">-- Describe a format string</span>
<span class="kr">data</span> <span class="kt">Format</span> <span class="ow">=</span> <span class="kt">D</span> <span class="o">|</span> <span class="kt">S</span> <span class="o">|</span> <span class="kt">L</span> <span class="kt">String</span>

<span class="c1">-- Parse a format string.  This is left largely to you</span>
<span class="c1">-- as we are here interested in building our first ever</span>
<span class="c1">-- Template Haskell program and not in building printf.</span>
<span class="nf">parse</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Format</span><span class="p">]</span>
<span class="nf">parse</span> <span class="n">s</span>   <span class="ow">=</span> <span class="p">[</span> <span class="kt">L</span> <span class="n">s</span> <span class="p">]</span>

<span class="c1">-- Generate Haskell source code from a parsed representation</span>
<span class="c1">-- of the format string.  This code will be spliced into</span>
<span class="c1">-- the module which calls &quot;pr&quot;, at compile time.</span>
<span class="nf">gen</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Format</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="kt">Exp</span>
<span class="nf">gen</span> <span class="p">[</span><span class="kt">D</span><span class="p">]</span>   <span class="ow">=</span> <span class="p">[</span><span class="o">|</span> <span class="nf">\</span><span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">show</span> <span class="n">n</span> <span class="o">|</span><span class="p">]</span>
<span class="nf">gen</span> <span class="p">[</span><span class="kt">S</span><span class="p">]</span>   <span class="ow">=</span> <span class="p">[</span><span class="o">|</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="o">|</span><span class="p">]</span>
<span class="nf">gen</span> <span class="p">[</span><span class="kt">L</span> <span class="n">s</span><span class="p">]</span> <span class="ow">=</span> <span class="n">stringE</span> <span class="n">s</span>

<span class="c1">-- Here we generate the Haskell code for the splice</span>
<span class="c1">-- from an input format string.</span>
<span class="nf">pr</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="kt">Exp</span>
<span class="nf">pr</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">gen</span> <span class="p">(</span><span class="n">parse</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Now run the compiler,</p>
<div class="highlight-none"><div class="highlight"><pre>$ ghc --make -XTemplateHaskell main.hs -o main
</pre></div>
</div>
<p>Run <code class="file docutils literal"><span class="pre">main</span></code> and here is your output:</p>
<div class="highlight-none"><div class="highlight"><pre>$ ./main
Hello
</pre></div>
</div>
</div>
<div class="section" id="using-template-haskell-with-profiling">
<span id="th-profiling"></span><h2>10.26.5. Using Template Haskell with Profiling<a class="headerlink" href="#using-template-haskell-with-profiling" title="Permalink to this headline">¶</a></h2>
<p id="index-18">Template Haskell relies on GHC&#8217;s built-in bytecode compiler and
interpreter to run the splice expressions. The bytecode interpreter runs
the compiled expression on top of the same runtime on which GHC itself
is running; this means that the compiled code referred to by the
interpreted expression must be compatible with this runtime, and in
particular this means that object code that is compiled for profiling
<em>cannot</em> be loaded and used by a splice expression, because profiled
object code is only compatible with the profiling version of the
runtime.</p>
<p>This causes difficulties if you have a multi-module program containing
Template Haskell code and you need to compile it for profiling, because
GHC cannot load the profiled object code and use it when executing the
splices.</p>
<p>Fortunately GHC provides two workarounds.</p>
<p>The first option is to compile the program twice:</p>
<ol class="arabic">
<li><p class="first">Compile the program or library first the normal way, without
<a class="reference internal" href="profiling.html#ghc-flag--prof"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-prof</span></code></a>.</p>
</li>
<li><p class="first">Then compile it again with <a class="reference internal" href="profiling.html#ghc-flag--prof"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-prof</span></code></a>, and additionally use <code class="docutils literal"><span class="pre">-osuf</span>
<span class="pre">p_o</span></code> to name the object files differently (you can choose any suffix that
isn&#8217;t the normal object suffix here). GHC will automatically load the object
files built in the first step when executing splice expressions. If you omit
the <a class="reference internal" href="separate_compilation.html#ghc-flag--osuf ⟨suffix⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-osuf</span> <span class="pre">⟨suffix⟩</span></code></a> flag when building with <a class="reference internal" href="profiling.html#ghc-flag--prof"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-prof</span></code></a> and
Template Haskell is used, GHC will emit an error message.</p>
</li>
</ol>
<p id="index-19">The second option is to add the flag <a class="reference internal" href="ghci.html#ghc-flag--fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fexternal-interpreter</span></code></a> (see
<a class="reference internal" href="ghci.html#external-interpreter"><span>Running the interpreter in a separate process</span></a>), which runs the interpreter in a separate
process, wherein it can load and run the profiled code directly.
There&#8217;s no need to compile the code twice, just add
<a class="reference internal" href="ghci.html#ghc-flag--fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fexternal-interpreter</span></code></a> and it should just work.  (this option is
experimental in GHC 8.0.x, but it may become the default in future
releases).</p>
</div>
<div class="section" id="template-haskell-quasi-quotation">
<span id="th-quasiquotation"></span><h2>10.26.6. Template Haskell Quasi-quotation<a class="headerlink" href="#template-haskell-quasi-quotation" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XQuasiQuotes">
<code class="descname">-XQuasiQuotes</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XQuasiQuotes" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable Template Haskell Quasi-quotation syntax.</p>
</dd></dl>

<p>Quasi-quotation allows patterns and expressions to be written using
programmer-defined concrete syntax; the motivation behind the extension
and several examples are documented in &#8220;<a class="reference external" href="http://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf">Why It&#8217;s Nice to be Quoted:
Quasiquoting for
Haskell</a>&#8221;
(Proc Haskell Workshop 2007). The example below shows how to write a
quasiquoter for a simple expression language.</p>
<p>Here are the salient features</p>
<ul>
<li><p class="first">A quasi-quote has the form <code class="docutils literal"><span class="pre">[quoter|</span> <span class="pre">string</span> <span class="pre">|]</span></code>.</p>
<ul class="simple">
<li>The ⟨quoter⟩ must be the name of an imported quoter, either
qualified or unqualified; it cannot be an arbitrary expression.</li>
<li>The ⟨quoter⟩ cannot be &#8220;<code class="docutils literal"><span class="pre">e</span></code>&#8221;, &#8220;<code class="docutils literal"><span class="pre">t</span></code>&#8221;, &#8220;<code class="docutils literal"><span class="pre">d</span></code>&#8221;, or &#8220;<code class="docutils literal"><span class="pre">p</span></code>&#8221;,
since those overlap with Template Haskell quotations.</li>
<li>There must be no spaces in the token <code class="docutils literal"><span class="pre">[quoter|</span></code>.</li>
<li>The quoted ⟨string⟩ can be arbitrary, and may contain newlines.</li>
<li>The quoted ⟨string⟩ finishes at the first occurrence of the
two-character sequence <code class="docutils literal"><span class="pre">&quot;|]&quot;</span></code>. Absolutely no escaping is
performed. If you want to embed that character sequence in the
string, you must invent your own escape convention (such as, say,
using the string <code class="docutils literal"><span class="pre">&quot;|~]&quot;</span></code> instead), and make your quoter function
interpret <code class="docutils literal"><span class="pre">&quot;|~]&quot;</span></code> as <code class="docutils literal"><span class="pre">&quot;|]&quot;</span></code>. One way to implement this is to
compose your quoter with a pre-processing pass to perform your
escape conversion. See the discussion in <a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/5348">Trac #5348</a> for details.</li>
</ul>
</li>
<li><p class="first">A quasiquote may appear in place of</p>
<ul class="simple">
<li>An expression</li>
<li>A pattern</li>
<li>A type</li>
<li>A top-level declaration</li>
</ul>
<p>(Only the first two are described in the paper.)</p>
</li>
<li><p class="first">A quoter is a value of type
<code class="docutils literal"><span class="pre">Language.Haskell.TH.Quote.QuasiQuoter</span></code>, which is defined thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">QuasiQuoter</span> <span class="ow">=</span> <span class="kt">QuasiQuoter</span> <span class="p">{</span> <span class="n">quoteExp</span>  <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="kt">Exp</span><span class="p">,</span>
                                 <span class="n">quotePat</span>  <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="kt">Pat</span><span class="p">,</span>
                                 <span class="n">quoteType</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="kt">Type</span><span class="p">,</span>
                                 <span class="n">quoteDec</span>  <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="p">[</span><span class="kt">Dec</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>That is, a quoter is a tuple of four parsers, one for each of the
contexts in which a quasi-quote can occur.</p>
</li>
<li><p class="first">A quasi-quote is expanded by applying the appropriate parser to the
string enclosed by the Oxford brackets. The context of the
quasi-quote (expression, pattern, type, declaration) determines which
of the parsers is called.</p>
</li>
<li><p class="first">Unlike normal declaration splices of the form <code class="docutils literal"><span class="pre">$(...)</span></code>, declaration
quasi-quotes do not cause a declaration group break. See
<a class="reference internal" href="#th-syntax"><span>Syntax</span></a> for more information.</p>
</li>
</ul>
<div class="admonition warning" id="quasi-quotes-list-comprehension-ambiguity">
<p class="first admonition-title">Warning</p>
<p id="index-20"><a class="reference internal" href="#ghc-flag--XQuasiQuotes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XQuasiQuotes</span></code></a> introduces an unfortunate ambiguity with list
comprehension syntax. Consider the following,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">v</span><span class="o">|</span> <span class="n">v</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="p">]]</span>
</pre></div>
</div>
<p class="last">Without <a class="reference internal" href="#ghc-flag--XQuasiQuotes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XQuasiQuotes</span></code></a> this is parsed as a list comprehension.
With <a class="reference internal" href="#ghc-flag--XQuasiQuotes"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XQuasiQuotes</span></code></a> this is parsed as a quasi-quote; however,
this parse will fail due to the lack of a closing <code class="docutils literal"><span class="pre">|]</span></code>. See
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/11679">Trac #11679</a>.</p>
</div>
<p>The example below shows quasi-quotation in action. The quoter <code class="docutils literal"><span class="pre">expr</span></code>
is bound to a value of type <code class="docutils literal"><span class="pre">QuasiQuoter</span></code> defined in module <code class="docutils literal"><span class="pre">Expr</span></code>.
The example makes use of an antiquoted variable <code class="docutils literal"><span class="pre">n</span></code>, indicated by the
syntax <code class="docutils literal"><span class="pre">'int:n</span></code> (this syntax for anti-quotation was defined by the
parser&#8217;s author, <em>not</em> by GHC). This binds <code class="docutils literal"><span class="pre">n</span></code> to the integer value
argument of the constructor <code class="docutils literal"><span class="pre">IntExpr</span></code> when pattern matching. Please
see the referenced paper for further details regarding anti-quotation as
well as the description of a technique that uses SYB to leverage a
single parser of type <code class="docutils literal"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> to generate both an expression
parser that returns a value of type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">Exp</span></code> and a pattern parser that
returns a value of type <code class="docutils literal"><span class="pre">Q</span> <span class="pre">Pat</span></code>.</p>
<p>Quasiquoters must obey the same stage restrictions as Template Haskell,
e.g., in the example, <code class="docutils literal"><span class="pre">expr</span></code> cannot be defined in <code class="docutils literal"><span class="pre">Main.hs</span></code> where it
is used, but must be imported.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{- ------------- file Main.hs --------------- -}</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Expr</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">print</span> <span class="o">$</span> <span class="n">eval</span> <span class="p">[</span><span class="n">expr</span><span class="o">|</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">|</span><span class="p">]</span>
          <span class="p">;</span> <span class="kr">case</span> <span class="kt">IntExpr</span> <span class="mi">1</span> <span class="kr">of</span>
              <span class="p">{</span> <span class="p">[</span><span class="n">expr</span><span class="o">|</span><span class="n">&#39;int</span><span class="kt">:</span><span class="n">n</span><span class="o">|</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">print</span> <span class="n">n</span>
              <span class="p">;</span>  <span class="kr">_</span>              <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>
              <span class="p">}</span>
          <span class="p">}</span>


<span class="cm">{- ------------- file Expr.hs --------------- -}</span>
<span class="kr">module</span> <span class="nn">Expr</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Language.Haskell.TH</span> <span class="k">as</span> <span class="n">TH</span>
<span class="kr">import</span> <span class="nn">Language.Haskell.TH.Quote</span>

<span class="kr">data</span> <span class="kt">Expr</span>  <span class="ow">=</span>  <span class="kt">IntExpr</span> <span class="kt">Integer</span>
           <span class="o">|</span>  <span class="kt">AntiIntExpr</span> <span class="kt">String</span>
           <span class="o">|</span>  <span class="kt">BinopExpr</span> <span class="kt">BinOp</span> <span class="kt">Expr</span> <span class="kt">Expr</span>
           <span class="o">|</span>  <span class="kt">AntiExpr</span> <span class="kt">String</span>
    <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Typeable</span><span class="p">,</span> <span class="kt">Data</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">BinOp</span>  <span class="ow">=</span>  <span class="kt">AddOp</span>
            <span class="o">|</span>  <span class="kt">SubOp</span>
            <span class="o">|</span>  <span class="kt">MulOp</span>
            <span class="o">|</span>  <span class="kt">DivOp</span>
    <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Typeable</span><span class="p">,</span> <span class="kt">Data</span><span class="p">)</span>

<span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">IntExpr</span> <span class="n">n</span><span class="p">)</span>        <span class="ow">=</span> <span class="n">n</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">BinopExpr</span> <span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">opToFun</span> <span class="n">op</span><span class="p">)</span> <span class="p">(</span><span class="n">eval</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">eval</span> <span class="n">y</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">opToFun</span> <span class="kt">AddOp</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
    <span class="n">opToFun</span> <span class="kt">SubOp</span> <span class="ow">=</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span>
    <span class="n">opToFun</span> <span class="kt">MulOp</span> <span class="ow">=</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
    <span class="n">opToFun</span> <span class="kt">DivOp</span> <span class="ow">=</span> <span class="n">div</span>

<span class="nf">expr</span> <span class="ow">=</span> <span class="kt">QuasiQuoter</span> <span class="p">{</span> <span class="n">quoteExp</span> <span class="ow">=</span> <span class="n">parseExprExp</span><span class="p">,</span> <span class="n">quotePat</span> <span class="ow">=</span>  <span class="n">parseExprPat</span> <span class="p">}</span>

<span class="c1">-- Parse an Expr, returning its representation as</span>
<span class="c1">-- either a Q Exp or a Q Pat. See the referenced paper</span>
<span class="c1">-- for how to use SYB to do this by writing a single</span>
<span class="c1">-- parser of type String -&gt; Expr instead of two</span>
<span class="c1">-- separate parsers.</span>

<span class="nf">parseExprExp</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="kt">Exp</span>
<span class="nf">parseExprExp</span> <span class="o">...</span>

<span class="nf">parseExprPat</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Q</span> <span class="kt">Pat</span>
<span class="nf">parseExprPat</span> <span class="o">...</span>
</pre></div>
</div>
<p>Now run the compiler:</p>
<div class="highlight-none"><div class="highlight"><pre>$ ghc --make -XQuasiQuotes Main.hs -o main
</pre></div>
</div>
<p>Run &#8220;main&#8221; and here is your output:</p>
<div class="highlight-none"><div class="highlight"><pre>$ ./main
3
1
</pre></div>
</div>
</div>
</div>
<div class="section" id="arrow-notation">
<span id="id63"></span><h1>10.27. Arrow notation<a class="headerlink" href="#arrow-notation" title="Permalink to this headline">¶</a></h1>
<dl class="ghc-flag">
<dt id="ghc-flag--XArrows">
<code class="descname">-XArrows</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XArrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable arrow notation.</p>
</dd></dl>

<p>Arrows are a generalisation of monads introduced by John Hughes. For
more details, see</p>
<ul class="simple">
<li>“Generalising Monads to Arrows”, John Hughes, in Science of Computer
Programming 37, pp. 67–111, May 2000. The paper that introduced arrows:
a friendly introduction, motivated with programming examples.</li>
<li>“<a class="reference external" href="http://www.soi.city.ac.uk/~ross/papers/notation.html">A New Notation for
Arrows</a>”,
Ross Paterson, in ICFP, Sep 2001. Introduced the notation described
here.</li>
<li>“<a class="reference external" href="http://www.soi.city.ac.uk/~ross/papers/fop.html">Arrows and
Computation</a>”,
Ross Paterson, in The Fun of Programming, Palgrave, 2003.</li>
<li>“<a class="reference external" href="http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf">Programming with
Arrows</a>”, John
Hughes, in 5th International Summer School on Advanced Functional
Programming, Lecture Notes in Computer Science vol. 3622, Springer,
2004. This paper includes another introduction to the notation, with
practical examples.</li>
<li>“<a class="reference external" href="http://www.haskell.org/ghc/docs/papers/arrow-rules.pdf">Type and Translation Rules for Arrow Notation in
GHC</a>”,
Ross Paterson and Simon Peyton Jones, September 16, 2004. A terse
enumeration of the formal rules used (extracted from comments in the
source code).</li>
<li>The arrows web page at
<code class="docutils literal"><span class="pre">http://www.haskell.org/arrows/</span></code> &lt;<a class="reference external" href="http://www.haskell.org/arrows/">http://www.haskell.org/arrows/</a>&gt;`__.</li>
</ul>
<p>With the <a class="reference internal" href="#ghc-flag--XArrows"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XArrows</span></code></a> flag, GHC supports the arrow notation described in
the second of these papers, translating it using combinators from the
<a class="reference external" href="../libraries/base-4.10.1.0/Control-Arrow.html">Control.Arrow</a> module.
What follows is a brief introduction to the notation; it won&#8217;t make much
sense unless you&#8217;ve read Hughes&#8217;s paper.</p>
<p>The extension adds a new kind of expression for defining arrows:</p>
<div class="highlight-none"><div class="highlight"><pre>exp10 ::= ...
       |  proc apat -&gt; cmd
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">proc</span></code> is a new keyword. The variables of the pattern are bound
in the body of the <code class="docutils literal"><span class="pre">proc</span></code>-expression, which is a new sort of thing
called a command. The syntax of commands is as follows:</p>
<div class="highlight-none"><div class="highlight"><pre>cmd   ::= exp10 -&lt;  exp
       |  exp10 -&lt;&lt; exp
       |  cmd0
</pre></div>
</div>
<p>with ⟨cmd⟩<sup>0</sup> up to ⟨cmd⟩<sup>9</sup> defined using infix operators
as for expressions, and</p>
<div class="highlight-none"><div class="highlight"><pre>cmd10 ::= \ apat ... apat -&gt; cmd
       |  let decls in cmd
       |  if exp then cmd else cmd
       |  case exp of { calts }
       |  do { cstmt ; ... cstmt ; cmd }
       |  fcmd

fcmd  ::= fcmd aexp
       |  ( cmd )
       |  (| aexp cmd ... cmd |)

cstmt ::= let decls
       |  pat &lt;- cmd
       |  rec { cstmt ; ... cstmt [;] }
       |  cmd
</pre></div>
</div>
<p>where ⟨calts⟩ are like ⟨alts⟩ except that the bodies are commands
instead of expressions.</p>
<p>Commands produce values, but (like monadic computations) may yield more
than one value, or none, and may do other things as well. For the most
part, familiarity with monadic notation is a good guide to using
commands. However the values of expressions, even monadic ones, are
determined by the values of the variables they contain; this is not
necessarily the case for commands.</p>
<p>A simple example of the new notation is the expression</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">proc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="o">-&lt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>We call this a procedure or arrow abstraction. As with a lambda
expression, the variable <code class="docutils literal"><span class="pre">x</span></code> is a new variable bound within the
<code class="docutils literal"><span class="pre">proc</span></code>-expression. It refers to the input to the arrow. In the above
example, <code class="docutils literal"><span class="pre">-&lt;</span></code> is not an identifier but an new reserved symbol used for
building commands from an expression of arrow type and an expression to
be fed as input to that arrow. (The weird look will make more sense
later.) It may be read as analogue of application for arrows. The above
example is equivalent to the Haskell expression</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">f</span>
</pre></div>
</div>
<p>That would make no sense if the expression to the left of <code class="docutils literal"><span class="pre">-&lt;</span></code>
involves the bound variable <code class="docutils literal"><span class="pre">x</span></code>. More generally, the expression to the
left of <code class="docutils literal"><span class="pre">-&lt;</span></code> may not involve any local variable, i.e. a variable bound
in the current arrow abstraction. For such a situation there is a
variant <code class="docutils literal"><span class="pre">-&lt;&lt;</span></code>, as in</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">proc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&lt;&lt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>which is equivalent to</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">app</span>
</pre></div>
</div>
<p>so in this case the arrow must belong to the <code class="docutils literal"><span class="pre">ArrowApply</span></code> class. Such
an arrow is equivalent to a monad, so if you&#8217;re using this form you may
find a monadic formulation more convenient.</p>
<div class="section" id="do-notation-for-commands">
<h2>10.27.1. do-notation for commands<a class="headerlink" href="#do-notation-for-commands" title="Permalink to this headline">¶</a></h2>
<p>Another form of command is a form of <code class="docutils literal"><span class="pre">do</span></code>-notation. For example, you
can write</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">proc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="o">-&lt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">g</span> <span class="o">-&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span>
        <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
        <span class="n">t</span> <span class="ow">&lt;-</span> <span class="n">h</span> <span class="o">-&lt;</span> <span class="n">x</span><span class="o">*</span><span class="n">z</span>
        <span class="n">returnA</span> <span class="o">-&lt;</span> <span class="n">t</span><span class="o">+</span><span class="n">z</span>
</pre></div>
</div>
<p>You can read this much like ordinary <code class="docutils literal"><span class="pre">do</span></code>-notation, but with commands
in place of monadic expressions. The first line sends the value of
<code class="docutils literal"><span class="pre">x+1</span></code> as an input to the arrow <code class="docutils literal"><span class="pre">f</span></code>, and matches its output against
<code class="docutils literal"><span class="pre">y</span></code>. In the next line, the output is discarded. The arrow <code class="docutils literal"><span class="pre">returnA</span></code>
is defined in the <a class="reference external" href="../libraries/base-4.10.1.0/Control-Arrow.html">Control.Arrow</a> module as <code class="docutils literal"><span class="pre">arr</span>
<span class="pre">id</span></code>. The above example is treated as an abbreviation for</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">first</span> <span class="p">(</span><span class="n">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">first</span> <span class="p">(</span><span class="n">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">g</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">arr</span> <span class="n">snd</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span> <span class="kr">in</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">first</span> <span class="p">(</span><span class="n">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="o">+</span><span class="n">z</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">returnA</span>
</pre></div>
</div>
<p>Note that variables not used later in the composition are projected out.
After simplification using rewrite rules (see <a class="reference internal" href="#rewrite-rules"><span>Rewrite rules</span></a>)
defined in the <a class="reference external" href="../libraries/base-4.10.1.0/Control-Arrow.html">Control.Arrow</a> module, this
reduces to</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">first</span> <span class="n">f</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">first</span> <span class="n">g</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span> <span class="kr">in</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">first</span> <span class="n">h</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="n">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="o">+</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>which is what you might have written by hand. With arrow notation, GHC
keeps track of all those tuples of variables for you.</p>
<p>Note that although the above translation suggests that <code class="docutils literal"><span class="pre">let</span></code>-bound
variables like <code class="docutils literal"><span class="pre">z</span></code> must be monomorphic, the actual translation
produces Core, so polymorphic variables are allowed.</p>
<p>It&#8217;s also possible to have mutually recursive bindings, using the new
<code class="docutils literal"><span class="pre">rec</span></code> keyword, as in the following example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">counter</span> <span class="ow">::</span> <span class="kt">ArrowCircuit</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="kt">Bool</span> <span class="kt">Int</span>
<span class="nf">counter</span> <span class="ow">=</span> <span class="n">proc</span> <span class="n">reset</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">rec</span>     <span class="n">output</span> <span class="ow">&lt;-</span> <span class="n">returnA</span> <span class="o">-&lt;</span> <span class="kr">if</span> <span class="n">reset</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="n">next</span>
                <span class="n">next</span> <span class="ow">&lt;-</span> <span class="n">delay</span> <span class="mi">0</span> <span class="o">-&lt;</span> <span class="n">output</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">returnA</span> <span class="o">-&lt;</span> <span class="n">output</span>
</pre></div>
</div>
<p>The translation of such forms uses the <code class="docutils literal"><span class="pre">loop</span></code> combinator, so the arrow
concerned must belong to the <code class="docutils literal"><span class="pre">ArrowLoop</span></code> class.</p>
</div>
<div class="section" id="conditional-commands">
<h2>10.27.2. Conditional commands<a class="headerlink" href="#conditional-commands" title="Permalink to this headline">¶</a></h2>
<p>In the previous example, we used a conditional expression to construct
the input for an arrow. Sometimes we want to conditionally execute
different commands, as in</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">proc</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span>
        <span class="kr">if</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span>
        <span class="kr">then</span> <span class="n">g</span> <span class="o">-&lt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
        <span class="kr">else</span> <span class="n">h</span> <span class="o">-&lt;</span> <span class="n">y</span><span class="o">+</span><span class="mi">2</span>
</pre></div>
</div>
<p>which is translated to</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="kr">then</span> <span class="kt">Left</span> <span class="n">x</span> <span class="kr">else</span> <span class="kt">Right</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
        <span class="p">(</span><span class="n">arr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">g</span><span class="p">)</span> <span class="o">|||</span> <span class="p">(</span><span class="n">arr</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">y</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the translation uses <code class="docutils literal"><span class="pre">|||</span></code>, the arrow concerned must belong to
the <code class="docutils literal"><span class="pre">ArrowChoice</span></code> class.</p>
<p>There are also <code class="docutils literal"><span class="pre">case</span></code> commands, like</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">input</span> <span class="kr">of</span>
    <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="o">-&lt;</span> <span class="nb">()</span>
    <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="o">-&lt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">x1</span><span class="kt">:</span><span class="n">x2</span><span class="kt">:</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">h</span> <span class="o">-&lt;</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
        <span class="n">ys</span> <span class="ow">&lt;-</span> <span class="n">k</span> <span class="o">-&lt;</span> <span class="n">xs</span>
        <span class="n">returnA</span> <span class="o">-&lt;</span> <span class="n">y</span><span class="kt">:</span><span class="n">ys</span>
</pre></div>
</div>
<p>The syntax is the same as for <code class="docutils literal"><span class="pre">case</span></code> expressions, except that the
bodies of the alternatives are commands rather than expressions. The
translation is similar to that of <code class="docutils literal"><span class="pre">if</span></code> commands.</p>
</div>
<div class="section" id="defining-your-own-control-structures">
<h2>10.27.3. Defining your own control structures<a class="headerlink" href="#defining-your-own-control-structures" title="Permalink to this headline">¶</a></h2>
<p>As we&#8217;re seen, arrow notation provides constructs, modelled on those for
expressions, for sequencing, value recursion and conditionals. But
suitable combinators, which you can define in ordinary Haskell, may also
be used to build new commands out of existing ones. The basic idea is
that a command defines an arrow from environments to values. These
environments assign values to the free local variables of the command.
Thus combinators that produce arrows from arrows may also be used to
build commands from commands. For example, the <code class="docutils literal"><span class="pre">ArrowPlus</span></code> class
includes a combinator</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">ArrowPlus</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="o">&lt;+&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span>
</pre></div>
</div>
<p>so we can use it to build commands:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">expr&#39;</span> <span class="ow">=</span> <span class="n">proc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                <span class="n">returnA</span> <span class="o">-&lt;</span> <span class="n">x</span>
        <span class="o">&lt;+&gt;</span> <span class="kr">do</span>
                <span class="n">symbol</span> <span class="kt">Plus</span> <span class="o">-&lt;</span> <span class="nb">()</span>
                <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">term</span> <span class="o">-&lt;</span> <span class="nb">()</span>
                <span class="n">expr&#39;</span> <span class="o">-&lt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
        <span class="o">&lt;+&gt;</span> <span class="kr">do</span>
                <span class="n">symbol</span> <span class="kt">Minus</span> <span class="o">-&lt;</span> <span class="nb">()</span>
                <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">term</span> <span class="o">-&lt;</span> <span class="nb">()</span>
                <span class="n">expr&#39;</span> <span class="o">-&lt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</pre></div>
</div>
<p>(The <code class="docutils literal"><span class="pre">do</span></code> on the first line is needed to prevent the first <code class="docutils literal"><span class="pre">&lt;+&gt;</span> <span class="pre">...</span></code>
from being interpreted as part of the expression on the previous line.)
This is equivalent to</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">expr&#39;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">proc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">returnA</span> <span class="o">-&lt;</span> <span class="n">x</span><span class="p">)</span>
        <span class="o">&lt;+&gt;</span> <span class="p">(</span><span class="n">proc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                <span class="n">symbol</span> <span class="kt">Plus</span> <span class="o">-&lt;</span> <span class="nb">()</span>
                <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">term</span> <span class="o">-&lt;</span> <span class="nb">()</span>
                <span class="n">expr&#39;</span> <span class="o">-&lt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="o">&lt;+&gt;</span> <span class="p">(</span><span class="n">proc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                <span class="n">symbol</span> <span class="kt">Minus</span> <span class="o">-&lt;</span> <span class="nb">()</span>
                <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">term</span> <span class="o">-&lt;</span> <span class="nb">()</span>
                <span class="n">expr&#39;</span> <span class="o">-&lt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>We are actually using <code class="docutils literal"><span class="pre">&lt;+&gt;</span></code> here with the more specific type</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">ArrowPlus</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="o">&lt;+&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="nb">()</span><span class="p">)</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="nb">()</span><span class="p">)</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="nb">()</span><span class="p">)</span> <span class="n">c</span>
</pre></div>
</div>
<p>It is essential that this operator be polymorphic in <code class="docutils literal"><span class="pre">e</span></code> (representing
the environment input to the command and thence to its subcommands) and
satisfy the corresponding naturality property</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">arr</span> <span class="p">(</span><span class="n">first</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;+&gt;</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">arr</span> <span class="p">(</span><span class="n">first</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;+&gt;</span> <span class="p">(</span><span class="n">arr</span> <span class="p">(</span><span class="n">first</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<p>at least for strict <code class="docutils literal"><span class="pre">k</span></code>. (This should be automatic if you&#8217;re not using
<code class="docutils literal"><span class="pre">seq</span></code>.) This ensures that environments seen by the subcommands are
environments of the whole command, and also allows the translation to
safely trim these environments. (The second component of the input pairs
can contain unnamed input values, as described in the next section.) The
operator must also not use any variable defined within the current arrow
abstraction.</p>
<p>We could define our own operator</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">untilA</span> <span class="ow">::</span> <span class="kt">ArrowChoice</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="nb">()</span>
<span class="nf">untilA</span> <span class="n">body</span> <span class="n">cond</span> <span class="ow">=</span> <span class="n">proc</span> <span class="n">x</span> <span class="ow">-&gt;</span>
        <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">cond</span> <span class="o">-&lt;</span> <span class="n">x</span>
        <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">returnA</span> <span class="o">-&lt;</span> <span class="nb">()</span>
        <span class="kr">else</span> <span class="kr">do</span>
                <span class="n">body</span> <span class="o">-&lt;</span> <span class="n">x</span>
                <span class="n">untilA</span> <span class="n">body</span> <span class="n">cond</span> <span class="o">-&lt;</span> <span class="n">x</span>
</pre></div>
</div>
<p>and use it in the same way. Of course this infix syntax only makes sense
for binary operators; there is also a more general syntax involving
special brackets:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">proc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="o">-&lt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
        <span class="p">(</span><span class="o">|</span><span class="n">untilA</span> <span class="p">(</span><span class="n">increment</span> <span class="o">-&lt;</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="n">within</span> <span class="mf">0.5</span> <span class="o">-&lt;</span> <span class="n">x</span><span class="p">)</span><span class="o">|</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="primitive-constructs">
<h2>10.27.4. Primitive constructs<a class="headerlink" href="#primitive-constructs" title="Permalink to this headline">¶</a></h2>
<p>Some operators will need to pass additional inputs to their subcommands.
For example, in an arrow type supporting exceptions, the operator that
attaches an exception handler will wish to pass the exception that
occurred to the handler. Such an operator might have a type</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">handleA</span> <span class="ow">::</span> <span class="o">...</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="kt">Ex</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">c</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">Ex</span></code> is the type of exceptions handled. You could then use this
with arrow notation by writing a command</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">body</span> <span class="p">`</span><span class="n">handleA</span><span class="p">`</span> <span class="nf">\</span> <span class="n">ex</span> <span class="ow">-&gt;</span> <span class="n">handler</span>
</pre></div>
</div>
<p>so that if an exception is raised in the command <code class="docutils literal"><span class="pre">body</span></code>, the variable
<code class="docutils literal"><span class="pre">ex</span></code> is bound to the value of the exception and the command
<code class="docutils literal"><span class="pre">handler</span></code>, which typically refers to <code class="docutils literal"><span class="pre">ex</span></code>, is entered. Though the
syntax here looks like a functional lambda, we are talking about
commands, and something different is going on. The input to the arrow
represented by a command consists of values for the free local variables
in the command, plus a stack of anonymous values. In all the prior
examples, we made no assumptions about this stack. In the second
argument to <code class="docutils literal"><span class="pre">handleA</span></code>, the value of the exception has been added to
the stack input to the handler. The command form of lambda merely gives
this value a name.</p>
<p>More concretely, the input to a command consists of a pair of an
environment and a stack. Each value on the stack is paired with the
remainder of the stack, with an empty stack being <code class="docutils literal"><span class="pre">()</span></code>. So operators
like <code class="docutils literal"><span class="pre">handleA</span></code> that pass extra inputs to their subcommands can be
designed for use with the notation by placing the values on the stack
paired with the environment in this way. More precisely, the type of
each argument of the operator (and its result) should have the form</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="o">...</span> <span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="nb">()</span><span class="p">)</span><span class="o">...</span><span class="p">))</span> <span class="n">t</span>
</pre></div>
</div>
<p>where ⟨e⟩ is a polymorphic variable (representing the environment) and
⟨ti⟩ are the types of the values on the stack, with ⟨t1⟩ being the
&#8220;top&#8221;. The polymorphic variable ⟨e⟩ must not occur in ⟨a⟩, ⟨ti⟩ or ⟨t⟩.
However the arrows involved need not be the same. Here are some more
examples of suitable operators:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bracketA</span> <span class="ow">::</span> <span class="o">...</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="n">d</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">d</span>
<span class="nf">runReader</span> <span class="ow">::</span> <span class="o">...</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="kt">State</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="n">c</span>
<span class="nf">runState</span> <span class="ow">::</span> <span class="o">...</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="kt">State</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="kt">State</span><span class="p">)</span>
</pre></div>
</div>
<p>We can supply the extra input required by commands built with the last
two by applying them to ordinary expressions, as in</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">proc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">s</span> <span class="ow">&lt;-</span> <span class="o">...</span>
        <span class="p">(</span><span class="o">|</span><span class="n">runReader</span> <span class="p">(</span><span class="kr">do</span> <span class="p">{</span> <span class="o">...</span> <span class="p">})</span><span class="o">|</span><span class="p">)</span> <span class="n">s</span>
</pre></div>
</div>
<p>which adds <code class="docutils literal"><span class="pre">s</span></code> to the stack of inputs to the command built using
<code class="docutils literal"><span class="pre">runReader</span></code>.</p>
<p>The command versions of lambda abstraction and application are analogous
to the expression versions. In particular, the beta and eta rules
describe equivalences of commands. These three features (operators,
lambda abstraction and application) are the core of the notation;
everything else can be built using them, though the results would be
somewhat clumsy. For example, we could simulate <code class="docutils literal"><span class="pre">do</span></code>-notation by
defining</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="ow">::</span> <span class="kt">Arrow</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">c</span>
<span class="nf">u</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">returnA</span> <span class="o">&amp;&amp;&amp;</span> <span class="n">u</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">f</span>

<span class="nf">bind_</span> <span class="ow">::</span> <span class="kt">Arrow</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">c</span>
<span class="nf">u</span> <span class="p">`</span><span class="n">bind_</span><span class="p">`</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">u</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="n">arr</span> <span class="n">fst</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>We could simulate <code class="docutils literal"><span class="pre">if</span></code> by defining</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">cond</span> <span class="ow">::</span> <span class="kt">ArrowChoice</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="kt">Bool</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="n">b</span>
<span class="nf">cond</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="n">arr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="kr">else</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">|||</span> <span class="n">g</span>
</pre></div>
</div>
</div>
<div class="section" id="differences-with-the-paper">
<h2>10.27.5. Differences with the paper<a class="headerlink" href="#differences-with-the-paper" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Instead of a single form of arrow application (arrow tail) with two
translations, the implementation provides two forms <code class="docutils literal"><span class="pre">-&lt;</span></code>
(first-order) and <code class="docutils literal"><span class="pre">-&lt;&lt;</span></code> (higher-order).</li>
<li>User-defined operators are flagged with banana brackets instead of a
new <code class="docutils literal"><span class="pre">form</span></code> keyword.</li>
<li>In the paper and the previous implementation, values on the stack
were paired to the right of the environment in a single argument, but
now the environment and stack are separate arguments.</li>
</ul>
</div>
<div class="section" id="portability">
<h2>10.27.6. Portability<a class="headerlink" href="#portability" title="Permalink to this headline">¶</a></h2>
<p>Although only GHC implements arrow notation directly, there is also a
preprocessor (available from the <a class="reference external" href="http://www.haskell.org/arrows/">arrows web
page</a>) that translates arrow notation
into Haskell 98 for use with other Haskell systems. You would still want
to check arrow programs with GHC; tracing type errors in the
preprocessor output is not easy. Modules intended for both GHC and the
preprocessor must observe some additional restrictions:</p>
<ul class="simple">
<li>The module must import <a class="reference external" href="../libraries/base-4.10.1.0/Control-Arrow.html">Control.Arrow</a>.</li>
<li>The preprocessor cannot cope with other Haskell extensions. These
would have to go in separate modules.</li>
<li>Because the preprocessor targets Haskell (rather than Core),
<code class="docutils literal"><span class="pre">let</span></code>-bound variables are monomorphic.</li>
</ul>
</div>
</div>
<div class="section" id="bang-patterns-and-strict-haskell">
<span id="strict-haskell"></span><span id="bang-patterns"></span><h1>10.28. Bang patterns and Strict Haskell<a class="headerlink" href="#bang-patterns-and-strict-haskell" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-21"></span><p id="index-22">In high-performance Haskell code (e.g. numeric code) eliminating
thunks from an inner loop can be a huge win.
GHC supports three extensions to allow the programmer to specify
use of strict (call-by-value) evalution rather than lazy (call-by-need)
evaluation.</p>
<ul class="simple">
<li>Bang patterns (<a class="reference internal" href="#ghc-flag--XBangPatterns"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XBangPatterns</span></code></a>) makes pattern matching and
let bindings stricter.</li>
<li>Strict data types (<a class="reference internal" href="#ghc-flag--XStrictData"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XStrictData</span></code></a>) makes constructor fields
strict by default, on a per-module basis.</li>
<li>Strict pattern (<a class="reference internal" href="#ghc-flag--XStrict"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XStrict</span></code></a>) makes all patterns and let bindings
strict by default, on a per-module basis.</li>
</ul>
<p>The latter two extensions are simply a way to avoid littering high-performance
code with bang patterns, making it harder to read.</p>
<p>Bang patterns and strict matching do not affect the type system in any way.</p>
<div class="section" id="bang-patterns-informal">
<span id="id64"></span><h2>10.28.1. Bang patterns<a class="headerlink" href="#bang-patterns-informal" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XBangPatterns">
<code class="descname">-XBangPatterns</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XBangPatterns" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow use of bang pattern syntax.</p>
</dd></dl>

<p>GHC supports an extension of pattern matching called <em>bang patterns</em>,
written <code class="docutils literal"><span class="pre">!pat</span></code>. Bang patterns are under consideration for Haskell
Prime. The <a class="reference external" href="http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns">Haskell prime feature
description</a>
contains more discussion and examples than the material below.</p>
<p>The main idea is to add a single new production to the syntax of
patterns:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">pat</span> <span class="kt">::=</span> <span class="o">!</span><span class="n">pat</span>
</pre></div>
</div>
<p>Matching an expression <code class="docutils literal"><span class="pre">e</span></code> against a pattern <code class="docutils literal"><span class="pre">!p</span></code> is done by first
evaluating <code class="docutils literal"><span class="pre">e</span></code> (to WHNF) and then matching the result against <code class="docutils literal"><span class="pre">p</span></code>.
Example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f1</span> <span class="o">!</span><span class="n">x</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>This definition makes <code class="docutils literal"><span class="pre">f1</span></code> is strict in <code class="docutils literal"><span class="pre">x</span></code>, whereas without the
bang it would be lazy. Bang patterns can be nested of course:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f2</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">f2</span></code> is strict in <code class="docutils literal"><span class="pre">x</span></code> but not in <code class="docutils literal"><span class="pre">y</span></code>.</p>
<p>Note the following points:</p>
<ul>
<li><p class="first">A bang only really has
an effect if it precedes a variable or wild-card pattern:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f3</span> <span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
<span class="nf">f4</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>  <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">f3</span></code> and <code class="docutils literal"><span class="pre">f4</span></code> are identical; putting a bang before a pattern
that forces evaluation anyway does nothing.</p>
</li>
<li><p class="first">A bang pattern is allowed in a let or where clause, and makes the binding
strict.  For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="o">!</span><span class="n">x</span> <span class="ow">=</span> <span class="n">e</span> <span class="kr">in</span> <span class="n">body</span>
<span class="kr">let</span> <span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="n">e</span> <span class="kr">in</span> <span class="n">body</span>
</pre></div>
</div>
<p>In both cases <code class="docutils literal"><span class="pre">e</span></code> is evaluated before starting to evaluate <code class="docutils literal"><span class="pre">body</span></code>.</p>
<p>However, <em>nested</em> bangs in a let/where pattern binding behave uniformly with all
other forms of pattern matching. For example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">,[</span><span class="n">y</span><span class="p">])</span> <span class="ow">=</span> <span class="n">e</span> <span class="kr">in</span> <span class="n">b</span>
</pre></div>
</div>
<p>is equivalent to this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="p">{</span> <span class="n">t</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">e</span> <span class="kr">of</span> <span class="p">(</span><span class="n">x</span><span class="p">,[</span><span class="n">y</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
      <span class="n">x</span> <span class="ow">=</span> <span class="n">fst</span> <span class="n">t</span>
      <span class="n">y</span> <span class="ow">=</span> <span class="n">snd</span> <span class="n">t</span> <span class="p">}</span>
<span class="kr">in</span> <span class="n">b</span>
</pre></div>
</div>
<p>The binding is lazy, but when either <code class="docutils literal"><span class="pre">x</span></code> or <code class="docutils literal"><span class="pre">y</span></code> is evaluated by
<code class="docutils literal"><span class="pre">b</span></code> the entire pattern is matched, including forcing the evaluation of
<code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>See <a class="reference internal" href="#recursive-and-polymorphic-let-bindings"><span>Semantics of let bindings with bang patterns</span></a> for
the detailed semantics.</p>
</li>
<li><p class="first">A pattern with a bang at the outermost level is not allowed at the top
level of a module.</p>
</li>
<li><p class="first">Bang patterns work in <code class="docutils literal"><span class="pre">case</span></code> expressions too, of course:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">g5</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">in</span> <span class="n">body</span>
<span class="nf">g6</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">of</span> <span class="p">{</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">body</span> <span class="p">}</span>
<span class="nf">g7</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">of</span> <span class="p">{</span> <span class="o">!</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">body</span> <span class="p">}</span>
</pre></div>
</div>
<p>The functions <code class="docutils literal"><span class="pre">g5</span></code> and <code class="docutils literal"><span class="pre">g6</span></code> mean exactly the same thing. But <code class="docutils literal"><span class="pre">g7</span></code>
evaluates <code class="docutils literal"><span class="pre">(f</span> <span class="pre">x)</span></code>, binds <code class="docutils literal"><span class="pre">y</span></code> to the result, and then evaluates
<code class="docutils literal"><span class="pre">body</span></code>.</p>
</li>
<li><p class="first">There is one problem with syntactic ambiguity. Consider:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="o">!</span><span class="n">x</span> <span class="ow">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Is this a definition of the infix function &#8220;<code class="docutils literal"><span class="pre">(!)</span></code>&#8221;, or of the &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221;
with a bang pattern? GHC resolves this ambiguity in favour of the
latter. If you want to define <code class="docutils literal"><span class="pre">(!)</span></code> with bang-patterns enabled, you
have to do so using prefix notation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">!</span><span class="p">)</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">3</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="strict-by-default-data-types">
<span id="strict-data"></span><h2>10.28.2. Strict-by-default data types<a class="headerlink" href="#strict-by-default-data-types" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XStrictData">
<code class="descname">-XStrictData</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XStrictData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Make fields of data types defined in the current module strict by default.</p>
</dd></dl>

<p>Informally the <code class="docutils literal"><span class="pre">StrictData</span></code> language extension switches data type
declarations to be strict by default allowing fields to be lazy by
adding a <code class="docutils literal"><span class="pre">~</span></code> in front of the field.</p>
<p>When the user writes</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">C</span> <span class="n">a</span>
<span class="kr">data</span> <span class="kt">T&#39;</span> <span class="ow">=</span> <span class="kt">C&#39;</span> <span class="o">~</span><span class="n">a</span>
</pre></div>
</div>
<p>we interpret it as if they had written</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">C</span> <span class="o">!</span><span class="n">a</span>
<span class="kr">data</span> <span class="kt">T&#39;</span> <span class="ow">=</span> <span class="kt">C&#39;</span> <span class="n">a</span>
</pre></div>
</div>
<p>The extension only affects definitions in this module.</p>
</div>
<div class="section" id="strict-by-default-pattern-bindings">
<span id="strict"></span><h2>10.28.3. Strict-by-default pattern bindings<a class="headerlink" href="#strict-by-default-pattern-bindings" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XStrict">
<code class="descname">-XStrict</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XStrict" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="#ghc-flag--XStrictData"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XStrictData</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Make bindings in the current module strict by default.</p>
</dd></dl>

<p>Informally the <code class="docutils literal"><span class="pre">Strict</span></code> language extension switches functions, data
types, and bindings to be strict by default, allowing optional laziness
by adding <code class="docutils literal"><span class="pre">~</span></code> in front of a variable. This essentially reverses the
present situation where laziness is default and strictness can be
optionally had by adding <code class="docutils literal"><span class="pre">!</span></code> in front of a variable.</p>
<p><code class="docutils literal"><span class="pre">Strict</span></code> implies <a class="reference internal" href="#strict-data"><span>StrictData</span></a>.</p>
<ul>
<li><p class="first"><strong>Function definitions</strong></p>
<p>When the user writes</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>we interpret it as if they had written</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="o">!</span><span class="n">x</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Adding <code class="docutils literal"><span class="pre">~</span></code> in front of <code class="docutils literal"><span class="pre">x</span></code> gives the regular lazy behavior.</p>
</li>
<li><p class="first"><strong>Let/where bindings</strong></p>
<p>When the user writes</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="o">...</span>
<span class="kr">let</span> <span class="n">pat</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>we interpret it as if they had written</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="o">!</span><span class="n">x</span> <span class="ow">=</span> <span class="o">...</span>
<span class="kr">let</span> <span class="o">!</span><span class="n">pat</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Adding <code class="docutils literal"><span class="pre">~</span></code> in front of <code class="docutils literal"><span class="pre">x</span></code> gives the regular lazy
behavior.
The general rule is that we add an implicit bang on the outermost pattern,
unless disabled with <code class="docutils literal"><span class="pre">~</span></code>.</p>
</li>
<li><p class="first"><strong>Pattern matching in case expressions, lambdas, do-notation, etc</strong></p>
<p>The outermost pattern of all pattern matches gets an implicit bang,
unless disabled with <code class="docutils literal"><span class="pre">~</span></code>.
This applies to case expressions, patterns in lambda, do-notation,
list comprehension, and so on.
For example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">rhs</span>
</pre></div>
</div>
<p>is interpreted as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">rhs</span>
</pre></div>
</div>
<p>Since the semantics of pattern matching in case expressions is
strict, this usually has no effect whatsoever. But it does make a
difference in the degenerate case of variables and newtypes. So</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">rhs</span>
</pre></div>
</div>
<p>is lazy in Haskell, but with <code class="docutils literal"><span class="pre">Strict</span></code> is interpreted as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="o">!</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">rhs</span>
</pre></div>
</div>
<p>which evaluates <code class="docutils literal"><span class="pre">x</span></code>. Similarly, if <code class="docutils literal"><span class="pre">newtype</span> <span class="pre">Age</span> <span class="pre">=</span> <span class="pre">MkAge</span> <span class="pre">Int</span></code>, then</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="kt">MkAge</span> <span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">rhs</span>
</pre></div>
</div>
<p>is lazy in Haskell; but with <code class="docutils literal"><span class="pre">Strict</span></code> the added bang makes it
strict.</p>
<p>Similarly</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">\</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">body</span>
<span class="kr">do</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">rhs</span><span class="p">;</span> <span class="n">blah</span> <span class="p">}</span>
<span class="p">[</span> <span class="n">e</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">rhs</span><span class="p">;</span> <span class="n">blah</span> <span class="p">}</span>
</pre></div>
</div>
<p>all get implicit bangs on the <code class="docutils literal"><span class="pre">x</span></code> pattern.</p>
</li>
<li><p class="first"><strong>Nested patterns</strong></p>
<p>Notice that we do <em>not</em> put bangs on nested patterns. For
example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">flob</span> <span class="kr">then</span> <span class="p">(</span><span class="n">undefined</span><span class="p">,</span> <span class="n">undefined</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="kt">False</span><span class="p">)</span>
<span class="kr">in</span> <span class="o">...</span>
</pre></div>
</div>
<p>will behave like</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">flob</span> <span class="kr">then</span> <span class="p">(</span><span class="n">undefined</span><span class="p">,</span> <span class="n">undefined</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span><span class="kt">False</span><span class="p">)</span>
<span class="kr">in</span> <span class="o">...</span>
</pre></div>
</div>
<p>which will strictly evaluate the right hand side, and bind <code class="docutils literal"><span class="pre">p</span></code>
and <code class="docutils literal"><span class="pre">q</span></code> to the components of the pair. But the pair itself is
lazy (unless we also compile the <code class="docutils literal"><span class="pre">Prelude</span></code> with <code class="docutils literal"><span class="pre">Strict</span></code>; see
<a class="reference internal" href="#strict-modularity"><span>Modularity</span></a> below). So <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> may end up bound to
undefined. See also <a class="reference internal" href="#recursive-and-polymorphic-let-bindings"><span>Dynamic semantics of bang patterns</span></a> below.</p>
</li>
<li><p class="first"><strong>Top level bindings</strong></p>
<p>are unaffected by <code class="docutils literal"><span class="pre">Strict</span></code>. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">x</span> <span class="ow">=</span> <span class="n">factorial</span> <span class="mi">20</span>
<span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="kr">then</span> <span class="kt">True</span> <span class="kr">else</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">x</span></code> and the pattern binding <code class="docutils literal"><span class="pre">(y,z)</span></code> remain lazy. Reason:
there is no good moment to force them, until first use.</p>
</li>
<li><p class="first"><strong>Newtypes</strong></p>
<p>There is no effect on newtypes, which simply rename existing types.
For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">C</span> <span class="n">a</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">C</span> <span class="n">x</span><span class="p">)</span>  <span class="ow">=</span> <span class="n">rhs1</span>
<span class="nf">g</span> <span class="o">!</span><span class="p">(</span><span class="kt">C</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">rhs2</span>
</pre></div>
</div>
<p>In ordinary Haskell, <code class="docutils literal"><span class="pre">f</span></code> is lazy in its argument and hence in
<code class="docutils literal"><span class="pre">x</span></code>; and <code class="docutils literal"><span class="pre">g</span></code> is strict in its argument and hence also strict in
<code class="docutils literal"><span class="pre">x</span></code>. With <code class="docutils literal"><span class="pre">Strict</span></code>, both become strict because <code class="docutils literal"><span class="pre">f</span></code>&#8216;s argument
gets an implicit bang.</p>
</li>
</ul>
</div>
<div class="section" id="modularity">
<span id="strict-modularity"></span><h2>10.28.4. Modularity<a class="headerlink" href="#modularity" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Strict</span></code> and <code class="docutils literal"><span class="pre">StrictData</span></code> only affects definitions in the module
they are used in. Functions and data types imported from other modules
are unaffected. For example, we won&#8217;t evaluate the argument to
<code class="docutils literal"><span class="pre">Just</span></code> before applying the constructor.  Similarly we won&#8217;t evaluate
the first argument to <code class="docutils literal"><span class="pre">Data.Map.findWithDefault</span></code> before applying the
function.</p>
<p>This is crucial to preserve correctness. Entities defined in other
modules might rely on laziness for correctness (whether functional or
performance).</p>
<p>Tuples, lists, <code class="docutils literal"><span class="pre">Maybe</span></code>, and all the other types from <code class="docutils literal"><span class="pre">Prelude</span></code>
continue to have their existing, lazy, semantics.</p>
</div>
<div class="section" id="dynamic-semantics-of-bang-patterns">
<span id="recursive-and-polymorphic-let-bindings"></span><span id="bang-patterns-sem"></span><h2>10.28.5. Dynamic semantics of bang patterns<a class="headerlink" href="#dynamic-semantics-of-bang-patterns" title="Permalink to this headline">¶</a></h2>
<p>The semantics of Haskell pattern matching is described in <a class="reference external" href="http://www.haskell.org/onlinereport/exps.html#sect3.17.2">Section
3.17.2</a> of
the Haskell Report. To this description add one extra item 10, saying:</p>
<ul class="simple">
<li>Matching the pattern <code class="docutils literal"><span class="pre">!pat</span></code> against a value <code class="docutils literal"><span class="pre">v</span></code> behaves as
follows:<ul>
<li>if <code class="docutils literal"><span class="pre">v</span></code> is bottom, the match diverges</li>
<li>otherwise, <code class="docutils literal"><span class="pre">pat</span></code> is matched against <code class="docutils literal"><span class="pre">v</span></code></li>
</ul>
</li>
</ul>
<p>Similarly, in Figure 4 of <a class="reference external" href="http://www.haskell.org/onlinereport/exps.html#sect3.17.3">Section
3.17.3</a>,
add a new case (t):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="p">{</span> <span class="o">!</span><span class="n">pat</span> <span class="ow">-&gt;</span> <span class="n">e</span><span class="p">;</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">e&#39;</span> <span class="p">}</span>
   <span class="ow">=</span> <span class="n">v</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="p">{</span> <span class="n">pat</span> <span class="ow">-&gt;</span> <span class="n">e</span><span class="p">;</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">e&#39;</span> <span class="p">}</span>
</pre></div>
</div>
<p>That leaves let expressions, whose translation is given in <a class="reference external" href="http://www.haskell.org/onlinereport/exps.html#sect3.12">Section
3.12</a> of the
Haskell Report.
Replace the &#8220;Translation&#8221; there with the following one.  Given
<code class="docutils literal"><span class="pre">let</span> <span class="pre">{</span> <span class="pre">bind1</span> <span class="pre">...</span> <span class="pre">bindn</span> <span class="pre">}</span> <span class="pre">in</span> <span class="pre">body</span></code>:</p>
<div class="admonition-force admonition">
<p class="first admonition-title">FORCE</p>
<p class="last">Replace any binding <code class="docutils literal"><span class="pre">!p</span> <span class="pre">=</span> <span class="pre">e</span></code> with <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">case</span> <span class="pre">e</span> <span class="pre">of</span> <span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">(x1,</span> <span class="pre">...,</span> <span class="pre">xn);</span> <span class="pre">(x1,</span> <span class="pre">...,</span> <span class="pre">xn)</span> <span class="pre">=</span> <span class="pre">v</span></code> and replace
<code class="docutils literal"><span class="pre">body</span></code> with <code class="docutils literal"><span class="pre">v</span> <span class="pre">seq</span> <span class="pre">body</span></code>, where <code class="docutils literal"><span class="pre">v</span></code> is fresh. This translation works fine if
<code class="docutils literal"><span class="pre">p</span></code> is already a variable <code class="docutils literal"><span class="pre">x</span></code>, but can obviously be optimised by not
introducing a fresh variable <code class="docutils literal"><span class="pre">v</span></code>.</p>
</div>
<div class="admonition-split admonition">
<p class="first admonition-title">SPLIT</p>
<p class="last">Replace any binding <code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">e</span></code>, where <code class="docutils literal"><span class="pre">p</span></code> is not a variable, with
<code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">e;</span> <span class="pre">x1</span> <span class="pre">=</span> <span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">x1;</span> <span class="pre">...;</span> <span class="pre">xn</span> <span class="pre">=</span> <span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">xn</span></code>, where
<code class="docutils literal"><span class="pre">v</span></code> is fresh and <code class="docutils literal"><span class="pre">x1</span></code>.. <code class="docutils literal"><span class="pre">xn</span></code> are the bound variables of <code class="docutils literal"><span class="pre">p</span></code>.
Again if <code class="docutils literal"><span class="pre">e</span></code> is a variable, this can be optimised by not introducing a
fresh variable.</p>
</div>
<p>The result will be a (possibly) recursive set of bindings, binding
only simple variables on the left hand side. (One could go one step
further, as in the Haskell Report and make the recursive bindings
non-recursive using <code class="docutils literal"><span class="pre">fix</span></code>, but we do not do so in Core, and it only
obfuscates matters, so we do not do so here.)</p>
<p>The translation is carefully crafted to make bang patterns meaningful
for recursive and polymorphic bindings as well as straightforward
non-recursive bindings.</p>
<p>Here are some examples of how this translation works. The first
expression of each sequence is Haskell source; the subsequent ones are
Core.</p>
<p>Here is a simple non-recursive case:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span>     <span class="c1">-- Non-recursive</span>
    <span class="o">!</span><span class="n">x</span> <span class="ow">=</span> <span class="n">factorial</span> <span class="n">y</span>
<span class="kr">in</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="kt">FORCE</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">factorial</span> <span class="n">y</span> <span class="kr">in</span> <span class="n">x</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="n">inline</span> <span class="n">seq</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">factorial</span> <span class="n">y</span> <span class="kr">in</span> <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="n">inline</span> <span class="n">x</span><span class="p">)</span>
    <span class="kr">case</span> <span class="n">factorial</span> <span class="n">y</span> <span class="kr">of</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">body</span>
</pre></div>
</div>
<p>Same again, only with a pattern binding:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="o">!</span><span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">e</span> <span class="kr">in</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="kt">FORCE</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">e</span> <span class="kr">of</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span>
    <span class="kr">in</span> <span class="n">v</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="kt">SPLIT</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">e</span> <span class="kr">of</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">x</span>
        <span class="n">y</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">y</span>
    <span class="kr">in</span> <span class="n">v</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="n">inline</span> <span class="n">seq</span><span class="p">,</span> <span class="n">float</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="n">bindings</span> <span class="n">inwards</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">e</span> <span class="kr">of</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="kr">in</span> <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">x</span>
                          <span class="n">y</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">y</span>
                      <span class="kr">in</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="n">fluff</span> <span class="n">up</span> <span class="n">v&#39;s</span> <span class="n">pattern</span><span class="p">;</span> <span class="n">this</span> <span class="n">is</span> <span class="n">a</span> <span class="n">standard</span> <span class="kt">Core</span> <span class="n">optimisation</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">e</span> <span class="kr">of</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="kr">in</span> <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="n">v</span><span class="o">@</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">x</span>
                                <span class="n">y</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">y</span>
                            <span class="kr">in</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="kr">case</span> <span class="kr">of</span> <span class="n">known</span> <span class="n">constructor</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">e</span> <span class="kr">of</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="kr">in</span> <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span> <span class="n">v</span><span class="o">@</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">p</span>
                                <span class="n">y</span> <span class="ow">=</span> <span class="n">q</span>
                            <span class="kr">in</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="n">inline</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="kr">case</span> <span class="p">(</span><span class="kr">case</span> <span class="n">e</span> <span class="kr">of</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="kr">of</span>
        <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">body</span><span class="p">[</span><span class="n">p</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="o">/</span><span class="n">y</span><span class="p">]</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="kr">case</span> <span class="kr">of</span> <span class="kr">case</span><span class="p">)</span>
    <span class="kr">case</span> <span class="n">e</span> <span class="kr">of</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">body</span><span class="p">[</span><span class="n">p</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="o">/</span><span class="n">y</span><span class="p">]</span>
</pre></div>
</div>
<p>The final form is just what we want: a simple case expression.</p>
<p>Here is a recursive case</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">letrec</span> <span class="n">xs</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>  <span class="c1">-- Recursive</span>
        <span class="o">!</span><span class="n">xs</span> <span class="ow">=</span> <span class="n">factorial</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">xs</span>
<span class="kr">in</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="kt">FORCE</span><span class="p">)</span>
    <span class="n">letrec</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">factorial</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">xs</span> <span class="kr">in</span> <span class="n">xs</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="n">inline</span> <span class="n">seq</span><span class="p">)</span>
    <span class="n">letrec</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">factorial</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">xs</span> <span class="kr">in</span> <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span> <span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="n">eliminate</span> <span class="kr">case</span> <span class="kr">of</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">letrec</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">factorial</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">xs</span> <span class="kr">in</span> <span class="n">body</span>
</pre></div>
</div>
<p>and a polymorphic one:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">f</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>    <span class="c1">-- Polymorphic</span>
    <span class="o">!</span><span class="n">f</span> <span class="ow">=</span> <span class="n">fst</span> <span class="p">(</span><span class="n">reverse</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span>
<span class="kr">in</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="kt">FORCE</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">f</span> <span class="ow">=</span> <span class="o">/\</span><span class="n">a</span><span class="o">.</span> <span class="n">fst</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">a</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span> <span class="kr">in</span> <span class="n">f</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">body</span>
<span class="o">===&gt;</span> <span class="p">(</span><span class="n">inline</span> <span class="n">seq</span><span class="p">,</span> <span class="n">inline</span> <span class="n">f</span><span class="p">)</span>
    <span class="kr">case</span> <span class="p">(</span><span class="o">/\</span><span class="n">a</span><span class="o">.</span> <span class="n">fst</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">a</span><span class="p">,</span> <span class="kt">True</span><span class="p">))</span> <span class="kr">of</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">body</span>
</pre></div>
</div>
<p>Notice that the <code class="docutils literal"><span class="pre">seq</span></code> is added only in the translation to Core
If we did it in Haskell source, thus</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">f</span> <span class="ow">=</span> <span class="o">...</span> <span class="kr">in</span> <span class="n">f</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">body</span>
</pre></div>
</div>
<p>then <code class="docutils literal"><span class="pre">f</span></code>&#8216;s polymorphic type would get intantiated, so the Core
translation would be</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">f</span> <span class="ow">=</span> <span class="o">...</span> <span class="kr">in</span> <span class="n">f</span> <span class="kt">Any</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">body</span>
</pre></div>
</div>
<p>When overloading is involved, the results might be slightly counter
intuitive:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">f</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>    <span class="c1">-- Overloaded</span>
    <span class="o">!</span><span class="n">f</span> <span class="ow">=</span> <span class="n">fst</span> <span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span>
<span class="kr">in</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="kt">FORCE</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">f</span> <span class="ow">=</span> <span class="o">/\</span><span class="n">a</span> <span class="nf">\</span><span class="p">(</span><span class="n">d</span><span class="ow">::</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span> <span class="n">fst</span> <span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span> <span class="kr">in</span> <span class="n">f</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">body</span>

<span class="o">===&gt;</span> <span class="p">(</span><span class="n">inline</span> <span class="n">seq</span><span class="p">,</span> <span class="kr">case</span> <span class="kr">of</span> <span class="n">value</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">f</span> <span class="ow">=</span> <span class="o">/\</span><span class="n">a</span> <span class="nf">\</span><span class="p">(</span><span class="n">d</span><span class="ow">::</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span> <span class="n">fst</span> <span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span> <span class="kr">in</span> <span class="n">body</span>
</pre></div>
</div>
<p>Note that the bang has no effect at all in this case</p>
</div>
</div>
<div class="section" id="assertions">
<span id="id65"></span><h1>10.29. Assertions<a class="headerlink" href="#assertions" title="Permalink to this headline">¶</a></h1>
<p id="index-23">If you want to make use of assertions in your standard Haskell code, you
could define a function like the following:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">assert</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">assert</span> <span class="kt">False</span> <span class="n">x</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;assertion failed!&quot;</span>
<span class="nf">assert</span> <span class="kr">_</span>     <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div>
</div>
<p>which works, but gives you back a less than useful error message &#8211; an
assertion failed, but which and where?</p>
<p>One way out is to define an extended <code class="docutils literal"><span class="pre">assert</span></code> function which also
takes a descriptive string to include in the error message and perhaps
combine this with the use of a pre-processor which inserts the source
location where <code class="docutils literal"><span class="pre">assert</span></code> was used.</p>
<p>GHC offers a helping hand here, doing all of this for you. For every use
of <code class="docutils literal"><span class="pre">assert</span></code> in the user&#8217;s source:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">kelvinToC</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">kelvinToC</span> <span class="n">k</span> <span class="ow">=</span> <span class="n">assert</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mf">273.15</span><span class="p">)</span>
</pre></div>
</div>
<p>GHC will rewrite this to also include the source location where the
assertion was made,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">assert</span> <span class="n">pred</span> <span class="n">val</span> <span class="o">==&gt;</span> <span class="n">assertError</span> <span class="s">&quot;Main.hs|15&quot;</span> <span class="n">pred</span> <span class="n">val</span>
</pre></div>
</div>
<p>The rewrite is only performed by the compiler when it spots applications
of <code class="docutils literal"><span class="pre">Control.Exception.assert</span></code>, so you can still define and use your
own versions of <code class="docutils literal"><span class="pre">assert</span></code>, should you so wish. If not, import
<code class="docutils literal"><span class="pre">Control.Exception</span></code> to make use <code class="docutils literal"><span class="pre">assert</span></code> in your code.</p>
<p id="index-24">GHC ignores assertions when optimisation is turned on with the
<a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a> flag. That is, expressions of the form <code class="docutils literal"><span class="pre">assert</span> <span class="pre">pred</span> <span class="pre">e</span></code>
will be rewritten to <code class="docutils literal"><span class="pre">e</span></code>. You can also disable assertions using the
<a class="reference internal" href="using-optimisation.html#ghc-flag--fignore-asserts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fignore-asserts</span></code></a> option. The option
<a class="reference internal" href="using-optimisation.html#ghc-flag--fignore-asserts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fno-ignore-asserts</span></code></a>
allows enabling assertions even when optimisation is turned on.</p>
<p>Assertion failures can be caught, see the documentation for the
<a class="reference external" href="../libraries/base-4.10.1.0/Control-Exception.html">Control.Exception</a> library for the details.</p>
</div>
<div class="section" id="static-pointers">
<span id="id66"></span><h1>10.30. Static pointers<a class="headerlink" href="#static-pointers" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-25"></span><dl class="ghc-flag">
<dt id="ghc-flag--XStaticPointers">
<code class="descname">-XStaticPointers</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XStaticPointers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.10.1</td>
</tr>
</tbody>
</table>
<p>Allow use of static pointer syntax.</p>
</dd></dl>

<p>The language extension <a class="reference internal" href="#ghc-flag--XStaticPointers"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XStaticPointers</span></code></a> adds a new syntactic form
<code class="docutils literal"><span class="pre">static</span> <span class="pre">e</span></code>, which stands for a reference to the closed expression ⟨e⟩.
This reference is stable and portable, in the sense that it remains
valid across different processes on possibly different machines. Thus, a
process can create a reference and send it to another process that can
resolve it to ⟨e⟩.</p>
<p>With this extension turned on, <code class="docutils literal"><span class="pre">static</span></code> is no longer a valid
identifier.</p>
<p>Static pointers were first proposed in the paper <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf">Towards Haskell in the
cloud</a>,
Jeff Epstein, Andrew P. Black and Simon Peyton-Jones, Proceedings of the
4th ACM Symposium on Haskell, pp. 118-129, ACM, 2011.</p>
<div class="section" id="using-static-pointers">
<span id="id67"></span><h2>10.30.1. Using static pointers<a class="headerlink" href="#using-static-pointers" title="Permalink to this headline">¶</a></h2>
<p>Each reference is given a key which can be used to locate it at runtime
with
<a class="reference external" href="../libraries/base-4.10.1.0/GHC-StaticPtr.html#v%3AunsafeLookupStaticPtr">unsafeLookupStaticPtr</a>
which uses a global and immutable table called the Static Pointer Table.
The compiler includes entries in this table for all static forms found
in the linked modules. The value can be obtained from the reference via
<a class="reference external" href="../libraries/base-4.10.1.0/GHC-StaticPtr.html#v%3AdeRefStaticPtr">deRefStaticPtr</a>.</p>
<p>The body <code class="docutils literal"><span class="pre">e</span></code> of a <code class="docutils literal"><span class="pre">static</span> <span class="pre">e</span></code> expression must be a closed expression. Where
we say an expression is <em>closed</em> when all of its free (type) variables are
closed. And a variable is <em>closed</em> if it is let-bound to a <em>closed</em> expression
and its type is <em>closed</em> as well. And a type is <em>closed</em> if it has no free
variables.</p>
<p>All of the following are permissible:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">inc</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">inc</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="nf">ref1</span> <span class="ow">=</span> <span class="n">static</span> <span class="mi">1</span>
<span class="nf">ref2</span> <span class="ow">=</span> <span class="n">static</span> <span class="n">inc</span>
<span class="nf">ref3</span> <span class="ow">=</span> <span class="n">static</span> <span class="p">(</span><span class="n">inc</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">ref4</span> <span class="ow">=</span> <span class="n">static</span> <span class="p">((</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">))</span>
<span class="nf">ref5</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">static</span> <span class="p">(</span><span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kr">in</span> <span class="n">x</span><span class="p">)</span>
<span class="nf">ref6</span> <span class="n">y</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kr">in</span> <span class="n">static</span> <span class="n">x</span>
</pre></div>
</div>
<p>While the following definitions are rejected:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ref7</span> <span class="n">y</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">y</span> <span class="kr">in</span> <span class="n">static</span> <span class="n">x</span>    <span class="c1">-- x is not closed</span>
<span class="nf">ref8</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">static</span> <span class="p">(</span><span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kr">in</span> <span class="n">y</span><span class="p">)</span>  <span class="c1">-- y is not let-bound</span>
<span class="nf">ref8</span> <span class="p">(</span><span class="n">y</span> <span class="ow">::</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">undefined</span> <span class="ow">::</span> <span class="n">a</span>
                 <span class="kr">in</span> <span class="n">static</span> <span class="n">x</span>      <span class="c1">-- x has a non-closed type</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While modules loaded in GHCi with the <a class="reference internal" href="ghci.html#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> command may use
<a class="reference internal" href="#ghc-flag--XStaticPointers"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XStaticPointers</span></code></a> and <code class="docutils literal"><span class="pre">static</span></code> expressions, statements
entered on the REPL may not. This is a limitation of GHCi; see
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/12356">Trac #12356</a> for details.</p>
</div>
</div>
<div class="section" id="static-semantics-of-static-pointers">
<span id="typechecking-static-pointers"></span><h2>10.30.2. Static semantics of static pointers<a class="headerlink" href="#static-semantics-of-static-pointers" title="Permalink to this headline">¶</a></h2>
<p>Informally, if we have a closed expression</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">e</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a_1</span> <span class="o">...</span> <span class="n">a_n</span> <span class="o">.</span> <span class="n">t</span>
</pre></div>
</div>
<p>the static form is of type</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">static</span> <span class="n">e</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">IsStatic</span> <span class="n">p</span><span class="p">,</span> <span class="kt">Typeable</span> <span class="n">a_1</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="kt">Typeable</span> <span class="n">a_n</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">p</span> <span class="n">t</span>
</pre></div>
</div>
<p>A static form determines a value of type <code class="docutils literal"><span class="pre">StaticPtr</span> <span class="pre">t</span></code>, but just
like <code class="docutils literal"><span class="pre">OverloadedLists</span></code> and <code class="docutils literal"><span class="pre">OverloadedStrings</span></code>, this literal
expression is overloaded to allow lifting a <code class="docutils literal"><span class="pre">StaticPtr</span></code> into another
type implicitly, via the <code class="docutils literal"><span class="pre">IsStatic</span></code> class:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">IsStatic</span> <span class="n">p</span> <span class="kr">where</span>
    <span class="n">fromStaticPtr</span> <span class="ow">::</span> <span class="kt">StaticPtr</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">p</span> <span class="n">a</span>
</pre></div>
</div>
<p>The only predefined instance is the obvious one that does nothing:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">IsStatic</span> <span class="kt">StaticPtr</span> <span class="kr">where</span>
    <span class="n">fromStaticPtr</span> <span class="n">sptr</span> <span class="ow">=</span> <span class="n">sptr</span>
</pre></div>
</div>
<p>See <a class="reference external" href="../libraries/base-4.10.1.0/GHC-StaticPtr.html#t%3AIsStatic">IsStatic</a>.</p>
<p>Furthermore, type <code class="docutils literal"><span class="pre">t</span></code> is constrained to have a <code class="docutils literal"><span class="pre">Typeable</span></code> instance.
The following are therefore illegal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">static</span> <span class="n">show</span>                    <span class="c1">-- No Typeable instance for (Show a =&gt; a -&gt; String)</span>
<span class="nf">static</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Monad</span><span class="o">.</span><span class="kt">ST</span><span class="o">.</span><span class="n">runST</span>  <span class="c1">-- No Typeable instance for ((forall s. ST s a) -&gt; a)</span>
</pre></div>
</div>
<p>That being said, with the appropriate use of wrapper datatypes, the
above limitations induce no loss of generality:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE ConstraintKinds           #-}</span>
<span class="cm">{-# LANGUAGE ExistentialQuantification #-}</span>
<span class="cm">{-# LANGUAGE Rank2Types                #-}</span>
<span class="cm">{-# LANGUAGE StandaloneDeriving        #-}</span>
<span class="cm">{-# LANGUAGE StaticPointers            #-}</span>

<span class="kr">import</span> <span class="nn">Control.Monad.ST</span>
<span class="kr">import</span> <span class="nn">Data.Typeable</span>
<span class="kr">import</span> <span class="nn">GHC.StaticPtr</span>

<span class="kr">data</span> <span class="kt">Dict</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">c</span> <span class="ow">=&gt;</span> <span class="kt">Dict</span>

<span class="nf">g1</span> <span class="ow">::</span> <span class="kt">Typeable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">StaticPtr</span> <span class="p">(</span><span class="kt">Dict</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span><span class="p">)</span>
<span class="nf">g1</span> <span class="ow">=</span> <span class="n">static</span> <span class="p">(</span><span class="nf">\</span><span class="kt">Dict</span> <span class="ow">-&gt;</span> <span class="n">show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Rank2Wrapper</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">R2W</span> <span class="p">(</span><span class="n">forall</span> <span class="n">s</span><span class="o">.</span> <span class="n">f</span> <span class="n">s</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="kt">Typeable</span>
<span class="kr">newtype</span> <span class="kt">Flip</span> <span class="n">f</span> <span class="n">a</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Flip</span> <span class="p">{</span> <span class="n">unFlip</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">s</span> <span class="n">a</span> <span class="p">}</span>
  <span class="kr">deriving</span> <span class="kt">Typeable</span>

<span class="nf">g2</span> <span class="ow">::</span> <span class="kt">Typeable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">StaticPtr</span> <span class="p">(</span><span class="kt">Rank2Wrapper</span> <span class="p">(</span><span class="kt">Flip</span> <span class="kt">ST</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">g2</span> <span class="ow">=</span> <span class="n">static</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">R2W</span> <span class="n">f</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">runST</span> <span class="p">(</span><span class="n">unFlip</span> <span class="n">f</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pragmas">
<span id="id68"></span><h1>10.31. Pragmas<a class="headerlink" href="#pragmas" title="Permalink to this headline">¶</a></h1>
<p id="index-26">GHC supports several pragmas, or instructions to the compiler placed in
the source code. Pragmas don&#8217;t normally affect the meaning of the
program, but they might affect the efficiency of the generated code.</p>
<p>Pragmas all take the form <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">word</span> <span class="pre">...</span> <span class="pre">#-}</span></code> where ⟨word⟩ indicates
the type of pragma, and is followed optionally by information specific
to that type of pragma. Case is ignored in ⟨word⟩. The various values
for ⟨word⟩ that GHC understands are described in the following sections;
any pragma encountered with an unrecognised ⟨word⟩ is ignored. The
layout rule applies in pragmas, so the closing <code class="docutils literal"><span class="pre">#-}</span></code> should start in a
column to the right of the opening <code class="docutils literal"><span class="pre">{-#</span></code>.</p>
<p>Certain pragmas are <em>file-header pragmas</em>:</p>
<ul class="simple">
<li>A file-header pragma must precede the <code class="docutils literal"><span class="pre">module</span></code> keyword in the file.</li>
<li>There can be as many file-header pragmas as you please, and they can
be preceded or followed by comments.</li>
<li>File-header pragmas are read once only, before pre-processing the
file (e.g. with cpp).</li>
<li>The file-header pragmas are: <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">#-}</span></code>,
<code class="docutils literal"><span class="pre">{-#</span> <span class="pre">OPTIONS_GHC</span> <span class="pre">#-}</span></code>, and <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">INCLUDE</span> <span class="pre">#-}</span></code>.</li>
</ul>
<div class="section" id="language-pragma">
<span id="id69"></span><h2>10.31.1. LANGUAGE pragma<a class="headerlink" href="#language-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-27">The <code class="docutils literal"><span class="pre">LANGUAGE</span></code> pragma allows language extensions to be enabled in a
portable way. It is the intention that all Haskell compilers support the
<code class="docutils literal"><span class="pre">LANGUAGE</span></code> pragma with the same syntax, although not all extensions
are supported by all compilers, of course. The <code class="docutils literal"><span class="pre">LANGUAGE</span></code> pragma
should be used instead of <code class="docutils literal"><span class="pre">OPTIONS_GHC</span></code>, if possible.</p>
<p>For example, to enable the FFI and preprocessing with CPP:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE ForeignFunctionInterface, CPP #-}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">LANGUAGE</span></code> is a file-header pragma (see <a class="reference internal" href="#pragmas"><span>Pragmas</span></a>).</p>
<p>Every language extension can also be turned into a command-line flag by
prefixing it with &#8220;<code class="docutils literal"><span class="pre">-X</span></code>&#8221;; for example <code class="docutils literal"><span class="pre">-XForeignFunctionInterface</span></code>.
(Similarly, all &#8220;<code class="docutils literal"><span class="pre">-X</span></code>&#8221; flags can be written as <code class="docutils literal"><span class="pre">LANGUAGE</span></code> pragmas.)</p>
<p>A list of all supported language extensions can be obtained by invoking
<code class="docutils literal"><span class="pre">ghc</span> <span class="pre">--supported-extensions</span></code> (see <a class="reference internal" href="using.html#ghc-flag---supported-extensions"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--supported-extensions</span></code></a>).</p>
<p>Any extension from the <code class="docutils literal"><span class="pre">Extension</span></code> type defined in
<a class="reference external" href="../libraries/Cabal-2.0.1.0/Language-Haskell-Extension.html">Language.Haskell.Extension</a>
may be used. GHC will report an error if any of the requested extensions
are not supported.</p>
</div>
<div class="section" id="options-ghc-pragma">
<span id="options-pragma"></span><h2>10.31.2. <code class="docutils literal"><span class="pre">OPTIONS_GHC</span></code> pragma<a class="headerlink" href="#options-ghc-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-28">The <code class="docutils literal"><span class="pre">OPTIONS_GHC</span></code> pragma is used to specify additional options that
are given to the compiler when compiling this source file. See
<a class="reference internal" href="using.html#source-file-options"><span>Command line options in source files</span></a> for details.</p>
<p>Previous versions of GHC accepted <code class="docutils literal"><span class="pre">OPTIONS</span></code> rather than
<code class="docutils literal"><span class="pre">OPTIONS_GHC</span></code>, but that is now deprecated.</p>
<p><code class="docutils literal"><span class="pre">OPTIONS_GHC</span></code> is a file-header pragma (see <a class="reference internal" href="#pragmas"><span>Pragmas</span></a>).</p>
</div>
<div class="section" id="include-pragma">
<span id="id70"></span><h2>10.31.3. <code class="docutils literal"><span class="pre">INCLUDE</span></code> pragma<a class="headerlink" href="#include-pragma" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">INCLUDE</span></code> used to be necessary for specifying header files to be
included when using the FFI and compiling via C. It is no longer
required for GHC, but is accepted (and ignored) for compatibility with
other compilers.</p>
</div>
<div class="section" id="warning-and-deprecated-pragmas">
<span id="warning-deprecated-pragma"></span><h2>10.31.4. <code class="docutils literal"><span class="pre">WARNING</span></code> and <code class="docutils literal"><span class="pre">DEPRECATED</span></code> pragmas<a class="headerlink" href="#warning-and-deprecated-pragmas" title="Permalink to this headline">¶</a></h2>
<p id="index-29">The <code class="docutils literal"><span class="pre">WARNING</span></code> pragma allows you to attach an arbitrary warning to a
particular function, class, or type. A <code class="docutils literal"><span class="pre">DEPRECATED</span></code> pragma lets you
specify that a particular function, class, or type is deprecated. There
are two ways of using these pragmas.</p>
<ul>
<li><p class="first">You can work on an entire module thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Wibble</span> <span class="cm">{-# DEPRECATED &quot;Use Wobble instead&quot; #-}</span> <span class="kr">where</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>Or:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Wibble</span> <span class="cm">{-# WARNING &quot;This is an unstable interface.&quot; #-}</span> <span class="kr">where</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>When you compile any module that import <code class="docutils literal"><span class="pre">Wibble</span></code>, GHC will print
the specified message.</p>
</li>
<li><p class="first">You can attach a warning to a function, class, type, or data
constructor, with the following top-level declarations:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# DEPRECATED f, C, T &quot;Don&#39;t use these&quot; #-}</span>
<span class="cm">{-# WARNING unsafePerformIO &quot;This is unsafe; I hope you know what you&#39;re doing&quot; #-}</span>
</pre></div>
</div>
<p>When you compile any module that imports and uses any of the
specified entities, GHC will print the specified message.</p>
<p>You can only attach to entities declared at top level in the module
being compiled, and you can only use unqualified names in the list of
entities. A capitalised name, such as <code class="docutils literal"><span class="pre">T</span></code> refers to <em>either</em> the
type constructor <code class="docutils literal"><span class="pre">T</span></code> <em>or</em> the data constructor <code class="docutils literal"><span class="pre">T</span></code>, or both if
both are in scope. If both are in scope, there is currently no way to
specify one without the other (c.f. fixities <a class="reference internal" href="#infix-tycons"><span>Infix type constructors, classes, and type variables</span></a>).</p>
</li>
</ul>
<p>Also note that the argument to <code class="docutils literal"><span class="pre">DEPRECATED</span></code> and <code class="docutils literal"><span class="pre">WARNING</span></code> can also be a list
of strings, in which case the strings will be presented on separate lines in the
resulting warning message,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# DEPRECATED foo, bar [&quot;Don&#39;t use these&quot;, &quot;Use gar instead&quot;] #-}</span>
</pre></div>
</div>
<p>Warnings and deprecations are not reported for (a) uses within the
defining module, (b) defining a method in a class instance, and (c) uses
in an export list. The latter reduces spurious complaints within a
library in which one module gathers together and re-exports the exports
of several others.</p>
<p>You can suppress the warnings with the flag
<a class="reference internal" href="using-warnings.html#ghc-flag--Wwarnings-deprecations"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wno-warnings-deprecations</span></code></a>.</p>
</div>
<div class="section" id="minimal-pragma">
<span id="id71"></span><h2>10.31.5. MINIMAL pragma<a class="headerlink" href="#minimal-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-30">The <code class="docutils literal"><span class="pre">MINIMAL</span></code> pragma is used to specify the minimal complete definition of
a class, i.e. specify which methods must be implemented by all
instances. If an instance does not satisfy the minimal complete
definition, then a warning is generated. This can be useful when a class
has methods with circular defaults. For example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
    <span class="cm">{-# MINIMAL (==) | (/=) #-}</span>
</pre></div>
</div>
<p>Without the <code class="docutils literal"><span class="pre">MINIMAL</span></code> pragma no warning would be generated for an instance
that implements neither method.</p>
<p>The syntax for minimal complete definition is:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">mindef</span> <span class="kt">::=</span> <span class="n">name</span>
        <span class="o">|</span>  <span class="sc">&#39;(&#39;</span> <span class="n">mindef</span> <span class="sc">&#39;)&#39;</span>
        <span class="o">|</span>  <span class="n">mindef</span> <span class="sc">&#39;|&#39;</span> <span class="n">mindef</span>
        <span class="o">|</span>  <span class="n">mindef</span> <span class="sc">&#39;,&#39;</span> <span class="n">mindef</span>
</pre></div>
</div>
<p>A vertical bar denotes disjunction, i.e. one of the two sides is
required. A comma denotes conjunction, i.e. both sides are required.
Conjunction binds stronger than disjunction.</p>
<p>If no <code class="docutils literal"><span class="pre">MINIMAL</span></code> pragma is given in the class declaration, it is just as if
a pragma <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">MINIMAL</span> <span class="pre">op1,</span> <span class="pre">op2,</span> <span class="pre">...,</span> <span class="pre">opn</span> <span class="pre">#-}</span></code> was given, where the
<code class="docutils literal"><span class="pre">opi</span></code> are the methods (a) that lack a default method in the class
declaration, and (b) whose name that does not start with an underscore
(c.f. <a class="reference internal" href="using-warnings.html#ghc-flag--Wmissing-methods"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wmissing-methods</span></code></a>, <a class="reference internal" href="using-warnings.html#options-sanity"><span>Warnings and sanity-checking</span></a>).</p>
<p>This warning can be turned off with the flag
<a class="reference internal" href="using-warnings.html#ghc-flag--Wmissing-methods"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wno-missing-methods</span></code></a>.</p>
</div>
<div class="section" id="inline-and-noinline-pragmas">
<span id="inline-noinline-pragma"></span><h2>10.31.6. INLINE and NOINLINE pragmas<a class="headerlink" href="#inline-and-noinline-pragmas" title="Permalink to this headline">¶</a></h2>
<p>These pragmas control the inlining of function definitions.</p>
<div class="section" id="inline-pragma">
<span id="id72"></span><h3>10.31.6.1. INLINE pragma<a class="headerlink" href="#inline-pragma" title="Permalink to this headline">¶</a></h3>
<p id="index-31">GHC (with <a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a>, as always) tries to inline (or &#8220;unfold&#8221;)
functions/values that are &#8220;small enough,&#8221; thus avoiding the call
overhead and possibly exposing other more-wonderful optimisations. GHC
has a set of heuristics, tuned over a long period of time using many
benchmarks, that decide when it is beneficial to inline a function at
its call site. The heuristics are designed to inline functions when it
appears to be beneficial to do so, but without incurring excessive code
bloat. If a function looks too big, it won&#8217;t be inlined, and functions
larger than a certain size will not even have their definition exported
in the interface file. Some of the thresholds that govern these
heuristic decisions can be changed using flags, see <a class="reference internal" href="using-optimisation.html#options-f"><span>-f*: platform-independent flags</span></a>.</p>
<p>Normally GHC will do a reasonable job of deciding by itself when it is a
good idea to inline a function. However, sometimes you might want to
override the default behaviour. For example, if you have a key function
that is important to inline because it leads to further optimisations,
but GHC judges it to be too big to inline.</p>
<p>The sledgehammer you can bring to bear is the <code class="docutils literal"><span class="pre">INLINE</span></code> pragma, used thusly:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">key_function</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span>
<span class="cm">{-# INLINE key_function #-}</span>
</pre></div>
</div>
<p>The major effect of an <code class="docutils literal"><span class="pre">INLINE</span></code> pragma is to declare a function&#8217;s
&#8220;cost&#8221; to be very low. The normal unfolding machinery will then be very
keen to inline it. However, an <code class="docutils literal"><span class="pre">INLINE</span></code> pragma for a function &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221;
has a number of other effects:</p>
<ul>
<li><p class="first">While GHC is keen to inline the function, it does not do so blindly.
For example, if you write</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">map</span> <span class="n">key_function</span> <span class="n">xs</span>
</pre></div>
</div>
<p>there really isn&#8217;t any point in inlining <code class="docutils literal"><span class="pre">key_function</span></code> to get</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">body</span><span class="p">)</span> <span class="n">xs</span>
</pre></div>
</div>
<p>In general, GHC only inlines the function if there is some reason (no
matter how slight) to suppose that it is useful to do so.</p>
</li>
<li><p class="first">Moreover, GHC will only inline the function if it is <em>fully applied</em>,
where &#8220;fully applied&#8221; means applied to as many arguments as appear
(syntactically) on the LHS of the function definition. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">comp1</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="cm">{-# INLINE comp1 #-}</span>
<span class="nf">comp1</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">comp2</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="cm">{-# INLINE comp2 #-}</span>
<span class="nf">comp2</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>The two functions <code class="docutils literal"><span class="pre">comp1</span></code> and <code class="docutils literal"><span class="pre">comp2</span></code> have the same semantics,
but <code class="docutils literal"><span class="pre">comp1</span></code> will be inlined when applied to <em>two</em> arguments, while
<code class="docutils literal"><span class="pre">comp2</span></code> requires <em>three</em>. This might make a big difference if you
say</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">map</span> <span class="p">(</span><span class="n">not</span> <span class="p">`</span><span class="n">comp1</span><span class="p">`</span> <span class="n">not</span><span class="p">)</span> <span class="n">xs</span>
</pre></div>
</div>
<p>which will optimise better than the corresponding use of <code class="docutils literal"><span class="pre">comp2</span></code>.</p>
</li>
<li><p class="first">It is useful for GHC to optimise the definition of an INLINE function
<code class="docutils literal"><span class="pre">f</span></code> just like any other non-INLINE function, in case the
non-inlined version of <code class="docutils literal"><span class="pre">f</span></code> is ultimately called. But we don&#8217;t want
to inline the <em>optimised</em> version of <code class="docutils literal"><span class="pre">f</span></code>; a major reason for INLINE
pragmas is to expose functions in <code class="docutils literal"><span class="pre">f</span></code>&#8216;s RHS that have rewrite
rules, and it&#8217;s no good if those functions have been optimised away.</p>
<p>So <em>GHC guarantees to inline precisely the code that you wrote</em>, no
more and no less. It does this by capturing a copy of the definition
of the function to use for inlining (we call this the &#8220;inline-RHS&#8221;),
which it leaves untouched, while optimising the ordinarily RHS as
usual. For externally-visible functions the inline-RHS (not the
optimised RHS) is recorded in the interface file.</p>
</li>
<li><p class="first">An INLINE function is not worker/wrappered by strictness analysis.
It&#8217;s going to be inlined wholesale instead.</p>
</li>
</ul>
<p>GHC ensures that inlining cannot go on forever: every mutually-recursive
group is cut by one or more <em>loop breakers</em> that is never inlined (see
<a class="reference external" href="http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm">Secrets of the GHC inliner, JFP 12(4) July
2002</a>).
GHC tries not to select a function with an INLINE pragma as a loop
breaker, but when there is no choice even an INLINE function can be
selected, in which case the INLINE pragma is ignored. For example, for a
self-recursive function, the loop breaker can only be the function
itself, so an INLINE pragma is always ignored.</p>
<p>Syntactically, an <code class="docutils literal"><span class="pre">INLINE</span></code> pragma for a function can be put anywhere
its type signature could be put.</p>
<p><code class="docutils literal"><span class="pre">INLINE</span></code> pragmas are a particularly good idea for the
<code class="docutils literal"><span class="pre">then</span></code>/<code class="docutils literal"><span class="pre">return</span></code> (or <code class="docutils literal"><span class="pre">bind</span></code>/<code class="docutils literal"><span class="pre">unit</span></code>) functions in a monad. For
example, in GHC&#8217;s own <code class="docutils literal"><span class="pre">UniqueSupply</span></code> monad code, we have:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# INLINE thenUs #-}</span>
<span class="cm">{-# INLINE returnUs #-}</span>
</pre></div>
</div>
<p>See also the <code class="docutils literal"><span class="pre">NOINLINE</span></code> (<a class="reference internal" href="#noinline-pragma"><span>NOINLINE pragma</span></a>) and <code class="docutils literal"><span class="pre">INLINABLE</span></code>
(<a class="reference internal" href="#inlinable-pragma"><span>INLINABLE pragma</span></a>) pragmas.</p>
</div>
<div class="section" id="inlinable-pragma">
<span id="id73"></span><h3>10.31.6.2. INLINABLE pragma<a class="headerlink" href="#inlinable-pragma" title="Permalink to this headline">¶</a></h3>
<p>An <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">INLINABLE</span> <span class="pre">f</span> <span class="pre">#-}</span></code> pragma on a function <code class="docutils literal"><span class="pre">f</span></code> has the following
behaviour:</p>
<ul class="simple">
<li>While <code class="docutils literal"><span class="pre">INLINE</span></code> says &#8220;please inline me&#8221;, the <code class="docutils literal"><span class="pre">INLINABLE</span></code> says
&#8220;feel free to inline me; use your discretion&#8221;. In other words the
choice is left to GHC, which uses the same rules as for pragma-free
functions. Unlike <code class="docutils literal"><span class="pre">INLINE</span></code>, that decision is made at the <em>call
site</em>, and will therefore be affected by the inlining threshold,
optimisation level etc.</li>
<li>Like <code class="docutils literal"><span class="pre">INLINE</span></code>, the <code class="docutils literal"><span class="pre">INLINABLE</span></code> pragma retains a copy of the
original RHS for inlining purposes, and persists it in the interface
file, regardless of the size of the RHS.</li>
<li>One way to use <code class="docutils literal"><span class="pre">INLINABLE</span></code> is in conjunction with the special
function <code class="docutils literal"><span class="pre">inline</span></code> (<a class="reference internal" href="#special-ids"><span>Special built-in functions</span></a>). The call <code class="docutils literal"><span class="pre">inline</span> <span class="pre">f</span></code> tries
very hard to inline <code class="docutils literal"><span class="pre">f</span></code>. To make sure that <code class="docutils literal"><span class="pre">f</span></code> can be inlined, it
is a good idea to mark the definition of <code class="docutils literal"><span class="pre">f</span></code> as <code class="docutils literal"><span class="pre">INLINABLE</span></code>, so
that GHC guarantees to expose an unfolding regardless of how big it
is. Moreover, by annotating <code class="docutils literal"><span class="pre">f</span></code> as <code class="docutils literal"><span class="pre">INLINABLE</span></code>, you ensure that
<code class="docutils literal"><span class="pre">f</span></code>&#8216;s original RHS is inlined, rather than whatever random
optimised version of <code class="docutils literal"><span class="pre">f</span></code> GHC&#8217;s optimiser has produced.</li>
<li>The <code class="docutils literal"><span class="pre">INLINABLE</span></code> pragma also works with <code class="docutils literal"><span class="pre">SPECIALISE</span></code>: if you mark
function <code class="docutils literal"><span class="pre">f</span></code> as <code class="docutils literal"><span class="pre">INLINABLE</span></code>, then you can subsequently
<code class="docutils literal"><span class="pre">SPECIALISE</span></code> in another module (see <a class="reference internal" href="#specialize-pragma"><span>SPECIALIZE pragma</span></a>).</li>
<li>Unlike <code class="docutils literal"><span class="pre">INLINE</span></code>, it is OK to use an <code class="docutils literal"><span class="pre">INLINABLE</span></code> pragma on a
recursive function. The principal reason do to so to allow later use
of <code class="docutils literal"><span class="pre">SPECIALISE</span></code></li>
</ul>
<p>The alternative spelling <code class="docutils literal"><span class="pre">INLINEABLE</span></code> is also accepted by GHC.</p>
</div>
<div class="section" id="noinline-pragma">
<span id="id74"></span><h3>10.31.6.3. NOINLINE pragma<a class="headerlink" href="#noinline-pragma" title="Permalink to this headline">¶</a></h3>
<p id="index-32">The <code class="docutils literal"><span class="pre">NOINLINE</span></code> pragma does exactly what you&#8217;d expect: it stops the
named function from being inlined by the compiler. You shouldn&#8217;t ever
need to do this, unless you&#8217;re very cautious about code size.</p>
<p><code class="docutils literal"><span class="pre">NOTINLINE</span></code> is a synonym for <code class="docutils literal"><span class="pre">NOINLINE</span></code> (<code class="docutils literal"><span class="pre">NOINLINE</span></code> is specified
by Haskell 98 as the standard way to disable inlining, so it should be
used if you want your code to be portable).</p>
</div>
<div class="section" id="conlike-modifier">
<span id="conlike-pragma"></span><h3>10.31.6.4. CONLIKE modifier<a class="headerlink" href="#conlike-modifier" title="Permalink to this headline">¶</a></h3>
<p id="index-33">An INLINE or NOINLINE pragma may have a CONLIKE modifier, which affects
matching in RULEs (only). See <a class="reference internal" href="#conlike"><span>How rules interact with CONLIKE pragmas</span></a>.</p>
</div>
<div class="section" id="phase-control">
<span id="id75"></span><h3>10.31.6.5. Phase control<a class="headerlink" href="#phase-control" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you want to control exactly when in GHC&#8217;s pipeline the INLINE
pragma is switched on. Inlining happens only during runs of the
<em>simplifier</em>. Each run of the simplifier has a different <em>phase number</em>;
the phase number decreases towards zero. If you use
<code class="docutils literal"><span class="pre">-dverbose-core2core</span></code> you&#8217;ll see the sequence of phase numbers for
successive runs of the simplifier. In an INLINE pragma you can
optionally specify a phase number, thus:</p>
<ul class="simple">
<li>&#8220;<code class="docutils literal"><span class="pre">INLINE[k]</span> <span class="pre">f</span></code>&#8221; means: do not inline <code class="docutils literal"><span class="pre">f</span></code> until phase <code class="docutils literal"><span class="pre">k</span></code>, but
from phase <code class="docutils literal"><span class="pre">k</span></code> onwards be very keen to inline it.</li>
<li>&#8220;<code class="docutils literal"><span class="pre">INLINE[~k]</span> <span class="pre">f</span></code>&#8221; means: be very keen to inline <code class="docutils literal"><span class="pre">f</span></code> until phase
<code class="docutils literal"><span class="pre">k</span></code>, but from phase <code class="docutils literal"><span class="pre">k</span></code> onwards do not inline it.</li>
<li>&#8220;<code class="docutils literal"><span class="pre">NOINLINE[k]</span> <span class="pre">f</span></code>&#8221; means: do not inline <code class="docutils literal"><span class="pre">f</span></code> until phase <code class="docutils literal"><span class="pre">k</span></code>, but
from phase <code class="docutils literal"><span class="pre">k</span></code> onwards be willing to inline it (as if there was no
pragma).</li>
<li>&#8220;<code class="docutils literal"><span class="pre">NOINLINE[~k]</span> <span class="pre">f</span></code>&#8221; means: be willing to inline <code class="docutils literal"><span class="pre">f</span></code> until phase
<code class="docutils literal"><span class="pre">k</span></code>, but from phase <code class="docutils literal"><span class="pre">k</span></code> onwards do not inline it.</li>
</ul>
<p>The same information is summarised here:</p>
<div class="highlight-haskell"><div class="highlight"><pre>                         <span class="c1">-- Before phase 2     Phase 2 and later</span>
<span class="cm">{-# INLINE   [2]  f #-}</span>  <span class="c1">--      No                 Yes</span>
<span class="cm">{-# INLINE   [~2] f #-}</span>  <span class="c1">--      Yes                No</span>
<span class="cm">{-# NOINLINE [2]  f #-}</span>  <span class="c1">--      No                 Maybe</span>
<span class="cm">{-# NOINLINE [~2] f #-}</span>  <span class="c1">--      Maybe              No</span>

<span class="cm">{-# INLINE   f #-}</span>       <span class="c1">--      Yes                Yes</span>
<span class="cm">{-# NOINLINE f #-}</span>       <span class="c1">--      No                 No</span>
</pre></div>
</div>
<p>By &#8220;Maybe&#8221; we mean that the usual heuristic inlining rules apply (if the
function body is small, or it is applied to interesting-looking
arguments etc). Another way to understand the semantics is this:</p>
<ul class="simple">
<li>For both INLINE and NOINLINE, the phase number says when inlining is
allowed at all.</li>
<li>The INLINE pragma has the additional effect of making the function
body look small, so that when inlining is allowed it is very likely
to happen.</li>
</ul>
<p>The same phase-numbering control is available for RULES
(<a class="reference internal" href="#rewrite-rules"><span>Rewrite rules</span></a>).</p>
</div>
</div>
<div class="section" id="line-pragma">
<span id="id76"></span><h2>10.31.7. <code class="docutils literal"><span class="pre">LINE</span></code> pragma<a class="headerlink" href="#line-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-34">This pragma is similar to C&#8217;s <code class="docutils literal"><span class="pre">#line</span></code> pragma, and is mainly for use in
automatically generated Haskell code. It lets you specify the line
number and filename of the original code; for example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LINE 42 &quot;Foo.vhs&quot; #-}</span>
</pre></div>
</div>
<p>if you&#8217;d generated the current file from something called <code class="docutils literal"><span class="pre">Foo.vhs</span></code>
and this line corresponds to line 42 in the original. GHC will adjust
its error messages to refer to the line/file named in the <code class="docutils literal"><span class="pre">LINE</span></code>
pragma.</p>
<p><code class="docutils literal"><span class="pre">LINE</span></code> pragmas generated from Template Haskell set the file and line
position for the duration of the splice and are limited to the splice.
Note that because Template Haskell splices abstract syntax, the file
positions are not automatically advanced.</p>
</div>
<div class="section" id="column-pragma">
<span id="id77"></span><h2>10.31.8. <code class="docutils literal"><span class="pre">COLUMN</span></code> pragma<a class="headerlink" href="#column-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-35">This is the analogue of the <code class="docutils literal"><span class="pre">LINE</span></code> pragma and is likewise intended for
use in automatically generated Haskell code. It lets you specify the
column number of the original code; for example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foo</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="cm">{-# COLUMN 42 #-}</span><span class="n">pure</span> <span class="nb">()</span>
  <span class="n">pure</span> <span class="nb">()</span>
</pre></div>
</div>
<p>This adjusts all column numbers immediately after the pragma to start
at 42.  The presence of this pragma only affects the quality of the
diagnostics and does not change the syntax of the code itself.</p>
</div>
<div class="section" id="rules-pragma">
<span id="rules"></span><h2>10.31.9. <code class="docutils literal"><span class="pre">RULES</span></code> pragma<a class="headerlink" href="#rules-pragma" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">RULES</span></code> pragma lets you specify rewrite rules. It is described in
<a class="reference internal" href="#rewrite-rules"><span>Rewrite rules</span></a>.</p>
</div>
<div class="section" id="specialize-pragma">
<span id="id78"></span><h2>10.31.10. <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> pragma<a class="headerlink" href="#specialize-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-36">(UK spelling also accepted.) For key overloaded functions, you can
create extra versions (NB: more code space) specialised to particular
types. Thus, if you have an overloaded function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">hammeredLookup</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">key</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">key</span> <span class="ow">-&gt;</span> <span class="n">value</span>
</pre></div>
</div>
<p>If it is heavily used on lists with <code class="docutils literal"><span class="pre">Widget</span></code> keys, you could
specialise it as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# SPECIALIZE hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}</span>
</pre></div>
</div>
<ul>
<li><p class="first">A <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> pragma for a function can be put anywhere its type
signature could be put. Moreover, you can also <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> an
<em>imported</em> function provided it was given an <code class="docutils literal"><span class="pre">INLINABLE</span></code> pragma at
its definition site (<a class="reference internal" href="#inlinable-pragma"><span>INLINABLE pragma</span></a>).</p>
</li>
<li><p class="first">A <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> has the effect of generating (a) a specialised
version of the function and (b) a rewrite rule (see
<a class="reference internal" href="#rewrite-rules"><span>Rewrite rules</span></a>) that rewrites a call to the un-specialised
function into a call to the specialised one. Moreover, given a
<code class="docutils literal"><span class="pre">SPECIALIZE</span></code> pragma for a function <code class="docutils literal"><span class="pre">f</span></code>, GHC will automatically
create specialisations for any type-class-overloaded functions called
by <code class="docutils literal"><span class="pre">f</span></code>, if they are in the same module as the <code class="docutils literal"><span class="pre">SPECIALIZE</span></code>
pragma, or if they are <code class="docutils literal"><span class="pre">INLINABLE</span></code>; and so on, transitively.</p>
</li>
<li><p class="first">You can add phase control (<a class="reference internal" href="#phase-control"><span>Phase control</span></a>) to the RULE
generated by a <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> pragma, just as you can if you write a
<code class="docutils literal"><span class="pre">RULE</span></code> directly. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# SPECIALIZE [0] hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}</span>
</pre></div>
</div>
<p>generates a specialisation rule that only fires in Phase 0 (the final
phase). If you do not specify any phase control in the <code class="docutils literal"><span class="pre">SPECIALIZE</span></code>
pragma, the phase control is inherited from the inline pragma (if
any) of the function. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="o">...</span><span class="n">blah</span><span class="o">...</span>
<span class="cm">{-# NOINLINE [0] foo #-}</span>
<span class="cm">{-# SPECIALIZE foo :: Int -&gt; Int #-}</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">NOINLINE</span></code> pragma tells GHC not to inline <code class="docutils literal"><span class="pre">foo</span></code> until Phase
0; and this property is inherited by the specialisation RULE, which
will therefore only fire in Phase 0.</p>
<p>The main reason for using phase control on specialisations is so that
you can write optimisation RULES that fire early in the compilation
pipeline, and only <em>then</em> specialise the calls to the function. If
specialisation is done too early, the optimisation rules might fail
to fire.</p>
</li>
<li><p class="first">The type in a SPECIALIZE pragma can be any type that is less
polymorphic than the type of the original function. In concrete
terms, if the original function is <code class="docutils literal"><span class="pre">f</span></code> then the pragma</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# SPECIALIZE f :: &lt;type&gt; #-}</span>
</pre></div>
</div>
<p>is valid if and only if the definition</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f_spec</span> <span class="ow">::</span> <span class="o">&lt;</span><span class="kr">type</span><span class="o">&gt;</span>
<span class="nf">f_spec</span> <span class="ow">=</span> <span class="n">f</span>
</pre></div>
</div>
<p>is valid. Here are some examples (where we only give the type
signature for the original function, not its code):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="cm">{-# SPECIALISE f :: Int -&gt; b -&gt; b #-}</span>

<span class="nf">g</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ix</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="cm">{-# SPECIALISE g :: (Eq a) =&gt; a -&gt; Int -&gt; Int #-}</span>

<span class="nf">h</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="cm">{-# SPECIALISE h :: (Eq a) =&gt; [a] -&gt; [a] -&gt; [a] #-}</span>
</pre></div>
</div>
<p>The last of these examples will generate a RULE with a
somewhat-complex left-hand side (try it yourself), so it might not
fire very well. If you use this kind of specialisation, let us know
how well it works.</p>
</li>
</ul>
<div class="section" id="specialize-inline">
<span id="id79"></span><h3>10.31.10.1. <code class="docutils literal"><span class="pre">SPECIALIZE</span> <span class="pre">INLINE</span></code><a class="headerlink" href="#specialize-inline" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> pragma can optionally be followed with a <code class="docutils literal"><span class="pre">INLINE</span></code> or
<code class="docutils literal"><span class="pre">NOINLINE</span></code> pragma, optionally followed by a phase, as described in
<a class="reference internal" href="#inline-noinline-pragma"><span>INLINE and NOINLINE pragmas</span></a>. The <code class="docutils literal"><span class="pre">INLINE</span></code> pragma affects the
specialised version of the function (only), and applies even if the
function is recursive. The motivating example is this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- A GADT for arrays with type-indexed representation</span>
<span class="kr">data</span> <span class="kt">Arr</span> <span class="n">e</span> <span class="kr">where</span>
  <span class="kt">ArrInt</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">ByteArray</span><span class="o">#</span> <span class="ow">-&gt;</span> <span class="kt">Arr</span> <span class="kt">Int</span>
  <span class="kt">ArrPair</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Arr</span> <span class="n">e1</span> <span class="ow">-&gt;</span> <span class="kt">Arr</span> <span class="n">e2</span> <span class="ow">-&gt;</span> <span class="kt">Arr</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>

<span class="p">(</span><span class="o">!:</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Arr</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">e</span>
<span class="cm">{-# SPECIALISE INLINE (!:) :: Arr Int -&gt; Int -&gt; Int #-}</span>
<span class="cm">{-# SPECIALISE INLINE (!:) :: Arr (a, b) -&gt; Int -&gt; (a, b) #-}</span>
<span class="p">(</span><span class="kt">ArrInt</span> <span class="kr">_</span> <span class="n">ba</span><span class="p">)</span>     <span class="o">!:</span> <span class="p">(</span><span class="kt">I</span><span class="o">#</span> <span class="n">i</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">I</span><span class="o">#</span> <span class="p">(</span><span class="n">indexIntArray</span><span class="o">#</span> <span class="n">ba</span> <span class="n">i</span><span class="p">)</span>
<span class="p">(</span><span class="kt">ArrPair</span> <span class="kr">_</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">)</span> <span class="o">!:</span> <span class="n">i</span>      <span class="ow">=</span> <span class="p">(</span><span class="n">a1</span> <span class="o">!:</span> <span class="n">i</span><span class="p">,</span> <span class="n">a2</span> <span class="o">!:</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">(!:)</span></code> is a recursive function that indexes arrays of type
<code class="docutils literal"><span class="pre">Arr</span> <span class="pre">e</span></code>. Consider a call to <code class="docutils literal"><span class="pre">(!:)</span></code> at type <code class="docutils literal"><span class="pre">(Int,Int)</span></code>. The second
specialisation will fire, and the specialised function will be inlined.
It has two calls to <code class="docutils literal"><span class="pre">(!:)</span></code>, both at type <code class="docutils literal"><span class="pre">Int</span></code>. Both these calls
fire the first specialisation, whose body is also inlined. The result is
a type-based unrolling of the indexing function.</p>
<p>You can add explicit phase control (<a class="reference internal" href="#phase-control"><span>Phase control</span></a>) to
<code class="docutils literal"><span class="pre">SPECIALISE</span> <span class="pre">INLINE</span></code> pragma, just like on an <code class="docutils literal"><span class="pre">INLINE</span></code> pragma; if you
do so, the same phase is used for the rewrite rule and the INLINE
control of the specialised function.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You can make GHC diverge by using <code class="docutils literal"><span class="pre">SPECIALISE</span> <span class="pre">INLINE</span></code> on an
ordinarily-recursive function.</p>
</div>
</div>
<div class="section" id="specialize-for-imported-functions">
<h3>10.31.10.2. <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> for imported functions<a class="headerlink" href="#specialize-for-imported-functions" title="Permalink to this headline">¶</a></h3>
<p>Generally, you can only give a <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> pragma for a function
defined in the same module. However if a function <code class="docutils literal"><span class="pre">f</span></code> is given an
<code class="docutils literal"><span class="pre">INLINABLE</span></code> pragma at its definition site, then it can subsequently be
specialised by importing modules (see <a class="reference internal" href="#inlinable-pragma"><span>INLINABLE pragma</span></a>). For example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Map</span><span class="p">(</span> <span class="n">lookup</span><span class="p">,</span> <span class="n">blah</span> <span class="n">blah</span> <span class="p">)</span> <span class="kr">where</span>
  <span class="n">lookup</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">key</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span><span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">key</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
  <span class="n">lookup</span> <span class="ow">=</span> <span class="o">...</span>
  <span class="cm">{-# INLINABLE lookup #-}</span>

<span class="kr">module</span> <span class="nn">Client</span> <span class="kr">where</span>
  <span class="kr">import</span> <span class="nn">Map</span><span class="p">(</span> <span class="n">lookup</span> <span class="p">)</span>

  <span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T1</span> <span class="o">|</span> <span class="kt">T2</span> <span class="kr">deriving</span><span class="p">(</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span> <span class="p">)</span>
  <span class="cm">{-# SPECIALISE lookup :: [(T,a)] -&gt; T -&gt; Maybe a</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">lookup</span></code> is declared <code class="docutils literal"><span class="pre">INLINABLE</span></code>, but it cannot be specialised
for type <code class="docutils literal"><span class="pre">T</span></code> at its definition site, because that type does not exist
yet. Instead a client module can define <code class="docutils literal"><span class="pre">T</span></code> and then specialise
<code class="docutils literal"><span class="pre">lookup</span></code> at that type.</p>
<p>Moreover, every module that imports <code class="docutils literal"><span class="pre">Client</span></code> (or imports a module that
imports <code class="docutils literal"><span class="pre">Client</span></code>, transitively) will &#8220;see&#8221;, and make use of, the
specialised version of <code class="docutils literal"><span class="pre">lookup</span></code>. You don&#8217;t need to put a
<code class="docutils literal"><span class="pre">SPECIALIZE</span></code> pragma in every module.</p>
<p>Moreover you often don&#8217;t even need the <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> pragma in the
first place. When compiling a module <code class="docutils literal"><span class="pre">M</span></code>, GHC&#8217;s optimiser (when given the
<a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a> flag) automatically considers each top-level overloaded function declared
in <code class="docutils literal"><span class="pre">M</span></code>, and specialises it for the different types at which it is called in
<code class="docutils literal"><span class="pre">M</span></code>. The optimiser <em>also</em> considers each <em>imported</em> <code class="docutils literal"><span class="pre">INLINABLE</span></code>
overloaded function, and specialises it for the different types at which
it is called in <code class="docutils literal"><span class="pre">M</span></code>. So in our example, it would be enough for <code class="docutils literal"><span class="pre">lookup</span></code>
to be called at type <code class="docutils literal"><span class="pre">T</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Client</span> <span class="kr">where</span>
  <span class="kr">import</span> <span class="nn">Map</span><span class="p">(</span> <span class="n">lookup</span> <span class="p">)</span>

  <span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T1</span> <span class="o">|</span> <span class="kt">T2</span> <span class="kr">deriving</span><span class="p">(</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span> <span class="p">)</span>

  <span class="n">findT1</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">T</span><span class="p">,</span><span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
  <span class="n">findT1</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="n">m</span> <span class="kt">T1</span>   <span class="c1">-- A call of lookup at type T</span>
</pre></div>
</div>
<p>However, sometimes there are no such calls, in which case the pragma can
be useful.</p>
</div>
<div class="section" id="obsolete-specialize-syntax">
<h3>10.31.10.3. Obsolete <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> syntax<a class="headerlink" href="#obsolete-specialize-syntax" title="Permalink to this headline">¶</a></h3>
<p>In earlier versions of GHC, it was possible to provide your own
specialised function for a given type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# SPECIALIZE hammeredLookup :: [(Int, value)] -&gt; Int -&gt; value = intLookup #-}</span>
</pre></div>
</div>
<p>This feature has been removed, as it is now subsumed by the <code class="docutils literal"><span class="pre">RULES</span></code>
pragma (see <a class="reference internal" href="#rule-spec"><span>Specialisation</span></a>).</p>
</div>
</div>
<div class="section" id="specialize-instance-pragma">
<span id="id80"></span><h2>10.31.11. <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> instance pragma<a class="headerlink" href="#specialize-instance-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-37">Same idea, except for instance declarations. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Foo</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="p">{</span>
   <span class="cm">{-# SPECIALIZE instance Eq (Foo [(Int, Bar)]) #-}</span>
   <span class="o">...</span> <span class="n">usual</span> <span class="n">stuff</span> <span class="o">...</span>
 <span class="p">}</span>
</pre></div>
</div>
<p>The pragma must occur inside the <code class="docutils literal"><span class="pre">where</span></code> part of the instance
declaration.</p>
</div>
<div class="section" id="unpack-pragma">
<span id="id81"></span><h2>10.31.12. <code class="docutils literal"><span class="pre">UNPACK</span></code> pragma<a class="headerlink" href="#unpack-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-38">The <code class="docutils literal"><span class="pre">UNPACK</span></code> indicates to the compiler that it should unpack the
contents of a constructor field into the constructor itself, removing a
level of indirection. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T</span> <span class="cm">{-# UNPACK #-}</span> <span class="o">!</span><span class="kt">Float</span>
           <span class="cm">{-# UNPACK #-}</span> <span class="o">!</span><span class="kt">Float</span>
</pre></div>
</div>
<p>will create a constructor <code class="docutils literal"><span class="pre">T</span></code> containing two unboxed floats. This may
not always be an optimisation: if the <code class="docutils literal"><span class="pre">T</span></code> constructor is scrutinised
and the floats passed to a non-strict function for example, they will
have to be reboxed (this is done automatically by the compiler).</p>
<p>Unpacking constructor fields should only be used in conjunction with
<a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a> <a class="footnote-reference" href="#id83" id="id82">[1]</a>, in order to expose unfoldings to the compiler so the
reboxing can be removed as often as possible. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="ow">::</span> <span class="kt">T</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">T</span> <span class="n">f1</span> <span class="n">f2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span>
</pre></div>
</div>
<p>The compiler will avoid reboxing <code class="docutils literal"><span class="pre">f1</span></code> and <code class="docutils literal"><span class="pre">f2</span></code> by inlining <code class="docutils literal"><span class="pre">+</span></code> on
floats, but only when <a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a> is on.</p>
<p>Any single-constructor data is eligible for unpacking; for example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T</span> <span class="cm">{-# UNPACK #-}</span> <span class="o">!</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
<p>will store the two <code class="docutils literal"><span class="pre">Int</span></code>s directly in the <code class="docutils literal"><span class="pre">T</span></code> constructor, by
flattening the pair. Multi-level unpacking is also supported:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T</span> <span class="cm">{-# UNPACK #-}</span> <span class="o">!</span><span class="kt">S</span>
<span class="kr">data</span> <span class="kt">S</span> <span class="ow">=</span> <span class="kt">S</span> <span class="cm">{-# UNPACK #-}</span> <span class="o">!</span><span class="kt">Int</span> <span class="cm">{-# UNPACK #-}</span> <span class="o">!</span><span class="kt">Int</span>
</pre></div>
</div>
<p>will store two unboxed <code class="docutils literal"><span class="pre">Int#</span></code>s directly in the <code class="docutils literal"><span class="pre">T</span></code> constructor.
The unpacker can see through newtypes, too.</p>
<p>See also the <a class="reference internal" href="using-optimisation.html#ghc-flag--funbox-strict-fields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-funbox-strict-fields</span></code></a> flag, which essentially has the
effect of adding <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">UNPACK</span> <span class="pre">#-}</span></code> to every strict constructor field.</p>
<table class="docutils footnote" frame="void" id="id83" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id82">[1]</a></td><td>in fact, UNPACK has no effect without
-O
, for technical reasons (see
tick 5252
)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="nounpack-pragma">
<span id="id84"></span><h2>10.31.13. <code class="docutils literal"><span class="pre">NOUNPACK</span></code> pragma<a class="headerlink" href="#nounpack-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-39">The <code class="docutils literal"><span class="pre">NOUNPACK</span></code> pragma indicates to the compiler that it should not
unpack the contents of a constructor field. Example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T</span> <span class="cm">{-# NOUNPACK #-}</span> <span class="o">!</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
<p>Even with the flags <a class="reference internal" href="using-optimisation.html#ghc-flag--funbox-strict-fields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-funbox-strict-fields</span></code></a> and <a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a>, the
field of the constructor <code class="docutils literal"><span class="pre">T</span></code> is not unpacked.</p>
</div>
<div class="section" id="source-pragma">
<span id="id85"></span><h2>10.31.14. <code class="docutils literal"><span class="pre">SOURCE</span></code> pragma<a class="headerlink" href="#source-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-40">The <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code> pragma is used only in <code class="docutils literal"><span class="pre">import</span></code> declarations,
to break a module loop. It is described in detail in
<a class="reference internal" href="separate_compilation.html#mutual-recursion"><span>How to compile mutually recursive modules</span></a>.</p>
</div>
<div class="section" id="complete-pragmas">
<span id="complete-pragma"></span><h2>10.31.15. <code class="docutils literal"><span class="pre">COMPLETE</span></code> pragmas<a class="headerlink" href="#complete-pragmas" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">COMPLETE</span></code> pragma is used to inform the pattern match checker that a
certain set of patterns is complete and that any function which matches
on all the specified patterns is total.</p>
<p>The most common usage of <code class="docutils literal"><span class="pre">COMPLETE</span></code> pragmas is with
<a class="reference internal" href="#pattern-synonyms"><span>Pattern synonyms</span></a>.
On its own, the checker is very naive and assumes that any match involving
a pattern synonym will fail. As a result, any pattern match on a
pattern synonym is regarded as
incomplete unless the user adds a catch-all case.</p>
<p>For example, the data types <code class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">A</span></code> are isomorphic but some
computations are more naturally expressed in terms of one or the other. To
get the best of both worlds, we can choose one as our implementation and then
provide a set of pattern synonyms so that users can use the other representation
if they desire. We can then specify a <code class="docutils literal"><span class="pre">COMPLETE</span></code> pragma in order to
inform the pattern match checker that a function which matches on both <code class="docutils literal"><span class="pre">LeftChoice</span></code>
and <code class="docutils literal"><span class="pre">RightChoice</span></code> is total.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Choice</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Choice</span> <span class="kt">Bool</span> <span class="n">a</span>

<span class="nf">pattern</span> <span class="kt">LeftChoice</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Choice</span> <span class="n">a</span>
<span class="nf">pattern</span> <span class="kt">LeftChoice</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Choice</span> <span class="kt">False</span> <span class="n">a</span>

<span class="nf">pattern</span> <span class="kt">RightChoice</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Choice</span> <span class="n">a</span>
<span class="nf">pattern</span> <span class="kt">RightChoice</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Choice</span> <span class="kt">True</span> <span class="n">a</span>

<span class="cm">{-# COMPLETE LeftChoice, RightChoice #-}</span>

<span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Choice</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="p">(</span><span class="kt">LeftChoice</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span>
<span class="nf">foo</span> <span class="p">(</span><span class="kt">RightChoice</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">COMPLETE</span></code> pragmas are only used by the pattern match checker. If a function
definition matches on all the constructors specified in the pragma then the
compiler will produce no warning.</p>
<p><code class="docutils literal"><span class="pre">COMPLETE</span></code> pragmas can contain any data constructors or pattern
synonyms which are in scope, but must mention at least one data
constructor or pattern synonym defined in the same module.
<code class="docutils literal"><span class="pre">COMPLETE</span></code> pragmas may only appear at the top level of a module.
Once defined, they are automatically imported and exported from
modules. <code class="docutils literal"><span class="pre">COMPLETE</span></code> pragmas should be thought of as asserting a
universal truth about a set of patterns and as a result, should not be
used to silence context specific incomplete match warnings.</p>
<p>When specifing a <code class="docutils literal"><span class="pre">COMPLETE</span></code> pragma, the result types of all patterns must
be consistent with each other. This is a sanity check as it would be impossible
to match on all the patterns if the types were inconsistent.</p>
<p>The result type must also be unambiguous. Usually this can be inferred but
when all the pattern synonyms in a group are polymorphic in the constructor
the user must provide a type signature.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">LL</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">go</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span>

<span class="kr">instance</span> <span class="kt">LL</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">go</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="nf">pattern</span> <span class="kt">T</span> <span class="ow">::</span> <span class="kt">LL</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="nf">pattern</span> <span class="kt">T</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="n">go</span> <span class="ow">-&gt;</span> <span class="nb">()</span><span class="p">)</span>

<span class="cm">{-# COMPLETE T :: [] #-}</span>

<span class="c1">-- No warning</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="kt">T</span> <span class="ow">=</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
<div class="section" id="overlapping-overlappable-overlaps-and-incoherent-pragmas">
<span id="overlap-pragma"></span><h2>10.31.16. <code class="docutils literal"><span class="pre">OVERLAPPING</span></code>, <code class="docutils literal"><span class="pre">OVERLAPPABLE</span></code>, <code class="docutils literal"><span class="pre">OVERLAPS</span></code>, and <code class="docutils literal"><span class="pre">INCOHERENT</span></code> pragmas<a class="headerlink" href="#overlapping-overlappable-overlaps-and-incoherent-pragmas" title="Permalink to this headline">¶</a></h2>
<p id="index-41">The pragmas <code class="docutils literal"><span class="pre">OVERLAPPING</span></code>, <code class="docutils literal"><span class="pre">OVERLAPPABLE</span></code>, <code class="docutils literal"><span class="pre">OVERLAPS</span></code>,
<code class="docutils literal"><span class="pre">INCOHERENT</span></code> are used to specify the overlap behavior for individual
instances, as described in Section <a class="reference internal" href="#instance-overlap"><span>Overlapping instances</span></a>. The pragmas
are written immediately after the <code class="docutils literal"><span class="pre">instance</span></code> keyword, like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="cm">{-# OVERLAPPING #-}</span> <span class="kt">C</span> <span class="n">t</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="rewrite-rules">
<span id="id86"></span><h1>10.32. Rewrite rules<a class="headerlink" href="#rewrite-rules" title="Permalink to this headline">¶</a></h1>
<p id="index-42">The programmer can specify rewrite rules as part of the source program
(in a pragma). Here is an example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# RULES</span>
<span class="cm">&quot;map/map&quot;    forall f g xs.  map f (map g xs) = map (f.g) xs</span>
<span class="cm">  #-}</span>
</pre></div>
</div>
<p>Use the debug flag <a class="reference internal" href="debugging.html#ghc-flag--ddump-simpl-stats"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-simpl-stats</span></code></a> to see what rules fired. If
you need more information, then <a class="reference internal" href="debugging.html#ghc-flag--ddump-rule-firings"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-rule-firings</span></code></a> shows you each
individual rule firing and <a class="reference internal" href="debugging.html#ghc-flag--ddump-rule-rewrites"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-rule-rewrites</span></code></a> also shows what the
code looks like before and after the rewrite.</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fenable-rewrite-rules">
<code class="descname">-fenable-rewrite-rules</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fenable-rewrite-rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the compiler to apply rewrite rules to the source program.</p>
</dd></dl>

<div class="section" id="id87">
<h2>10.32.1. Syntax<a class="headerlink" href="#id87" title="Permalink to this headline">¶</a></h2>
<p>From a syntactic point of view:</p>
<ul>
<li><p class="first">There may be zero or more rules in a <code class="docutils literal"><span class="pre">RULES</span></code> pragma, separated by
semicolons (which may be generated by the layout rule).</p>
</li>
<li><p class="first">The layout rule applies in a pragma. Currently no new indentation
level is set, so if you put several rules in single RULES pragma and
wish to use layout to separate them, you must lay out the starting in
the same column as the enclosing definitions.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# RULES</span>
<span class="cm">&quot;map/map&quot;    forall f g xs.  map f (map g xs) = map (f.g) xs</span>
<span class="cm">&quot;map/append&quot; forall f xs ys. map f (xs ++ ys) = map f xs ++ map f ys</span>
<span class="cm">  #-}</span>
</pre></div>
</div>
<p>Furthermore, the closing <code class="docutils literal"><span class="pre">#-}</span></code> should start in a column to the
right of the opening <code class="docutils literal"><span class="pre">{-#</span></code>.</p>
</li>
<li><p class="first">Each rule has a name, enclosed in double quotes. The name itself has
no significance at all. It is only used when reporting how many times
the rule fired.</p>
</li>
<li><p class="first">A rule may optionally have a phase-control number (see
<a class="reference internal" href="#phase-control"><span>Phase control</span></a>), immediately after the name of the rule. Thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# RULES</span>
<span class="cm">      &quot;map/map&quot; [2]  forall f g xs. map f (map g xs) = map (f.g) xs</span>
<span class="cm">  #-}</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">[2]</span></code> means that the rule is active in Phase 2 and subsequent
phases. The inverse notation <code class="docutils literal"><span class="pre">[~2]</span></code> is also accepted, meaning that
the rule is active up to, but not including, Phase 2.</p>
<p>Rules support the special phase-control notation <code class="docutils literal"><span class="pre">[~]</span></code>, which means
the rule is never active. This feature supports plugins (see
<a class="reference internal" href="extending_ghc.html#compiler-plugins"><span>Compiler Plugins</span></a>), by making it possible to define a RULE that
is never run by GHC, but is nevertheless parsed, typechecked etc, so
that it is available to the plugin.</p>
</li>
<li><p class="first">Each variable mentioned in a rule must either be in scope (e.g.
<code class="docutils literal"><span class="pre">map</span></code>), or bound by the <code class="docutils literal"><span class="pre">forall</span></code> (e.g. <code class="docutils literal"><span class="pre">f</span></code>, <code class="docutils literal"><span class="pre">g</span></code>, <code class="docutils literal"><span class="pre">xs</span></code>). The
variables bound by the <code class="docutils literal"><span class="pre">forall</span></code> are called the <em>pattern</em> variables.
They are separated by spaces, just like in a type <code class="docutils literal"><span class="pre">forall</span></code>.</p>
</li>
<li><p class="first">A pattern variable may optionally have a type signature. If the type
of the pattern variable is polymorphic, it <em>must</em> have a type
signature. For example, here is the <code class="docutils literal"><span class="pre">foldr/build</span></code> rule:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="s">&quot;fold/build&quot;</span>  <span class="n">forall</span> <span class="n">k</span> <span class="n">z</span> <span class="p">(</span><span class="n">g</span><span class="ow">::</span><span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">.</span>
              <span class="n">foldr</span> <span class="n">k</span> <span class="n">z</span> <span class="p">(</span><span class="n">build</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="n">g</span> <span class="n">k</span> <span class="n">z</span>
</pre></div>
</div>
<p>Since <code class="docutils literal"><span class="pre">g</span></code> has a polymorphic type, it must have a type signature.</p>
</li>
<li><p class="first">The left hand side of a rule must consist of a top-level variable
applied to arbitrary expressions. For example, this is <em>not</em> OK:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="s">&quot;wrong1&quot;</span>   <span class="n">forall</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">.</span>  <span class="kr">case</span> <span class="kt">True</span> <span class="kr">of</span> <span class="p">{</span> <span class="kt">True</span> <span class="ow">-&gt;</span> <span class="n">e1</span><span class="p">;</span> <span class="kt">False</span> <span class="ow">-&gt;</span> <span class="n">e2</span> <span class="p">}</span> <span class="ow">=</span> <span class="n">e1</span>
<span class="s">&quot;wrong2&quot;</span>   <span class="n">forall</span> <span class="n">f</span><span class="o">.</span>      <span class="n">f</span> <span class="kt">True</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="s">&quot;wrong3&quot;</span>   <span class="n">forall</span> <span class="n">x</span><span class="o">.</span>      <span class="kt">Just</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>In <code class="docutils literal"><span class="pre">&quot;wrong1&quot;</span></code>, the LHS is not an application; in <code class="docutils literal"><span class="pre">&quot;wrong2&quot;</span></code>, the
LHS has a pattern variable in the head. In <code class="docutils literal"><span class="pre">&quot;wrong3&quot;</span></code>, the LHS consists
of a <em>constructor</em>, rather than a <em>variable</em>, applied to an argument.</p>
</li>
<li><p class="first">A rule does not need to be in the same module as (any of) the
variables it mentions, though of course they need to be in scope.</p>
</li>
<li><p class="first">All rules are implicitly exported from the module, and are therefore
in force in any module that imports the module that defined the rule,
directly or indirectly. (That is, if A imports B, which imports C,
then C&#8217;s rules are in force when compiling A.) The situation is very
similar to that for instance declarations.</p>
</li>
<li><p class="first">Inside a RULE &#8220;<code class="docutils literal"><span class="pre">forall</span></code>&#8221; is treated as a keyword, regardless of any
other flag settings. Furthermore, inside a RULE, the language
extension <a class="reference internal" href="#ghc-flag--XScopedTypeVariables"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XScopedTypeVariables</span></code></a> is automatically enabled; see
<a class="reference internal" href="#scoped-type-variables"><span>Lexically scoped type variables</span></a>.</p>
</li>
<li><p class="first">Like other pragmas, RULE pragmas are always checked for scope errors,
and are typechecked. Typechecking means that the LHS and RHS of a
rule are typechecked, and must have the same type. However, rules are
only <em>enabled</em> if the <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fenable-rewrite-rules</span></code></a> flag is on (see
<a class="reference internal" href="#rule-semantics"><span>Semantics</span></a>).</p>
</li>
</ul>
</div>
<div class="section" id="semantics">
<span id="rule-semantics"></span><h2>10.32.2. Semantics<a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h2>
<p>From a semantic point of view:</p>
<ul>
<li><p class="first">Rules are enabled (that is, used during optimisation) by the
<a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fenable-rewrite-rules</span></code></a> flag. This flag is implied by
<a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a>, and may be switched off (as usual) by
<a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fno-enable-rewrite-rules</span></code></a>. (NB: enabling
<a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fenable-rewrite-rules</span></code></a> without <a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a> may not do what you
expect, though, because without <a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a> GHC ignores all optimisation
information in interface files; see <a class="reference internal" href="using-optimisation.html#ghc-flag--fignore-interface-pragmas"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fignore-interface-pragmas</span></code></a>).
Note that <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fenable-rewrite-rules</span></code></a> is an
<em>optimisation</em> flag, and has no effect on parsing or typechecking.</p>
</li>
<li><p class="first">Rules are regarded as left-to-right rewrite rules. When GHC finds an
expression that is a substitution instance of the LHS of a rule, it
replaces the expression by the (appropriately-substituted) RHS. By &#8220;a
substitution instance&#8221; we mean that the LHS can be made equal to the
expression by substituting for the pattern variables.</p>
</li>
<li><p class="first">GHC makes absolutely no attempt to verify that the LHS and RHS of a
rule have the same meaning. That is undecidable in general, and
infeasible in most interesting cases. The responsibility is entirely
the programmer&#8217;s!</p>
</li>
<li><p class="first">GHC makes no attempt to make sure that the rules are confluent or
terminating. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="s">&quot;loop&quot;</span>        <span class="n">forall</span> <span class="n">x</span> <span class="n">y</span><span class="o">.</span>  <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span>
</pre></div>
</div>
<p>This rule will cause the compiler to go into an infinite loop.</p>
</li>
<li><p class="first">If more than one rule matches a call, GHC will choose one arbitrarily
to apply.</p>
</li>
<li><p class="first">GHC currently uses a very simple, syntactic, matching algorithm for
matching a rule LHS with an expression. It seeks a substitution which
makes the LHS and expression syntactically equal modulo alpha
conversion. The pattern (rule), but not the expression, is
eta-expanded if necessary. (Eta-expanding the expression can lead to
laziness bugs.) But not beta conversion (that&#8217;s called higher-order
matching).</p>
<p>Matching is carried out on GHC&#8217;s intermediate language, which
includes type abstractions and applications. So a rule only matches
if the types match too. See <a class="reference internal" href="#rule-spec"><span>Specialisation</span></a> below.</p>
</li>
<li><p class="first">GHC keeps trying to apply the rules as it optimises the program. For
example, consider:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">f</span>
    <span class="n">t</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">g</span>
<span class="kr">in</span>
<span class="nf">s</span> <span class="p">(</span><span class="n">t</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>The expression <code class="docutils literal"><span class="pre">s</span> <span class="pre">(t</span> <span class="pre">xs)</span></code> does not match the rule <code class="docutils literal"><span class="pre">&quot;map/map&quot;</span></code>,
but GHC will substitute for <code class="docutils literal"><span class="pre">s</span></code> and <code class="docutils literal"><span class="pre">t</span></code>, giving an expression
which does match. If <code class="docutils literal"><span class="pre">s</span></code> or <code class="docutils literal"><span class="pre">t</span></code> was (a) used more than once, and
(b) large or a redex, then it would not be substituted, and the rule
would not fire.</p>
</li>
</ul>
</div>
<div class="section" id="how-rules-interact-with-inline-noinline-pragmas">
<span id="rules-inline"></span><h2>10.32.3. How rules interact with <code class="docutils literal"><span class="pre">INLINE</span></code>/<code class="docutils literal"><span class="pre">NOINLINE</span></code> pragmas<a class="headerlink" href="#how-rules-interact-with-inline-noinline-pragmas" title="Permalink to this headline">¶</a></h2>
<p>Ordinary inlining happens at the same time as rule rewriting, which may
lead to unexpected results. Consider this (artificial) example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">g</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">y</span>
<span class="nf">h</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">g</span> <span class="kt">True</span>

<span class="cm">{-# RULES &quot;f&quot; f True = False #-}</span>
</pre></div>
</div>
<p>Since <code class="docutils literal"><span class="pre">f</span></code>&#8216;s right-hand side is small, it is inlined into <code class="docutils literal"><span class="pre">g</span></code>, to
give</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">g</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">y</span>
</pre></div>
</div>
<p>Now <code class="docutils literal"><span class="pre">g</span></code> is inlined into <code class="docutils literal"><span class="pre">h</span></code>, but <code class="docutils literal"><span class="pre">f</span></code>&#8216;s RULE has no chance to fire.
If instead GHC had first inlined <code class="docutils literal"><span class="pre">g</span></code> into <code class="docutils literal"><span class="pre">h</span></code> then there would have
been a better chance that <code class="docutils literal"><span class="pre">f</span></code>&#8216;s RULE might fire.</p>
<p>The way to get predictable behaviour is to use a NOINLINE pragma, or an
INLINE[⟨phase⟩] pragma, on <code class="docutils literal"><span class="pre">f</span></code>, to ensure that it is not inlined until
its RULEs have had a chance to fire. The warning flag
<a class="reference internal" href="using-warnings.html#ghc-flag--Winline-rule-shadowing"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Winline-rule-shadowing</span></code></a> (see <a class="reference internal" href="using-warnings.html#options-sanity"><span>Warnings and sanity-checking</span></a>) warns about
this situation.</p>
</div>
<div class="section" id="how-rules-interact-with-conlike-pragmas">
<span id="conlike"></span><h2>10.32.4. How rules interact with CONLIKE pragmas<a class="headerlink" href="#how-rules-interact-with-conlike-pragmas" title="Permalink to this headline">¶</a></h2>
<p>GHC is very cautious about duplicating work. For example, consider</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">k</span> <span class="n">z</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">build</span> <span class="n">g</span>
           <span class="kr">in</span> <span class="o">...</span><span class="p">(</span><span class="n">foldr</span> <span class="n">k</span> <span class="n">z</span> <span class="n">xs</span><span class="p">)</span><span class="o">...</span><span class="n">sum</span> <span class="n">xs</span><span class="o">...</span>
<span class="cm">{-# RULES &quot;foldr/build&quot; forall k z g. foldr k z (build g) = g k z #-}</span>
</pre></div>
</div>
<p>Since <code class="docutils literal"><span class="pre">xs</span></code> is used twice, GHC does not fire the foldr/build rule.
Rightly so, because it might take a lot of work to compute <code class="docutils literal"><span class="pre">xs</span></code>, which
would be duplicated if the rule fired.</p>
<p>Sometimes, however, this approach is over-cautious, and we <em>do</em> want the
rule to fire, even though doing so would duplicate redex. There is no
way that GHC can work out when this is a good idea, so we provide the
CONLIKE pragma to declare it, thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# INLINE CONLIKE [1] f #-}</span>
<span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">blah</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">CONLIKE</span></code> is a modifier to an <code class="docutils literal"><span class="pre">INLINE</span></code> or <code class="docutils literal"><span class="pre">NOINLINE</span></code> pragma. It specifies that
an application of <code class="docutils literal"><span class="pre">f</span></code> to one argument (in general, the number of arguments
to the left of the <code class="docutils literal"><span class="pre">=</span></code> sign) should be considered cheap enough to
duplicate, if such a duplication would make rule fire. (The name
&#8220;CONLIKE&#8221; is short for &#8220;constructor-like&#8221;, because constructors
certainly have such a property.) The CONLIKE pragma is a modifier to
INLINE/NOINLINE because it really only makes sense to match <code class="docutils literal"><span class="pre">f</span></code> on the
LHS of a rule if you are sure that <code class="docutils literal"><span class="pre">f</span></code> is not going to be inlined
before the rule has a chance to fire.</p>
</div>
<div class="section" id="how-rules-interact-with-class-methods">
<span id="rules-class-methods"></span><h2>10.32.5. How rules interact with class methods<a class="headerlink" href="#how-rules-interact-with-class-methods" title="Permalink to this headline">¶</a></h2>
<p>Giving a RULE for a class method is a bad idea:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">op</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">C</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="n">op</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="o">...</span><span class="n">rhs</span> <span class="n">for</span> <span class="n">op</span> <span class="n">at</span> <span class="kt">Bool</span><span class="o">...</span>

<span class="cm">{-# RULES &quot;f&quot; op True y = False #-}</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal"><span class="pre">op</span></code> is not an ordinary top-level function; it is a
class method. GHC rapidly rewrites any occurrences of
<code class="docutils literal"><span class="pre">op</span></code>-used-at-type-Bool to a specialised function, say <code class="docutils literal"><span class="pre">opBool</span></code>,
where</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">opBool</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">opBool</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="o">..</span><span class="n">rhs</span> <span class="n">for</span> <span class="n">op</span> <span class="n">at</span> <span class="kt">Bool</span><span class="o">...</span>
</pre></div>
</div>
<p>So the RULE never has a chance to fire, for just the same reasons as in
<a class="reference internal" href="#rules-inline"><span>How rules interact with INLINE/NOINLINE pragmas</span></a>.</p>
<p>The solution is to define the instance-specific function yourself, with
a pragma to prevent it being inlined too early, and give a RULE for it:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">C</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="n">op</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">opBool</span>

<span class="nf">opBool</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="cm">{-# NOINLINE [1] opBool #-}</span>
<span class="nf">opBool</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="o">..</span><span class="n">rhs</span> <span class="n">for</span> <span class="n">op</span> <span class="n">at</span> <span class="kt">Bool</span><span class="o">...</span>

<span class="cm">{-# RULES &quot;f&quot; opBool True y = False #-}</span>
</pre></div>
</div>
<p>If you want a RULE that truly applies to the overloaded class method,
the only way to do it is like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">op_c</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">op</span> <span class="ow">::</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="cm">{-# NOINLINE [1] op #-}</span>
<span class="nf">op</span> <span class="ow">=</span> <span class="n">op_c</span>

<span class="cm">{-# RULES &quot;reassociate&quot; op (op x y) z = op x (op y z) #-}</span>
</pre></div>
</div>
<p>Now the inlining of <code class="docutils literal"><span class="pre">op</span></code> is delayed until the rule has a chance to
fire. The down-side is that instance declarations must define <code class="docutils literal"><span class="pre">op_c</span></code>,
but all other uses should go via <code class="docutils literal"><span class="pre">op</span></code>.</p>
</div>
<div class="section" id="list-fusion">
<h2>10.32.6. List fusion<a class="headerlink" href="#list-fusion" title="Permalink to this headline">¶</a></h2>
<p>The RULES mechanism is used to implement fusion (deforestation) of
common list functions. If a &#8220;good consumer&#8221; consumes an intermediate
list constructed by a &#8220;good producer&#8221;, the intermediate list should be
eliminated entirely.</p>
<p>The following are good producers:</p>
<ul class="simple">
<li>List comprehensions</li>
<li>Enumerations of <code class="docutils literal"><span class="pre">Int</span></code>, <code class="docutils literal"><span class="pre">Integer</span></code> and <code class="docutils literal"><span class="pre">Char</span></code> (e.g.
<code class="docutils literal"><span class="pre">['a'..'z']</span></code>).</li>
<li>Explicit lists (e.g. <code class="docutils literal"><span class="pre">[True,</span> <span class="pre">False]</span></code>)</li>
<li>The cons constructor (e.g <code class="docutils literal"><span class="pre">3:4:[]</span></code>)</li>
<li><code class="docutils literal"><span class="pre">++</span></code></li>
<li><code class="docutils literal"><span class="pre">map</span></code></li>
<li><code class="docutils literal"><span class="pre">take</span></code>, <code class="docutils literal"><span class="pre">filter</span></code></li>
<li><code class="docutils literal"><span class="pre">iterate</span></code>, <code class="docutils literal"><span class="pre">repeat</span></code></li>
<li><code class="docutils literal"><span class="pre">zip</span></code>, <code class="docutils literal"><span class="pre">zipWith</span></code></li>
</ul>
<p>The following are good consumers:</p>
<ul class="simple">
<li>List comprehensions</li>
<li><code class="docutils literal"><span class="pre">array</span></code> (on its second argument)</li>
<li><code class="docutils literal"><span class="pre">++</span></code> (on its first argument)</li>
<li><code class="docutils literal"><span class="pre">foldr</span></code></li>
<li><code class="docutils literal"><span class="pre">map</span></code></li>
<li><code class="docutils literal"><span class="pre">take</span></code>, <code class="docutils literal"><span class="pre">filter</span></code></li>
<li><code class="docutils literal"><span class="pre">concat</span></code></li>
<li><code class="docutils literal"><span class="pre">unzip</span></code>, <code class="docutils literal"><span class="pre">unzip2</span></code>, <code class="docutils literal"><span class="pre">unzip3</span></code>, <code class="docutils literal"><span class="pre">unzip4</span></code></li>
<li><code class="docutils literal"><span class="pre">zip</span></code>, <code class="docutils literal"><span class="pre">zipWith</span></code> (but on one argument only; if both are good
producers, <code class="docutils literal"><span class="pre">zip</span></code> will fuse with one but not the other)</li>
<li><code class="docutils literal"><span class="pre">partition</span></code></li>
<li><code class="docutils literal"><span class="pre">head</span></code></li>
<li><code class="docutils literal"><span class="pre">and</span></code>, <code class="docutils literal"><span class="pre">or</span></code>, <code class="docutils literal"><span class="pre">any</span></code>, <code class="docutils literal"><span class="pre">all</span></code></li>
<li><code class="docutils literal"><span class="pre">sequence_</span></code></li>
<li><code class="docutils literal"><span class="pre">msum</span></code></li>
</ul>
<p>So, for example, the following should generate no intermediate lists:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">array</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]]</span>
</pre></div>
</div>
<p>This list could readily be extended; if there are Prelude functions that
you use a lot which are not included, please tell us.</p>
<p>If you want to write your own good consumers or producers, look at the
Prelude definitions of the above functions to see how to do so.</p>
</div>
<div class="section" id="specialisation">
<span id="rule-spec"></span><h2>10.32.7. Specialisation<a class="headerlink" href="#specialisation" title="Permalink to this headline">¶</a></h2>
<p>Rewrite rules can be used to get the same effect as a feature present in
earlier versions of GHC. For example, suppose that:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">genericLookup</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Table</span> <span class="n">a</span> <span class="n">b</span>   <span class="ow">-&gt;</span> <span class="n">a</span>   <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">intLookup</span>     <span class="ow">::</span>          <span class="kt">Table</span> <span class="kt">Int</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">intLookup</span></code> is an implementation of <code class="docutils literal"><span class="pre">genericLookup</span></code> that works
very fast for keys of type <code class="docutils literal"><span class="pre">Int</span></code>. You might wish to tell GHC to use
<code class="docutils literal"><span class="pre">intLookup</span></code> instead of <code class="docutils literal"><span class="pre">genericLookup</span></code> whenever the latter was
called with type <code class="docutils literal"><span class="pre">Table</span> <span class="pre">Int</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>. It used to be possible to
write</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# SPECIALIZE genericLookup :: Table Int b -&gt; Int -&gt; b = intLookup #-}</span>
</pre></div>
</div>
<p>This feature is no longer in GHC, but rewrite rules let you do the same
thing:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# RULES &quot;genericLookup/Int&quot; genericLookup = intLookup #-}</span>
</pre></div>
</div>
<p>This slightly odd-looking rule instructs GHC to replace
<code class="docutils literal"><span class="pre">genericLookup</span></code> by <code class="docutils literal"><span class="pre">intLookup</span></code> <em>whenever the types match</em>. What is
more, this rule does not need to be in the same file as
<code class="docutils literal"><span class="pre">genericLookup</span></code>, unlike the <code class="docutils literal"><span class="pre">SPECIALIZE</span></code> pragmas which currently do
(so that they have an original definition available to specialise).</p>
<p>It is <em>Your Responsibility</em> to make sure that <code class="docutils literal"><span class="pre">intLookup</span></code> really
behaves as a specialised version of <code class="docutils literal"><span class="pre">genericLookup</span></code>!!!</p>
<p>An example in which using <code class="docutils literal"><span class="pre">RULES</span></code> for specialisation will Win Big:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">toDouble</span> <span class="ow">::</span> <span class="kt">Real</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">toDouble</span> <span class="ow">=</span> <span class="n">fromRational</span> <span class="o">.</span> <span class="n">toRational</span>

<span class="cm">{-# RULES &quot;toDouble/Int&quot; toDouble = i2d #-}</span>
<span class="nf">i2d</span> <span class="p">(</span><span class="kt">I</span><span class="o">#</span> <span class="n">i</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">D</span><span class="o">#</span> <span class="p">(</span><span class="n">int2Double</span><span class="o">#</span> <span class="n">i</span><span class="p">)</span> <span class="c1">-- uses Glasgow prim-op directly</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">i2d</span></code> function is virtually one machine instruction; the default
conversion—via an intermediate <code class="docutils literal"><span class="pre">Rational</span></code>-is obscenely expensive by
comparison.</p>
</div>
<div class="section" id="controlling-what-s-going-on-in-rewrite-rules">
<span id="controlling-rules"></span><h2>10.32.8. Controlling what&#8217;s going on in rewrite rules<a class="headerlink" href="#controlling-what-s-going-on-in-rewrite-rules" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">Use <a class="reference internal" href="debugging.html#ghc-flag--ddump-rules"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-rules</span></code></a> to see the rules that are defined <em>in this
module</em>. This includes rules generated by the specialisation pass,
but excludes rules imported from other modules.</p>
</li>
<li><p class="first">Use <a class="reference internal" href="debugging.html#ghc-flag--ddump-simpl-stats"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-simpl-stats</span></code></a> to see what rules are being fired. If you
add <a class="reference internal" href="debugging.html#ghc-flag--dppr-debug"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dppr-debug</span></code></a> you get a more detailed listing.</p>
</li>
<li><p class="first">Use <a class="reference internal" href="debugging.html#ghc-flag--ddump-rule-firings"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-rule-firings</span></code></a> or <a class="reference internal" href="debugging.html#ghc-flag--ddump-rule-rewrites"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-rule-rewrites</span></code></a> to see in
great detail what rules are being fired. If you add <a class="reference internal" href="debugging.html#ghc-flag--dppr-debug"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dppr-debug</span></code></a>
you get a still more detailed listing.</p>
</li>
<li><p class="first">The definition of (say) <code class="docutils literal"><span class="pre">build</span></code> in <code class="docutils literal"><span class="pre">GHC/Base.hs</span></code> looks like
this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">build</span>   <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span><span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="cm">{-# INLINE build #-}</span>
<span class="nf">build</span> <span class="n">g</span> <span class="ow">=</span> <span class="n">g</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>Notice the <code class="docutils literal"><span class="pre">INLINE</span></code>! That prevents <code class="docutils literal"><span class="pre">(:)</span></code> from being inlined when
compiling <code class="docutils literal"><span class="pre">PrelBase</span></code>, so that an importing module will “see” the
<code class="docutils literal"><span class="pre">(:)</span></code>, and can match it on the LHS of a rule. <code class="docutils literal"><span class="pre">INLINE</span></code> prevents
any inlining happening in the RHS of the <code class="docutils literal"><span class="pre">INLINE</span></code> thing. I regret
the delicacy of this.</p>
</li>
<li><p class="first">In <code class="docutils literal"><span class="pre">libraries/base/GHC/Base.hs</span></code> look at the rules for <code class="docutils literal"><span class="pre">map</span></code> to
see how to write rules that will do fusion and yet give an efficient
program even if fusion doesn&#8217;t happen. More rules in
<code class="docutils literal"><span class="pre">GHC/List.hs</span></code>.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="special-built-in-functions">
<span id="special-ids"></span><h1>10.33. Special built-in functions<a class="headerlink" href="#special-built-in-functions" title="Permalink to this headline">¶</a></h1>
<p>GHC has a few built-in functions with special behaviour. In particular:</p>
<ul class="simple">
<li><a class="reference external" href="../libraries/base-4.10.1.0/GHC-Exts.html#v%3Ainline">inline</a>
allows control over inlining on a per-call-site basis.</li>
<li><a class="reference external" href="../libraries/base-4.10.1.0/GHC-Exts.html#v%3Alazy">lazy</a> restrains the strictness analyser.</li>
<li><a class="reference external" href="../libraries/base-4.10.1.0/GHC-Exts.html#v%3AoneShot">oneShot</a>
gives a hint to the compiler about how often a function is being
called.</li>
</ul>
</div>
<div class="section" id="generic-classes">
<span id="id88"></span><h1>10.34. Generic classes<a class="headerlink" href="#generic-classes" title="Permalink to this headline">¶</a></h1>
<p>GHC used to have an implementation of generic classes as defined in the
paper &#8220;Derivable type classes&#8221;, Ralf Hinze and Simon Peyton Jones,
Haskell Workshop, Montreal Sept 2000, pp. 94-105. These have been removed
and replaced by the more general <a class="reference external" href="#generic-programming">support for generic
programming</a>.</p>
</div>
<div class="section" id="generic-programming">
<span id="id89"></span><h1>10.35. Generic programming<a class="headerlink" href="#generic-programming" title="Permalink to this headline">¶</a></h1>
<p>Using a combination of <a class="reference internal" href="#ghc-flag--XDeriveGeneric"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveGeneric</span></code></a>,
<a class="reference internal" href="#ghc-flag--XDefaultSignatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDefaultSignatures</span></code></a>, and
<a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a>, you can easily do
datatype-generic programming using the <a class="reference external" href="../libraries/base-4.10.1.0/GHC-Generics.html">GHC.Generics</a> framework. This section gives a very brief overview of how
to do it.</p>
<p>Generic programming support in GHC allows defining classes with methods
that do not need a user specification when instantiating: the method
body is automatically derived by GHC. This is similar to what happens
for standard classes such as <code class="docutils literal"><span class="pre">Read</span></code> and <code class="docutils literal"><span class="pre">Show</span></code>, for instance, but
now for user-defined classes.</p>
<div class="section" id="deriving-representations">
<h2>10.35.1. Deriving representations<a class="headerlink" href="#deriving-representations" title="Permalink to this headline">¶</a></h2>
<p>The first thing we need is generic representations. The <code class="docutils literal"><span class="pre">GHC.Generics</span></code>
module defines a couple of primitive types that are used to represent
Haskell datatypes:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- | Unit: used for constructors without arguments</span>
<span class="kr">data</span> <span class="kt">U1</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">U1</span>

<span class="c1">-- | Constants, additional parameters and recursion of kind *</span>
<span class="kr">newtype</span> <span class="kt">K1</span> <span class="n">i</span> <span class="n">c</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">K1</span> <span class="p">{</span> <span class="n">unK1</span> <span class="ow">::</span> <span class="n">c</span> <span class="p">}</span>

<span class="c1">-- | Meta-information (constructor names, etc.)</span>
<span class="kr">newtype</span> <span class="kt">M1</span> <span class="n">i</span> <span class="n">c</span> <span class="n">f</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">M1</span> <span class="p">{</span> <span class="n">unM1</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">p</span> <span class="p">}</span>

<span class="c1">-- | Sums: encode choice between constructors</span>
<span class="kr">infixr</span> <span class="mi">5</span> <span class="kt">:+:</span>
<span class="kr">data</span> <span class="p">(</span><span class="kt">:+:</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">L1</span> <span class="p">(</span><span class="n">f</span> <span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="kt">R1</span> <span class="p">(</span><span class="n">g</span> <span class="n">p</span><span class="p">)</span>

<span class="c1">-- | Products: encode multiple arguments to constructors</span>
<span class="kr">infixr</span> <span class="mi">6</span> <span class="kt">:*:</span>
<span class="kr">data</span> <span class="p">(</span><span class="kt">:*:</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">p</span> <span class="kt">:*:</span> <span class="n">g</span> <span class="n">p</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">Generic</span></code> and <code class="docutils literal"><span class="pre">Generic1</span></code> classes mediate between user-defined
datatypes and their internal representation as a sum-of-products:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Generic</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="c1">-- Encode the representation of a user datatype</span>
  <span class="kr">type</span> <span class="kt">Rep</span> <span class="n">a</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
  <span class="c1">-- Convert from the datatype to its representation</span>
  <span class="n">from</span>  <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Rep</span> <span class="n">a</span><span class="p">)</span> <span class="n">x</span>
  <span class="c1">-- Convert from the representation to the datatype</span>
  <span class="n">to</span>    <span class="ow">::</span> <span class="p">(</span><span class="kt">Rep</span> <span class="n">a</span><span class="p">)</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="kr">class</span> <span class="kt">Generic1</span> <span class="p">(</span><span class="n">f</span> <span class="ow">::</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Rep1</span> <span class="n">f</span> <span class="ow">::</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="o">*</span>

  <span class="n">from1</span>  <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Rep1</span> <span class="n">f</span> <span class="n">a</span>
  <span class="n">to1</span>    <span class="ow">::</span> <span class="kt">Rep1</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Generic1</span></code> is used for functions that can only be defined over type
containers, such as <code class="docutils literal"><span class="pre">map</span></code>. Note that <code class="docutils literal"><span class="pre">Generic1</span></code> ranges over types of kind
<code class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code> by default, but if the <a class="reference internal" href="#ghc-flag--XPolyKinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XPolyKinds</span></code></a> extension is enabled,
then it can range of types of kind <code class="docutils literal"><span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>, for any kind <code class="docutils literal"><span class="pre">k</span></code>.</p>
<p>Instances of these classes can be derived by GHC with the
<a class="reference internal" href="#ghc-flag--XDeriveGeneric"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveGeneric</span></code></a> extension, and are necessary to be able to define
generic instances automatically.</p>
<p>For example, a user-defined datatype of trees</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">UserTree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">UserTree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">UserTree</span> <span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Leaf</span>
</pre></div>
</div>
<p>in a <code class="docutils literal"><span class="pre">Main</span></code> module in a package named <code class="docutils literal"><span class="pre">foo</span></code> will get the following
representation:</p>
<div class="highlight-haskell"><div class="highlight"><pre>instance Generic (UserTree a) where
  -- Representation type
  type Rep (UserTree a) =
    M1 D (&#39;MetaData &quot;UserTree&quot; &quot;Main&quot; &quot;package-name&quot; &#39;False) (
          M1 C (&#39;MetaCons &quot;Node&quot; &#39;PrefixI &#39;False) (
                M1 S (&#39;MetaSel &#39;Nothing
                               &#39;NoSourceUnpackedness
                               &#39;NoSourceStrictness
                               &#39;DecidedLazy)
                     (K1 R a)
            :*: M1 S (&#39;MetaSel &#39;Nothing
                               &#39;NoSourceUnpackedness
                               &#39;NoSourceStrictness
                               &#39;DecidedLazy)
                     (K1 R (UserTree a))
            :*: M1 S (&#39;MetaSel &#39;Nothing
                               &#39;NoSourceUnpackedness
                               &#39;NoSourceStrictness
                               &#39;DecidedLazy)
                     (K1 R (UserTree a)))
      :+: M1 C (&#39;MetaCons &quot;Leaf&quot; &#39;PrefixI &#39;False) U1)

  -- Conversion functions
  from (Node x l r) = M1 (L1 (M1 (M1 (K1 x) :*: M1 (K1 l) :*: M1 (K1 r))))
  from Leaf         = M1 (R1 (M1 U1))
  to (M1 (L1 (M1 (M1 (K1 x) :*: M1 (K1 l) :*: M1 (K1 r))))) = Node x l r
  to (M1 (R1 (M1 U1)))                                      = Leaf
</pre></div>
</div>
<p>This representation is generated automatically if a <code class="docutils literal"><span class="pre">deriving</span> <span class="pre">Generic</span></code>
clause is attached to the datatype. <a class="reference external" href="#stand-alone-deriving">Standalone
deriving</a> can also be used.</p>
</div>
<div class="section" id="writing-generic-functions">
<h2>10.35.2. Writing generic functions<a class="headerlink" href="#writing-generic-functions" title="Permalink to this headline">¶</a></h2>
<p>A generic function is defined by creating a class and giving instances
for each of the representation types of <code class="docutils literal"><span class="pre">GHC.Generics</span></code>. As an example
we show generic serialization:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Bin</span> <span class="ow">=</span> <span class="kt">O</span> <span class="o">|</span> <span class="kt">I</span>

<span class="kr">class</span> <span class="kt">GSerialize</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">gput</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Bin</span><span class="p">]</span>

<span class="kr">instance</span> <span class="kt">GSerialize</span> <span class="kt">U1</span> <span class="kr">where</span>
  <span class="n">gput</span> <span class="kt">U1</span> <span class="ow">=</span> <span class="kt">[]</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">GSerialize</span> <span class="n">a</span><span class="p">,</span> <span class="kt">GSerialize</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">GSerialize</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:*:</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">gput</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:*:</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">gput</span> <span class="n">x</span> <span class="o">++</span> <span class="n">gput</span> <span class="n">y</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">GSerialize</span> <span class="n">a</span><span class="p">,</span> <span class="kt">GSerialize</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">GSerialize</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:+:</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">gput</span> <span class="p">(</span><span class="kt">L1</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">O</span> <span class="kt">:</span> <span class="n">gput</span> <span class="n">x</span>
  <span class="n">gput</span> <span class="p">(</span><span class="kt">R1</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">I</span> <span class="kt">:</span> <span class="n">gput</span> <span class="n">x</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">GSerialize</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">GSerialize</span> <span class="p">(</span><span class="kt">M1</span> <span class="n">i</span> <span class="n">c</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">gput</span> <span class="p">(</span><span class="kt">M1</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">gput</span> <span class="n">x</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Serialize</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">GSerialize</span> <span class="p">(</span><span class="kt">K1</span> <span class="n">i</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">gput</span> <span class="p">(</span><span class="kt">K1</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">put</span> <span class="n">x</span>
</pre></div>
</div>
<p>Typically this class will not be exported, as it only makes sense to
have instances for the representation types.</p>
</div>
<div class="section" id="unlifted-representation-types">
<h2>10.35.3. Unlifted representation types<a class="headerlink" href="#unlifted-representation-types" title="Permalink to this headline">¶</a></h2>
<p>The data family <code class="docutils literal"><span class="pre">URec</span></code> is provided to enable generic programming over
datatypes with certain unlifted arguments. There are six instances corresponding
to common unlifted types:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">family</span> <span class="kt">URec</span> <span class="n">a</span> <span class="n">p</span>

<span class="kr">data</span> <span class="kr">instance</span> <span class="kt">URec</span> <span class="p">(</span><span class="kt">Ptr</span> <span class="nb">()</span><span class="p">)</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">UAddr</span>   <span class="p">{</span> <span class="n">uAddr</span><span class="o">#</span>   <span class="ow">::</span> <span class="kt">Addr</span><span class="o">#</span>   <span class="p">}</span>
<span class="kr">data</span> <span class="kr">instance</span> <span class="kt">URec</span> <span class="kt">Char</span>     <span class="n">p</span> <span class="ow">=</span> <span class="kt">UChar</span>   <span class="p">{</span> <span class="n">uChar</span><span class="o">#</span>   <span class="ow">::</span> <span class="kt">Char</span><span class="o">#</span>   <span class="p">}</span>
<span class="kr">data</span> <span class="kr">instance</span> <span class="kt">URec</span> <span class="kt">Double</span>   <span class="n">p</span> <span class="ow">=</span> <span class="kt">UDouble</span> <span class="p">{</span> <span class="n">uDouble</span><span class="o">#</span> <span class="ow">::</span> <span class="kt">Double</span><span class="o">#</span> <span class="p">}</span>
<span class="kr">data</span> <span class="kr">instance</span> <span class="kt">URec</span> <span class="kt">Int</span>      <span class="n">p</span> <span class="ow">=</span> <span class="kt">UInt</span>    <span class="p">{</span> <span class="n">uInt</span><span class="o">#</span>    <span class="ow">::</span> <span class="kt">Int</span><span class="o">#</span>    <span class="p">}</span>
<span class="kr">data</span> <span class="kr">instance</span> <span class="kt">URec</span> <span class="kt">Float</span>    <span class="n">p</span> <span class="ow">=</span> <span class="kt">UFloat</span>  <span class="p">{</span> <span class="n">uFloat</span><span class="o">#</span>  <span class="ow">::</span> <span class="kt">Float</span><span class="o">#</span>  <span class="p">}</span>
<span class="kr">data</span> <span class="kr">instance</span> <span class="kt">URec</span> <span class="kt">Word</span>     <span class="n">p</span> <span class="ow">=</span> <span class="kt">UWord</span>   <span class="p">{</span> <span class="n">uWord</span><span class="o">#</span>   <span class="ow">::</span> <span class="kt">Word</span><span class="o">#</span>   <span class="p">}</span>
</pre></div>
</div>
<p>Six type synonyms are provided for convenience:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">UAddr</span>   <span class="ow">=</span> <span class="kt">URec</span> <span class="p">(</span><span class="kt">Ptr</span> <span class="nb">()</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">UChar</span>   <span class="ow">=</span> <span class="kt">URec</span> <span class="kt">Char</span>
<span class="kr">type</span> <span class="kt">UDouble</span> <span class="ow">=</span> <span class="kt">URec</span> <span class="kt">Double</span>
<span class="kr">type</span> <span class="kt">UFloat</span>  <span class="ow">=</span> <span class="kt">URec</span> <span class="kt">Float</span>
<span class="kr">type</span> <span class="kt">UInt</span>    <span class="ow">=</span> <span class="kt">URec</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">UWord</span>   <span class="ow">=</span> <span class="kt">URec</span> <span class="kt">Word</span>
</pre></div>
</div>
<p>As an example, this data declaration:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">IntHash</span> <span class="ow">=</span> <span class="kt">IntHash</span> <span class="kt">Int</span><span class="o">#</span>
  <span class="kr">deriving</span> <span class="kt">Generic</span>
</pre></div>
</div>
<p>results in the following <code class="docutils literal"><span class="pre">Generic</span></code> instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre>instance &#39;Generic&#39; IntHash where
  type &#39;Rep&#39; IntHash =
    &#39;D1&#39; (&#39;MetaData &quot;IntHash&quot; &quot;Main&quot; &quot;package-name&quot; &#39;False)
      (&#39;C1&#39; (&#39;MetaCons &quot;IntHash&quot; &#39;PrefixI &#39;False)
        (&#39;S1&#39; (&#39;MetaSel &#39;Nothing
                        &#39;NoSourceUnpackedness
                        &#39;NoSourceStrictness
                        &#39;DecidedLazy)
              &#39;UInt&#39;))
</pre></div>
</div>
<p>A user could provide, for example, a <code class="docutils literal"><span class="pre">GSerialize</span> <span class="pre">UInt</span></code> instance so that a
<code class="docutils literal"><span class="pre">Serialize</span> <span class="pre">IntHash</span></code> instance could be easily defined in terms of
<code class="docutils literal"><span class="pre">GSerialize</span></code>.</p>
</div>
<div class="section" id="generic-defaults">
<h2>10.35.4. Generic defaults<a class="headerlink" href="#generic-defaults" title="Permalink to this headline">¶</a></h2>
<p>The only thing left to do now is to define a &#8220;front-end&#8221; class, which is
exposed to the user:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Serialize</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">put</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Bin</span><span class="p">]</span>

  <span class="kr">default</span> <span class="n">put</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Generic</span> <span class="n">a</span><span class="p">,</span> <span class="kt">GSerialize</span> <span class="p">(</span><span class="kt">Rep</span> <span class="n">a</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Bit</span><span class="p">]</span>
  <span class="n">put</span> <span class="ow">=</span> <span class="n">gput</span> <span class="o">.</span> <span class="n">from</span>
</pre></div>
</div>
<p>Here we use a <a class="reference external" href="#class-default-signatures">default signature</a> to
specify that the user does not have to provide an implementation for
<code class="docutils literal"><span class="pre">put</span></code>, as long as there is a <code class="docutils literal"><span class="pre">Generic</span></code> instance for the type to
instantiate. For the <code class="docutils literal"><span class="pre">UserTree</span></code> type, for instance, the user can just
write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Serialize</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serialize</span> <span class="p">(</span><span class="kt">UserTree</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The default method for <code class="docutils literal"><span class="pre">put</span></code> is then used, corresponding to the
generic implementation of serialization. If you are using
<a class="reference internal" href="#ghc-flag--XDeriveAnyClass"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XDeriveAnyClass</span></code></a>, the same instance is generated by simply attaching
a <code class="docutils literal"><span class="pre">deriving</span> <span class="pre">Serialize</span></code> clause to the <code class="docutils literal"><span class="pre">UserTree</span></code> datatype
declaration. For more examples of generic functions please refer to the
<a class="reference external" href="http://hackage.haskell.org/package/generic-deriving">generic-deriving</a>
package on Hackage.</p>
</div>
<div class="section" id="more-information">
<h2>10.35.5. More information<a class="headerlink" href="#more-information" title="Permalink to this headline">¶</a></h2>
<p>For more details please refer to the <a class="reference external" href="http://www.haskell.org/haskellwiki/GHC.Generics">Haskell Wiki
page</a> or the
original paper <a class="reference internal" href="#generics2010" id="id90">[Generics2010]</a>.</p>
<table class="docutils citation" frame="void" id="generics2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id90">[Generics2010]</a></td><td>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh.
<a class="reference external" href="http://dreixel.net/research/pdf/gdmh.pdf">A generic deriving mechanism for Haskell</a>. Proceedings of
the third ACM Haskell symposium on Haskell (Haskell&#8216;2010), pp. 37-48,
ACM, 2010.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="roles">
<span id="id91"></span><h1>10.36. Roles<a class="headerlink" href="#roles" title="Permalink to this headline">¶</a></h1>
<p id="index-43">Using <a class="reference internal" href="#ghc-flag--XGeneralizedNewtypeDeriving"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XGeneralizedNewtypeDeriving</span></code></a>
(<a class="reference internal" href="#generalized-newtype-deriving"><span>Generalising the deriving clause</span></a>), a programmer can take existing
instances of classes and &#8220;lift&#8221; these into instances of that class for a
newtype. However, this is not always safe. For example, consider the
following:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Age</span> <span class="ow">=</span> <span class="kt">MkAge</span> <span class="p">{</span> <span class="n">unAge</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>

<span class="kr">type</span> <span class="n">family</span> <span class="kt">Inspect</span> <span class="n">x</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Inspect</span> <span class="kt">Age</span> <span class="ow">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Inspect</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Bool</span>

<span class="kr">class</span> <span class="kt">BadIdea</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">bad</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Inspect</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">BadIdea</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="n">bad</span> <span class="ow">=</span> <span class="p">(</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

<span class="kr">deriving</span> <span class="kr">instance</span> <span class="kt">BadIdea</span> <span class="kt">Age</span>    <span class="c1">-- not allowed!</span>
</pre></div>
</div>
<p>If the derived instance were allowed, what would the type of its method
<code class="docutils literal"><span class="pre">bad</span></code> be? It would seem to be <code class="docutils literal"><span class="pre">Age</span> <span class="pre">-&gt;</span> <span class="pre">Inspect</span> <span class="pre">Age</span></code>, which is
equivalent to <code class="docutils literal"><span class="pre">Age</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>, according to the type family <code class="docutils literal"><span class="pre">Inspect</span></code>.
Yet, if we simply adapt the implementation from the instance for
<code class="docutils literal"><span class="pre">Int</span></code>, the implementation for <code class="docutils literal"><span class="pre">bad</span></code> produces a <code class="docutils literal"><span class="pre">Bool</span></code>, and we have
trouble.</p>
<p>The way to identify such situations is to have <em>roles</em> assigned to type
variables of datatypes, classes, and type synonyms.</p>
<p>Roles as implemented in GHC are a from a simplified version of the work
described in <a class="reference external" href="http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf">Generative type abstraction and type-level
computation</a>,
published at POPL 2011.</p>
<div class="section" id="nominal-representational-and-phantom">
<span id="id92"></span><h2>10.36.1. Nominal, Representational, and Phantom<a class="headerlink" href="#nominal-representational-and-phantom" title="Permalink to this headline">¶</a></h2>
<p id="index-44">The goal of the roles system is to track when two types have the same
underlying representation. In the example above, <code class="docutils literal"><span class="pre">Age</span></code> and <code class="docutils literal"><span class="pre">Int</span></code>
have the same representation. But, the corresponding instances of
<code class="docutils literal"><span class="pre">BadIdea</span></code> would <em>not</em> have the same representation, because the types
of the implementations of <code class="docutils literal"><span class="pre">bad</span></code> would be different.</p>
<p>Suppose we have two uses of a type constructor, each applied to the same
parameters except for one difference. (For example, <code class="docutils literal"><span class="pre">T</span> <span class="pre">Age</span> <span class="pre">Bool</span> <span class="pre">c</span></code> and
<code class="docutils literal"><span class="pre">T</span> <span class="pre">Int</span> <span class="pre">Bool</span> <span class="pre">c</span></code> for some type <code class="docutils literal"><span class="pre">T</span></code>.) The role of a type parameter says
what we need to know about the two differing type arguments in order to
know that the two outer types have the same representation (in the
example, what must be true about <code class="docutils literal"><span class="pre">Age</span></code> and <code class="docutils literal"><span class="pre">Int</span></code> in order to show
that <code class="docutils literal"><span class="pre">T</span> <span class="pre">Age</span> <span class="pre">Bool</span> <span class="pre">c</span></code> has the same representation as <code class="docutils literal"><span class="pre">T</span> <span class="pre">Int</span> <span class="pre">Bool</span> <span class="pre">c</span></code>).</p>
<p>GHC supports three different roles for type parameters: nominal,
representational, and phantom. If a type parameter has a nominal role,
then the two types that differ must not actually differ at all: they
must be identical (after type family reduction). If a type parameter has
a representational role, then the two types must have the same
representation. (If <code class="docutils literal"><span class="pre">T</span></code>&#8216;s first parameter&#8217;s role is representational,
then <code class="docutils literal"><span class="pre">T</span> <span class="pre">Age</span> <span class="pre">Bool</span> <span class="pre">c</span></code> and <code class="docutils literal"><span class="pre">T</span> <span class="pre">Int</span> <span class="pre">Bool</span> <span class="pre">c</span></code> would have the same
representation, because <code class="docutils literal"><span class="pre">Age</span></code> and <code class="docutils literal"><span class="pre">Int</span></code> have the same
representation.) If a type parameter has a phantom role, then we need no
further information.</p>
<p>Here are some examples:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Simple</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkSimple</span> <span class="n">a</span>          <span class="c1">-- a has role representational</span>

<span class="kr">type</span> <span class="n">family</span> <span class="kt">F</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="kt">Bool</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="kt">Age</span> <span class="ow">=</span> <span class="kt">Char</span>

<span class="kr">data</span> <span class="kt">Complex</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkComplex</span> <span class="p">(</span><span class="kt">F</span> <span class="n">a</span><span class="p">)</span>    <span class="c1">-- a has role nominal</span>

<span class="kr">data</span> <span class="kt">Phant</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkPhant</span> <span class="kt">Bool</span>         <span class="c1">-- a has role phantom</span>
</pre></div>
</div>
<p>The type <code class="docutils literal"><span class="pre">Simple</span></code> has its parameter at role representational, which is
generally the most common case. <code class="docutils literal"><span class="pre">Simple</span> <span class="pre">Age</span></code> would have the same
representation as <code class="docutils literal"><span class="pre">Simple</span> <span class="pre">Int</span></code>. The type <code class="docutils literal"><span class="pre">Complex</span></code>, on the other
hand, has its parameter at role nominal, because <code class="docutils literal"><span class="pre">Simple</span> <span class="pre">Age</span></code> and
<code class="docutils literal"><span class="pre">Simple</span> <span class="pre">Int</span></code> are <em>not</em> the same. Lastly, <code class="docutils literal"><span class="pre">Phant</span> <span class="pre">Age</span></code> and
<code class="docutils literal"><span class="pre">Phant</span> <span class="pre">Bool</span></code> have the same representation, even though <code class="docutils literal"><span class="pre">Age</span></code> and
<code class="docutils literal"><span class="pre">Bool</span></code> are unrelated.</p>
</div>
<div class="section" id="role-inference">
<span id="id93"></span><h2>10.36.2. Role inference<a class="headerlink" href="#role-inference" title="Permalink to this headline">¶</a></h2>
<p>What role should a given type parameter should have? GHC performs role
inference to determine the correct role for every parameter. It starts
with a few base facts: <code class="docutils literal"><span class="pre">(-&gt;)</span></code> has two representational parameters;
<code class="docutils literal"><span class="pre">(~)</span></code> has two nominal parameters; all type families&#8217; parameters are
nominal; and all GADT-like parameters are nominal. Then, these facts are
propagated to all places where these types are used. The default role
for datatypes and synonyms is phantom; the default role for classes is
nominal. Thus, for datatypes and synonyms, any parameters unused in the
right-hand side (or used only in other types in phantom positions) will
be phantom. Whenever a parameter is used in a representational position
(that is, used as a type argument to a constructor whose corresponding
variable is at role representational), we raise its role from phantom to
representational. Similarly, when a parameter is used in a nominal
position, its role is upgraded to nominal. We never downgrade a role
from nominal to phantom or representational, or from representational to
phantom. In this way, we infer the most-general role for each parameter.</p>
<p>Classes have their roles default to nominal to promote coherence of
class instances. If a <code class="docutils literal"><span class="pre">C</span> <span class="pre">Int</span></code> were stored in a datatype, it would be
quite bad if that were somehow changed into a <code class="docutils literal"><span class="pre">C</span> <span class="pre">Age</span></code> somewhere,
especially if another <code class="docutils literal"><span class="pre">C</span> <span class="pre">Age</span></code> had been declared!</p>
<p>There is one particularly tricky case that should be explained:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Tricky</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">MkTricky</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>What should <code class="docutils literal"><span class="pre">Tricky</span></code>&#8216;s roles be? At first blush, it would seem that
both <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> should be at role representational, since both are
used in the right-hand side and neither is involved in a type family.
However, this would be wrong, as the following example shows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Nom</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkNom</span> <span class="p">(</span><span class="kt">F</span> <span class="n">a</span><span class="p">)</span>   <span class="c1">-- type family F from example above</span>
</pre></div>
</div>
<p>Is <code class="docutils literal"><span class="pre">Tricky</span> <span class="pre">Nom</span> <span class="pre">Age</span></code> representationally equal to <code class="docutils literal"><span class="pre">Tricky</span> <span class="pre">Nom</span> <span class="pre">Int</span></code>?
No! The former stores a <code class="docutils literal"><span class="pre">Char</span></code> and the latter stores a <code class="docutils literal"><span class="pre">Bool</span></code>. The
solution to this is to require all parameters to type variables to have
role nominal. Thus, GHC would infer role representational for <code class="docutils literal"><span class="pre">a</span></code> but
role nominal for <code class="docutils literal"><span class="pre">b</span></code>.</p>
</div>
<div class="section" id="role-annotations">
<span id="id94"></span><h2>10.36.3. Role annotations<a class="headerlink" href="#role-annotations" title="Permalink to this headline">¶</a></h2>
<dl class="ghc-flag">
<dt id="ghc-flag--XRoleAnnotations">
<code class="descname">-XRoleAnnotations</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--XRoleAnnotations" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">7.8.1</td>
</tr>
</tbody>
</table>
<p>Allow role annotation syntax.</p>
</dd></dl>

<p>Sometimes the programmer wants to constrain the inference process. For
example, the base library contains the following definition:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Ptr</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Ptr</span> <span class="kt">Addr</span><span class="o">#</span>
</pre></div>
</div>
<p>The idea is that <code class="docutils literal"><span class="pre">a</span></code> should really be a representational parameter,
but role inference assigns it to phantom. This makes some level of
sense: a pointer to an <code class="docutils literal"><span class="pre">Int</span></code> really is representationally the same as
a pointer to a <code class="docutils literal"><span class="pre">Bool</span></code>. But, that&#8217;s not at all how we want to use
<code class="docutils literal"><span class="pre">Ptr</span></code>s! So, we want to be able to say</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">role</span> <span class="kt">Ptr</span> <span class="n">representational</span>
<span class="kr">data</span> <span class="kt">Ptr</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Ptr</span> <span class="kt">Addr</span><span class="o">#</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">type</span> <span class="pre">role</span></code> (enabled with <a class="reference internal" href="#ghc-flag--XRoleAnnotations"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XRoleAnnotations</span></code></a>) declaration
forces the parameter <code class="docutils literal"><span class="pre">a</span></code> to be at role representational, not role
phantom. GHC then checks the user-supplied roles to make sure they don&#8217;t
break any promises. It would be bad, for example, if the user could make
<code class="docutils literal"><span class="pre">BadIdea</span></code>&#8216;s role be representational.</p>
<p>As another example, we can consider a type <code class="docutils literal"><span class="pre">Set</span> <span class="pre">a</span></code> that represents a
set of data, ordered according to <code class="docutils literal"><span class="pre">a</span></code>&#8216;s <code class="docutils literal"><span class="pre">Ord</span></code> instance. While it
would generally be type-safe to consider <code class="docutils literal"><span class="pre">a</span></code> to be at role
representational, it is possible that a <code class="docutils literal"><span class="pre">newtype</span></code> and its base type
have <em>different</em> orderings encoded in their respective <code class="docutils literal"><span class="pre">Ord</span></code>
instances. This would lead to misbehavior at runtime. So, the author of
the <code class="docutils literal"><span class="pre">Set</span></code> datatype would like its parameter to be at role nominal.
This would be done with a declaration</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">role</span> <span class="kt">Set</span> <span class="n">nominal</span>
</pre></div>
</div>
<p>Role annotations can also be used should a programmer wish to write a
class with a representational (or phantom) role. However, as a class
with non-nominal roles can quickly lead to class instance incoherence,
it is necessary to also specify <a class="reference internal" href="#ghc-flag--XIncoherentInstances"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XIncoherentInstances</span></code></a> to allow
non-nominal roles for classes.</p>
<p>The other place where role annotations may be necessary are in
<code class="docutils literal"><span class="pre">hs-boot</span></code> files (<a class="reference internal" href="separate_compilation.html#mutual-recursion"><span>How to compile mutually recursive modules</span></a>), where the right-hand sides
of definitions can be omitted. As usual, the types/classes declared in
an <code class="docutils literal"><span class="pre">hs-boot</span></code> file must match up with the definitions in the <code class="docutils literal"><span class="pre">hs</span></code>
file, including down to the roles. The default role for datatypes is
representational in <code class="docutils literal"><span class="pre">hs-boot</span></code> files, corresponding to the common use
case.</p>
<p>Role annotations are allowed on data, newtype, and class declarations. A
role annotation declaration starts with <code class="docutils literal"><span class="pre">type</span> <span class="pre">role</span></code> and is followed by
one role listing for each parameter of the type. (This parameter count
includes parameters implicitly specified by a kind signature in a
GADT-style data or newtype declaration.) Each role listing is a role
(<code class="docutils literal"><span class="pre">nominal</span></code>, <code class="docutils literal"><span class="pre">representational</span></code>, or <code class="docutils literal"><span class="pre">phantom</span></code>) or a <code class="docutils literal"><span class="pre">_</span></code>. Using a
<code class="docutils literal"><span class="pre">_</span></code> says that GHC should infer that role. The role annotation may go
anywhere in the same module as the datatype or class definition (much
like a value-level type signature). Here are some examples:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="n">role</span> <span class="kt">T1</span> <span class="kr">_</span> <span class="n">phantom</span>
<span class="kr">data</span> <span class="kt">T1</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">MkT1</span> <span class="n">a</span>     <span class="c1">-- b is not used; annotation is fine but unnecessary</span>

<span class="kr">type</span> <span class="n">role</span> <span class="kt">T2</span> <span class="kr">_</span> <span class="n">phantom</span>
<span class="kr">data</span> <span class="kt">T2</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">MkT2</span> <span class="n">b</span>     <span class="c1">-- ERROR: b is used and cannot be phantom</span>

<span class="kr">type</span> <span class="n">role</span> <span class="kt">T3</span> <span class="kr">_</span> <span class="n">nominal</span>
<span class="kr">data</span> <span class="kt">T3</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">MkT3</span> <span class="n">a</span>     <span class="c1">-- OK: nominal is higher than necessary, but safe</span>

<span class="kr">type</span> <span class="n">role</span> <span class="kt">T4</span> <span class="n">nominal</span>
<span class="kr">data</span> <span class="kt">T4</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MkT4</span> <span class="p">(</span><span class="n">a</span> <span class="kt">Int</span><span class="p">)</span> <span class="c1">-- OK, but nominal is higher than necessary</span>

<span class="kr">type</span> <span class="n">role</span> <span class="kt">C</span> <span class="n">representational</span> <span class="kr">_</span>   <span class="c1">-- OK, with -XIncoherentInstances</span>
<span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span> <span class="o">...</span>    <span class="c1">-- OK, b will get a nominal role</span>

<span class="kr">type</span> <span class="n">role</span> <span class="kt">X</span> <span class="n">nominal</span>
<span class="kr">type</span> <span class="kt">X</span> <span class="n">a</span> <span class="ow">=</span> <span class="o">...</span>           <span class="c1">-- ERROR: role annotations not allowed for type synonyms</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="hascallstack">
<span id="id95"></span><h1>10.37. HasCallStack<a class="headerlink" href="#hascallstack" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal"><span class="pre">GHC.Stack.HasCallStack</span></code> is a lightweight method of obtaining a
partial call-stack at any point in the program.</p>
<p>A function can request its call-site with the <code class="docutils literal"><span class="pre">HasCallStack</span></code> constraint.
For example, we can define</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">errorWithCallStack</span> <span class="ow">::</span> <span class="kt">HasCallStack</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>as a variant of <code class="docutils literal"><span class="pre">error</span></code> that will get its call-site (as of GHC 8.0,
<code class="docutils literal"><span class="pre">error</span></code> already gets its call-site, but let&#8217;s assume for the sake of
demonstration that it does not). We can access the call-stack inside
<code class="docutils literal"><span class="pre">errorWithCallStack</span></code> with <code class="docutils literal"><span class="pre">GHC.Stack.callStack</span></code>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">errorWithCallStack</span> <span class="ow">::</span> <span class="kt">HasCallStack</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">errorWithCallStack</span> <span class="n">msg</span> <span class="ow">=</span> <span class="ne">error</span> <span class="p">(</span><span class="n">msg</span> <span class="o">++</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">++</span> <span class="n">prettyCallStack</span> <span class="n">callStack</span><span class="p">)</span>
</pre></div>
</div>
<p>Thus, if we call <code class="docutils literal"><span class="pre">errorWithCallStack</span></code> we will get a formatted call-stack
alongside our error message.</p>
<div class="highlight-none"><div class="highlight"><pre>ghci&gt; errorWithCallStack &quot;die&quot;
*** Exception: die
CallStack (from HasCallStack):
  errorWithCallStack, called at &lt;interactive&gt;:2:1 in interactive:Ghci1
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">CallStack</span></code> will only extend as far as the types allow it, for
example</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">myHead</span> <span class="ow">::</span> <span class="kt">HasCallStack</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">myHead</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">errorWithCallStack</span> <span class="s">&quot;empty&quot;</span>
<span class="nf">myHead</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>

<span class="nf">bad</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">bad</span> <span class="ow">=</span> <span class="n">myHead</span> <span class="kt">[]</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>ghci&gt; bad
*** Exception: empty
CallStack (from HasCallStack):
  errorWithCallStack, called at Bad.hs:8:15 in main:Bad
  myHead, called at Bad.hs:12:7 in main:Bad
</pre></div>
</div>
<p>includes the call-site of <code class="docutils literal"><span class="pre">errorWithCallStack</span></code> in <code class="docutils literal"><span class="pre">myHead</span></code>, and of
<code class="docutils literal"><span class="pre">myHead</span></code> in <code class="docutils literal"><span class="pre">bad</span></code>, but not the call-site of <code class="docutils literal"><span class="pre">bad</span></code> at the GHCi
prompt.</p>
<p>GHC solves <code class="docutils literal"><span class="pre">HasCallStack</span></code> constraints in two steps:</p>
<ol class="arabic simple">
<li>If there is a <code class="docutils literal"><span class="pre">CallStack</span></code> in scope &#8211; i.e. the enclosing definition
has a <code class="docutils literal"><span class="pre">HasCallStack</span></code> constraint &#8211; GHC will push the new call-site
onto the existing <code class="docutils literal"><span class="pre">CallStack</span></code>.</li>
<li>Otherwise GHC will solve the <code class="docutils literal"><span class="pre">HasCallStack</span></code> constraint for the
singleton <code class="docutils literal"><span class="pre">CallStack</span></code> containing just the current call-site.</li>
</ol>
<p>Importantly, GHC will <strong>never</strong> infer a <code class="docutils literal"><span class="pre">HasCallStack</span></code> constraint,
you must request it explicitly.</p>
<p><code class="docutils literal"><span class="pre">CallStack</span></code> is kept abstract, but GHC provides a function</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getCallStack</span> <span class="ow">::</span> <span class="kt">CallStack</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">SrcLoc</span><span class="p">)]</span>
</pre></div>
</div>
<p>to access the individual call-sites in the stack. The <code class="docutils literal"><span class="pre">String</span></code> is the
name of the function that was called, and the <code class="docutils literal"><span class="pre">SrcLoc</span></code> provides the
package, module, and file name, as well as the line and column numbers.</p>
<p><code class="docutils literal"><span class="pre">GHC.Stack</span></code> additionally exports a function <code class="docutils literal"><span class="pre">withFrozenCallStack</span></code> that
allows users to freeze the current <code class="docutils literal"><span class="pre">CallStack</span></code>, preventing any future push
operations from having an effect. This can be used by library authors
to prevent <code class="docutils literal"><span class="pre">CallStack</span></code>s from exposing unnecessary implementation
details. Consider the <code class="docutils literal"><span class="pre">myHead</span></code> example above, the <code class="docutils literal"><span class="pre">errorWithCallStack</span></code> line in
the printed stack is not particularly enlightening, so we might choose
to suppress it by freezing the <code class="docutils literal"><span class="pre">CallStack</span></code> that we pass to <code class="docutils literal"><span class="pre">errorWithCallStack</span></code>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">myHead</span> <span class="ow">::</span> <span class="kt">HasCallStack</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">myHead</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">withFrozenCallStack</span> <span class="p">(</span><span class="n">errorWithCallStack</span> <span class="s">&quot;empty&quot;</span><span class="p">)</span>
<span class="nf">myHead</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>ghci&gt; myHead []
*** Exception: empty
CallStack (from HasCallStack):
  myHead, called at Bad.hs:12:7 in main:Bad
</pre></div>
</div>
<p><strong>NOTE</strong>: The intrepid user may notice that <code class="docutils literal"><span class="pre">HasCallStack</span></code> is just an
alias for an implicit parameter <code class="docutils literal"><span class="pre">?callStack</span> <span class="pre">::</span> <span class="pre">CallStack</span></code>. This is an
implementation detail and <strong>should not</strong> be considered part of the
<code class="docutils literal"><span class="pre">CallStack</span></code> API, we may decide to change the implementation in the
future.</p>
<div class="section" id="compared-with-other-sources-of-stack-traces">
<h2>10.37.1. Compared with other sources of stack traces<a class="headerlink" href="#compared-with-other-sources-of-stack-traces" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">HasCallStack</span></code> does not interact with the RTS and does not require
compilation with <code class="docutils literal"><span class="pre">-prof</span></code>. On the other hand, as the <code class="docutils literal"><span class="pre">CallStack</span></code> is
built up explicitly via the <code class="docutils literal"><span class="pre">HasCallStack</span></code> constraints, it will
generally not contain as much information as the simulated call-stacks
maintained by the RTS.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="parallel.html" title="10.38. Concurrent and Parallel Haskell"
             >next</a> |</li>
        <li class="right" >
          <a href="lang.html" title="10. GHC Language Features"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.2.2 User&#39;s Guide</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="lang.html" >10. GHC Language Features</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, GHC Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>